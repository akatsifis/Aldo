diff --git a/Aldo Watch App Watch App/Aldo_Watch_AppApp.swift b/Aldo Watch App Watch App/Aldo_Watch_AppApp.swift
new file mode 100644
index 0000000..9326ce7
--- /dev/null
+++ b/Aldo Watch App Watch App/Aldo_Watch_AppApp.swift	
@@ -0,0 +1,20 @@
+//
+//  Aldo_Watch_AppApp.swift
+//  Aldo Watch App Watch App
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import SwiftUI
+
+@main
+struct Aldo_Watch_AppApp: App {
+    @StateObject private var workoutManager = WatchWorkoutManager()
+
+    var body: some Scene {
+        WindowGroup {
+            ContentView()
+                .environmentObject(workoutManager)
+        }
+    }
+}
diff --git a/Aldo Watch App Watch App/Assets.xcassets/AccentColor.colorset/Contents.json b/Aldo Watch App Watch App/Assets.xcassets/AccentColor.colorset/Contents.json
new file mode 100644
index 0000000..eb87897
--- /dev/null
+++ b/Aldo Watch App Watch App/Assets.xcassets/AccentColor.colorset/Contents.json	
@@ -0,0 +1,11 @@
+{
+  "colors" : [
+    {
+      "idiom" : "universal"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo Watch App Watch App/Assets.xcassets/AppIcon.appiconset/Contents.json b/Aldo Watch App Watch App/Assets.xcassets/AppIcon.appiconset/Contents.json
new file mode 100644
index 0000000..0bce061
--- /dev/null
+++ b/Aldo Watch App Watch App/Assets.xcassets/AppIcon.appiconset/Contents.json	
@@ -0,0 +1,14 @@
+{
+  "images" : [
+    {
+      "filename" : "unnamed copy.jpg",
+      "idiom" : "universal",
+      "platform" : "watchos",
+      "size" : "1024x1024"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo Watch App Watch App/Assets.xcassets/AppIcon.appiconset/unnamed copy.jpg b/Aldo Watch App Watch App/Assets.xcassets/AppIcon.appiconset/unnamed copy.jpg
new file mode 100644
index 0000000..19ba896
Binary files /dev/null and b/Aldo Watch App Watch App/Assets.xcassets/AppIcon.appiconset/unnamed copy.jpg differ
diff --git a/Aldo Watch App Watch App/Assets.xcassets/Contents.json b/Aldo Watch App Watch App/Assets.xcassets/Contents.json
new file mode 100644
index 0000000..73c0059
--- /dev/null
+++ b/Aldo Watch App Watch App/Assets.xcassets/Contents.json	
@@ -0,0 +1,6 @@
+{
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo Watch App Watch App/Assets.xcassets/Golf.imageset/Contents.json b/Aldo Watch App Watch App/Assets.xcassets/Golf.imageset/Contents.json
new file mode 100644
index 0000000..3a69017
--- /dev/null
+++ b/Aldo Watch App Watch App/Assets.xcassets/Golf.imageset/Contents.json	
@@ -0,0 +1,21 @@
+{
+  "images" : [
+    {
+      "filename" : "golf-golf-tournament-golf-course-golf-players.jpg",
+      "idiom" : "universal",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo Watch App Watch App/Assets.xcassets/Golf.imageset/golf-golf-tournament-golf-course-golf-players.jpg b/Aldo Watch App Watch App/Assets.xcassets/Golf.imageset/golf-golf-tournament-golf-course-golf-players.jpg
new file mode 100644
index 0000000..2faa202
Binary files /dev/null and b/Aldo Watch App Watch App/Assets.xcassets/Golf.imageset/golf-golf-tournament-golf-course-golf-players.jpg differ
diff --git a/Aldo Watch App Watch App/ContentView.swift b/Aldo Watch App Watch App/ContentView.swift
new file mode 100644
index 0000000..b90f382
--- /dev/null
+++ b/Aldo Watch App Watch App/ContentView.swift	
@@ -0,0 +1,33 @@
+//  ContentView.swift
+//  Aldo Watch App Watch App
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import SwiftUI
+
+struct ContentView: View {
+    @EnvironmentObject var workoutManager: WatchWorkoutManager
+
+    var body: some View {
+        VStack {
+            Text("Steps: \(workoutManager.steps)")
+                .foregroundColor(.white)
+            Text("Distance: \(String(format: "%.2f", workoutManager.distance)) miles")
+                .foregroundColor(.white)
+            Text("Calories: \(String(format: "%.2f", workoutManager.caloriesBurned)) kcal")
+                .foregroundColor(.white)
+        }
+        .padding()
+        .background(
+            Image("Golf")
+                .resizable()
+                .scaledToFill()
+        )
+    }
+}
+
+#Preview {
+    ContentView()
+        .environmentObject(WatchWorkoutManager())
+}
diff --git a/Aldo Watch App Watch App/Preview Content/Preview Assets.xcassets/Contents.json b/Aldo Watch App Watch App/Preview Content/Preview Assets.xcassets/Contents.json
new file mode 100644
index 0000000..73c0059
--- /dev/null
+++ b/Aldo Watch App Watch App/Preview Content/Preview Assets.xcassets/Contents.json	
@@ -0,0 +1,6 @@
+{
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo Watch App Watch App/WorkoutView.swift b/Aldo Watch App Watch App/WorkoutView.swift
new file mode 100644
index 0000000..bffb7d7
--- /dev/null
+++ b/Aldo Watch App Watch App/WorkoutView.swift	
@@ -0,0 +1,50 @@
+//
+//  WorkoutView.swift
+//  Aldo Watch App
+//
+//  Created by Andrew Katsifis on 6/23/24.
+//
+import SwiftUI
+import HealthKit
+
+struct WorkoutView: View {
+    @ObservedObject var workoutManager: WatchWorkoutManager
+
+    var body: some View {
+        VStack {
+            Text("Workout Metrics")
+                .font(.headline)
+                .padding(.bottom, 10)
+
+            HStack {
+                VStack(alignment: .leading) {
+                    Text("Steps")
+                    Text("\(workoutManager.steps)")
+                        .font(.title)
+                }
+                .padding()
+
+                VStack(alignment: .leading) {
+                    Text("Calories")
+                    Text(String(format: "%.1f", workoutManager.caloriesBurned))
+                        .font(.title)
+                }
+                .padding()
+
+                VStack(alignment: .leading) {
+                    Text("Distance")
+                    Text(String(format: "%.2f miles", workoutManager.distance))
+                        .font(.title)
+                }
+                .padding()
+            }
+        }
+        .padding()
+    }
+}
+
+struct WorkoutView_Previews: PreviewProvider {
+    static var previews: some View {
+        WorkoutView(workoutManager: WatchWorkoutManager())
+    }
+}
diff --git a/Aldo Watch App Watch AppTests/Aldo_Watch_App_Watch_AppTests.swift b/Aldo Watch App Watch AppTests/Aldo_Watch_App_Watch_AppTests.swift
new file mode 100644
index 0000000..3b1e02e
--- /dev/null
+++ b/Aldo Watch App Watch AppTests/Aldo_Watch_App_Watch_AppTests.swift	
@@ -0,0 +1,36 @@
+//
+//  Aldo_Watch_App_Watch_AppTests.swift
+//  Aldo Watch App Watch AppTests
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import XCTest
+@testable import Aldo_Watch_App_Watch_App
+
+final class Aldo_Watch_App_Watch_AppTests: XCTestCase {
+
+    override func setUpWithError() throws {
+        // Put setup code here. This method is called before the invocation of each test method in the class.
+    }
+
+    override func tearDownWithError() throws {
+        // Put teardown code here. This method is called after the invocation of each test method in the class.
+    }
+
+    func testExample() throws {
+        // This is an example of a functional test case.
+        // Use XCTAssert and related functions to verify your tests produce the correct results.
+        // Any test you write for XCTest can be annotated as throws and async.
+        // Mark your test throws to produce an unexpected failure when your test encounters an uncaught error.
+        // Tests marked async will run the test method on an arbitrary thread managed by the Swift runtime.
+    }
+
+    func testPerformanceExample() throws {
+        // This is an example of a performance test case.
+        self.measure {
+            // Put the code you want to measure the time of here.
+        }
+    }
+
+}
diff --git a/Aldo Watch App Watch AppUITests/Aldo_Watch_App_Watch_AppUITests.swift b/Aldo Watch App Watch AppUITests/Aldo_Watch_App_Watch_AppUITests.swift
new file mode 100644
index 0000000..c0fbc0e
--- /dev/null
+++ b/Aldo Watch App Watch AppUITests/Aldo_Watch_App_Watch_AppUITests.swift	
@@ -0,0 +1,41 @@
+//
+//  Aldo_Watch_App_Watch_AppUITests.swift
+//  Aldo Watch App Watch AppUITests
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import XCTest
+
+final class Aldo_Watch_App_Watch_AppUITests: XCTestCase {
+
+    override func setUpWithError() throws {
+        // Put setup code here. This method is called before the invocation of each test method in the class.
+
+        // In UI tests it is usually best to stop immediately when a failure occurs.
+        continueAfterFailure = false
+
+        // In UI tests itâ€™s important to set the initial state - such as interface orientation - required for your tests before they run. The setUp method is a good place to do this.
+    }
+
+    override func tearDownWithError() throws {
+        // Put teardown code here. This method is called after the invocation of each test method in the class.
+    }
+
+    func testExample() throws {
+        // UI tests must launch the application that they test.
+        let app = XCUIApplication()
+        app.launch()
+
+        // Use XCTAssert and related functions to verify your tests produce the correct results.
+    }
+
+    func testLaunchPerformance() throws {
+        if #available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 7.0, *) {
+            // This measures how long it takes to launch your application.
+            measure(metrics: [XCTApplicationLaunchMetric()]) {
+                XCUIApplication().launch()
+            }
+        }
+    }
+}
diff --git a/Aldo Watch App Watch AppUITests/Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift b/Aldo Watch App Watch AppUITests/Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift
new file mode 100644
index 0000000..0d300e9
--- /dev/null
+++ b/Aldo Watch App Watch AppUITests/Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift	
@@ -0,0 +1,32 @@
+//
+//  Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift
+//  Aldo Watch App Watch AppUITests
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import XCTest
+
+final class Aldo_Watch_App_Watch_AppUITestsLaunchTests: XCTestCase {
+
+    override class var runsForEachTargetApplicationUIConfiguration: Bool {
+        true
+    }
+
+    override func setUpWithError() throws {
+        continueAfterFailure = false
+    }
+
+    func testLaunch() throws {
+        let app = XCUIApplication()
+        app.launch()
+
+        // Insert steps here to perform after app launch but before taking a screenshot,
+        // such as logging into a test account or navigating somewhere in the app
+
+        let attachment = XCTAttachment(screenshot: app.screenshot())
+        attachment.name = "Launch Screen"
+        attachment.lifetime = .keepAlways
+        add(attachment)
+    }
+}
diff --git a/Aldo.xcodeproj/project.pbxproj b/Aldo.xcodeproj/project.pbxproj
index 13d6b6c..44d2a7c 100644
--- a/Aldo.xcodeproj/project.pbxproj
+++ b/Aldo.xcodeproj/project.pbxproj
@@ -7,6 +7,77 @@
 	objects = {
 
 /* Begin PBXBuildFile section */
+		4910B8FC2D6173F100C0FCAF /* AddMembersView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4910B8FB2D6173F100C0FCAF /* AddMembersView.swift */; };
+		4910B9002D6174B100C0FCAF /* AddUsersView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4910B8FF2D6174B100C0FCAF /* AddUsersView.swift */; };
+		4910B9022D617D4E00C0FCAF /* NotificationService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4910B9012D617D4E00C0FCAF /* NotificationService.swift */; };
+		4910B9042D617D7300C0FCAF /* EmailService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 4910B9032D617D7300C0FCAF /* EmailService.swift */; };
+		4910B9072D617E1800C0FCAF /* SwiftSMTP in Frameworks */ = {isa = PBXBuildFile; productRef = 4910B9062D617E1800C0FCAF /* SwiftSMTP */; };
+		49A241E02D6237950099D6FF /* PhoneVerificationView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49A241DF2D6237950099D6FF /* PhoneVerificationView.swift */; };
+		49A241E22D62E7350099D6FF /* AddScoreView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49A241E12D62E7350099D6FF /* AddScoreView.swift */; };
+		49A241E42D62E7550099D6FF /* User.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49A241E32D62E7550099D6FF /* User.swift */; };
+		49CC064C2D77F8280054986A /* FirestoreManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC064B2D77F8280054986A /* FirestoreManager.swift */; };
+		49CC064E2D77F8380054986A /* NetworkMonitor.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC064D2D77F8380054986A /* NetworkMonitor.swift */; };
+		49CC06502D77F8790054986A /* ImageCache.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC064F2D77F8790054986A /* ImageCache.swift */; };
+		49CC06522D77F8830054986A /* CachedAsyncImage.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC06512D77F8830054986A /* CachedAsyncImage.swift */; };
+		49CC06542D77F8E40054986A /* ProfileView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC06532D77F8E40054986A /* ProfileView.swift */; };
+		49CC06562D77FA8E0054986A /* EnhancedPlayNowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC06552D77FA8E0054986A /* EnhancedPlayNowView.swift */; };
+		49CC06582D7801910054986A /* LeagueSubmissionView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 49CC06572D7801910054986A /* LeagueSubmissionView.swift */; };
+		9CB92DB62D46C35C00AE6B05 /* CourseSearchView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DB52D46C34F00AE6B05 /* CourseSearchView.swift */; };
+		9CB92DB82D46C56000AE6B05 /* GolfCourse.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DB72D46C54E00AE6B05 /* GolfCourse.swift */; };
+		9CB92DBC2D47365C00AE6B05 /* League.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DBB2D47365B00AE6B05 /* League.swift */; };
+		9CB92DC22D47367E00AE6B05 /* SearchLeaguesView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DC12D47367E00AE6B05 /* SearchLeaguesView.swift */; };
+		9CB92DC42D47368B00AE6B05 /* LeagueService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DC32D47368B00AE6B05 /* LeagueService.swift */; };
+		9CB92DC62D47369D00AE6B05 /* ScoreService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DC52D47369D00AE6B05 /* ScoreService.swift */; };
+		9CB92DC82D4736AE00AE6B05 /* LeagueDetailView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DC72D4736AE00AE6B05 /* LeagueDetailView.swift */; };
+		9CB92DCA2D4739CD00AE6B05 /* Score.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DC92D4739CD00AE6B05 /* Score.swift */; };
+		9CB92DCC2D473F8400AE6B05 /* UserService.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DCB2D473F8400AE6B05 /* UserService.swift */; };
+		9CB92DCE2D473F9500AE6B05 /* CreateLeagueView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 9CB92DCD2D473F9500AE6B05 /* CreateLeagueView.swift */; };
+		EA0D9B982C1AA9500045669C /* FirebaseAnalytics in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9B972C1AA9500045669C /* FirebaseAnalytics */; };
+		EA0D9B9A2C1AA9500045669C /* FirebaseAnalyticsOnDeviceConversion in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9B992C1AA9500045669C /* FirebaseAnalyticsOnDeviceConversion */; };
+		EA0D9B9C2C1AA9500045669C /* FirebaseAnalyticsSwift in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9B9B2C1AA9500045669C /* FirebaseAnalyticsSwift */; };
+		EA0D9B9E2C1AA9500045669C /* FirebaseAnalyticsWithoutAdIdSupport in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9B9D2C1AA9500045669C /* FirebaseAnalyticsWithoutAdIdSupport */; };
+		EA0D9BA02C1AA9500045669C /* FirebaseAppCheck in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9B9F2C1AA9500045669C /* FirebaseAppCheck */; };
+		EA0D9BA32C1AAACD0045669C /* FirebaseAppDistribution-Beta in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BA22C1AAACD0045669C /* FirebaseAppDistribution-Beta */; };
+		EA0D9BA52C1AAACD0045669C /* FirebaseAuth in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BA42C1AAACD0045669C /* FirebaseAuth */; };
+		EA0D9BA72C1AAACD0045669C /* FirebaseAuthCombine-Community in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BA62C1AAACD0045669C /* FirebaseAuthCombine-Community */; };
+		EA0D9BA92C1AAACD0045669C /* FirebaseCrashlytics in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BA82C1AAACD0045669C /* FirebaseCrashlytics */; };
+		EA0D9BAB2C1AAACD0045669C /* FirebaseDatabase in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BAA2C1AAACD0045669C /* FirebaseDatabase */; };
+		EA0D9BAD2C1AAACD0045669C /* FirebaseDatabaseSwift in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BAC2C1AAACD0045669C /* FirebaseDatabaseSwift */; };
+		EA0D9BAF2C1AAACD0045669C /* FirebaseDynamicLinks in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BAE2C1AAACD0045669C /* FirebaseDynamicLinks */; };
+		EA0D9BB12C1AAACD0045669C /* FirebaseFirestore in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BB02C1AAACD0045669C /* FirebaseFirestore */; };
+		EA0D9BB32C1AAACD0045669C /* FirebaseFirestoreCombine-Community in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BB22C1AAACD0045669C /* FirebaseFirestoreCombine-Community */; };
+		EA0D9BB52C1AAACD0045669C /* FirebaseFirestoreSwift in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BB42C1AAACD0045669C /* FirebaseFirestoreSwift */; };
+		EA0D9BB72C1AAACD0045669C /* FirebaseFunctions in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BB62C1AAACD0045669C /* FirebaseFunctions */; };
+		EA0D9BB92C1AAACD0045669C /* FirebaseFunctionsCombine-Community in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BB82C1AAACD0045669C /* FirebaseFunctionsCombine-Community */; };
+		EA0D9BBB2C1AAACD0045669C /* FirebaseInAppMessaging-Beta in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BBA2C1AAACD0045669C /* FirebaseInAppMessaging-Beta */; };
+		EA0D9BBD2C1AAACD0045669C /* FirebaseInAppMessagingSwift-Beta in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BBC2C1AAACD0045669C /* FirebaseInAppMessagingSwift-Beta */; };
+		EA0D9BBF2C1AAACD0045669C /* FirebaseInstallations in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BBE2C1AAACD0045669C /* FirebaseInstallations */; };
+		EA0D9BC12C1AAACD0045669C /* FirebaseMessaging in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BC02C1AAACD0045669C /* FirebaseMessaging */; };
+		EA0D9BC32C1AAACD0045669C /* FirebaseMLModelDownloader in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BC22C1AAACD0045669C /* FirebaseMLModelDownloader */; };
+		EA0D9BC52C1AAACD0045669C /* FirebasePerformance in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BC42C1AAACD0045669C /* FirebasePerformance */; };
+		EA0D9BC72C1AAACD0045669C /* FirebaseRemoteConfig in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BC62C1AAACD0045669C /* FirebaseRemoteConfig */; };
+		EA0D9BC92C1AAACD0045669C /* FirebaseRemoteConfigSwift in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BC82C1AAACD0045669C /* FirebaseRemoteConfigSwift */; };
+		EA0D9BCB2C1AAACD0045669C /* FirebaseStorage in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BCA2C1AAACD0045669C /* FirebaseStorage */; };
+		EA0D9BCD2C1AAACD0045669C /* FirebaseStorageCombine-Community in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BCC2C1AAACD0045669C /* FirebaseStorageCombine-Community */; };
+		EA0D9BCF2C1AAACD0045669C /* FirebaseVertexAI-Preview in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BCE2C1AAACD0045669C /* FirebaseVertexAI-Preview */; };
+		EA0D9BD22C1AADFF0045669C /* SDWebImageSwiftUI in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BD12C1AADFF0045669C /* SDWebImageSwiftUI */; };
+		EA0D9BD52C23C8930045669C /* FacebookAEM in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BD42C23C8930045669C /* FacebookAEM */; };
+		EA0D9BD72C23C8930045669C /* FacebookBasics in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BD62C23C8930045669C /* FacebookBasics */; };
+		EA0D9BD92C23C8930045669C /* FacebookCore in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BD82C23C8930045669C /* FacebookCore */; };
+		EA0D9BDD2C23C8930045669C /* FacebookLogin in Frameworks */ = {isa = PBXBuildFile; productRef = EA0D9BDC2C23C8930045669C /* FacebookLogin */; };
+		EA0D9BE22C23CFCF0045669C /* ActivityAndTransportPromptView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9BE12C23CFCF0045669C /* ActivityAndTransportPromptView.swift */; };
+		EA0D9BE42C23D0470045669C /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9BE32C23D0470045669C /* AppDelegate.swift */; };
+		EA0D9BF22C23D37C0045669C /* WatchWorkoutManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9BF02C23D37C0045669C /* WatchWorkoutManager.swift */; };
+		EA0D9BF42C23D3B30045669C /* iOSWorkoutManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9BF32C23D3B30045669C /* iOSWorkoutManager.swift */; };
+		EA0D9BF62C23D59C0045669C /* Aldo_WatchApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9BEB2C23D2A70045669C /* Aldo_WatchApp.swift */; };
+		EA0D9C052C27D4E70045669C /* HealthKitIntegration.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9C042C27D4E70045669C /* HealthKitIntegration.swift */; };
+		EA0D9C062C27D4E70045669C /* HealthKitIntegration.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA0D9C042C27D4E70045669C /* HealthKitIntegration.swift */; };
+		EA4B94A82C27E93A00899DF1 /* IndividualHoleView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA4B94A72C27E93900899DF1 /* IndividualHoleView.swift */; };
+		EA4B94AA2C28716300899DF1 /* WorkoutView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA4B94A92C28716300899DF1 /* WorkoutView.swift */; };
+		EA8878B92C2A202E0033C943 /* Friend.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA8878B82C2A202E0033C943 /* Friend.swift */; };
+		EA8878BD2C2A23630033C943 /* AppUser.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA8878BC2C2A23630033C943 /* AppUser.swift */; };
+		EA8878BF2C2B3C8F0033C943 /* WorkoutStats.swift in Sources */ = {isa = PBXBuildFile; fileRef = EA8878BE2C2B3C8F0033C943 /* WorkoutStats.swift */; };
+		EAE40D5B2C29AC6800B6DD64 /* FriendsListView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE40D5A2C29AC6800B6DD64 /* FriendsListView.swift */; };
 		EAE8EB2B2C1A898D00E30653 /* AldoApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB2A2C1A898D00E30653 /* AldoApp.swift */; };
 		EAE8EB2D2C1A898D00E30653 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB2C2C1A898D00E30653 /* ContentView.swift */; };
 		EAE8EB2F2C1A898D00E30653 /* Item.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB2E2C1A898D00E30653 /* Item.swift */; };
@@ -15,6 +86,27 @@
 		EAE8EB3E2C1A899100E30653 /* AldoTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB3D2C1A899100E30653 /* AldoTests.swift */; };
 		EAE8EB482C1A899100E30653 /* AldoUITests.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB472C1A899100E30653 /* AldoUITests.swift */; };
 		EAE8EB4A2C1A899100E30653 /* AldoUITestsLaunchTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB492C1A899100E30653 /* AldoUITestsLaunchTests.swift */; };
+		EAE8EB5D2C1A89EA00E30653 /* Aldo_Watch_AppApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB5C2C1A89EA00E30653 /* Aldo_Watch_AppApp.swift */; };
+		EAE8EB5F2C1A89EA00E30653 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB5E2C1A89EA00E30653 /* ContentView.swift */; };
+		EAE8EB612C1A89ED00E30653 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = EAE8EB602C1A89ED00E30653 /* Assets.xcassets */; };
+		EAE8EB642C1A89ED00E30653 /* Preview Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = EAE8EB632C1A89ED00E30653 /* Preview Assets.xcassets */; };
+		EAE8EB6E2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB6D2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppTests.swift */; };
+		EAE8EB782C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITests.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB772C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITests.swift */; };
+		EAE8EB7A2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB792C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift */; };
+		EAE8EB7D2C1A89EE00E30653 /* Aldo.app in Embed Watch Content */ = {isa = PBXBuildFile; fileRef = EAE8EB5A2C1A89EA00E30653 /* Aldo.app */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
+		EAE8EB8A2C1A8D2100E30653 /* WelcomeView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB892C1A8D2100E30653 /* WelcomeView.swift */; };
+		EAE8EB8C2C1A8D5D00E30653 /* LoginView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB8B2C1A8D5D00E30653 /* LoginView.swift */; };
+		EAE8EB8E2C1A8D7F00E30653 /* SignUpView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB8D2C1A8D7F00E30653 /* SignUpView.swift */; };
+		EAE8EB902C1A8D9800E30653 /* AuthenticationManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB8F2C1A8D9800E30653 /* AuthenticationManager.swift */; };
+		EAE8EB922C1A8E1D00E30653 /* MainView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB912C1A8E1D00E30653 /* MainView.swift */; };
+		EAE8EB942C1A931D00E30653 /* UserModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB932C1A931D00E30653 /* UserModel.swift */; };
+		EAE8EB962C1A933B00E30653 /* FriendRequestView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB952C1A933B00E30653 /* FriendRequestView.swift */; };
+		EAE8EB982C1A93AB00E30653 /* ActivityView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB972C1A93AB00E30653 /* ActivityView.swift */; };
+		EAE8EB9A2C1A947800E30653 /* LogScoreView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB992C1A947800E30653 /* LogScoreView.swift */; };
+		EAE8EB9C2C1A94EC00E30653 /* ScoreEntryView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB9B2C1A94EC00E30653 /* ScoreEntryView.swift */; };
+		EAE8EB9E2C1A951800E30653 /* SettingsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB9D2C1A951800E30653 /* SettingsView.swift */; };
+		EAE8EBA02C1A976E00E30653 /* ImagePicker.swift in Sources */ = {isa = PBXBuildFile; fileRef = EAE8EB9F2C1A976E00E30653 /* ImagePicker.swift */; };
+		EAE8EBA42C1A995E00E30653 /* GoogleService-Info.plist in Resources */ = {isa = PBXBuildFile; fileRef = EAE8EBA32C1A995E00E30653 /* GoogleService-Info.plist */; };
 /* End PBXBuildFile section */
 
 /* Begin PBXContainerItemProxy section */
@@ -32,9 +124,82 @@
 			remoteGlobalIDString = EAE8EB262C1A898D00E30653;
 			remoteInfo = Aldo;
 		};
+		EAE8EB6A2C1A89EE00E30653 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = EAE8EB1F2C1A898D00E30653 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = EAE8EB592C1A89EA00E30653;
+			remoteInfo = "Aldo Watch App Watch App";
+		};
+		EAE8EB742C1A89EE00E30653 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = EAE8EB1F2C1A898D00E30653 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = EAE8EB592C1A89EA00E30653;
+			remoteInfo = "Aldo Watch App Watch App";
+		};
+		EAE8EB7B2C1A89EE00E30653 /* PBXContainerItemProxy */ = {
+			isa = PBXContainerItemProxy;
+			containerPortal = EAE8EB1F2C1A898D00E30653 /* Project object */;
+			proxyType = 1;
+			remoteGlobalIDString = EAE8EB592C1A89EA00E30653;
+			remoteInfo = "Aldo Watch App Watch App";
+		};
 /* End PBXContainerItemProxy section */
 
+/* Begin PBXCopyFilesBuildPhase section */
+		EAE8EB812C1A89EE00E30653 /* Embed Watch Content */ = {
+			isa = PBXCopyFilesBuildPhase;
+			buildActionMask = 2147483647;
+			dstPath = "$(CONTENTS_FOLDER_PATH)/Watch";
+			dstSubfolderSpec = 16;
+			files = (
+				EAE8EB7D2C1A89EE00E30653 /* Aldo.app in Embed Watch Content */,
+			);
+			name = "Embed Watch Content";
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+/* End PBXCopyFilesBuildPhase section */
+
 /* Begin PBXFileReference section */
+		4910B8FB2D6173F100C0FCAF /* AddMembersView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AddMembersView.swift; sourceTree = "<group>"; };
+		4910B8FF2D6174B100C0FCAF /* AddUsersView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AddUsersView.swift; sourceTree = "<group>"; };
+		4910B9012D617D4E00C0FCAF /* NotificationService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NotificationService.swift; sourceTree = "<group>"; };
+		4910B9032D617D7300C0FCAF /* EmailService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EmailService.swift; sourceTree = "<group>"; };
+		49A241DF2D6237950099D6FF /* PhoneVerificationView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PhoneVerificationView.swift; sourceTree = "<group>"; };
+		49A241E12D62E7350099D6FF /* AddScoreView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AddScoreView.swift; sourceTree = "<group>"; };
+		49A241E32D62E7550099D6FF /* User.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = User.swift; sourceTree = "<group>"; };
+		49CC064B2D77F8280054986A /* FirestoreManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FirestoreManager.swift; sourceTree = "<group>"; };
+		49CC064D2D77F8380054986A /* NetworkMonitor.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = NetworkMonitor.swift; sourceTree = "<group>"; };
+		49CC064F2D77F8790054986A /* ImageCache.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageCache.swift; sourceTree = "<group>"; };
+		49CC06512D77F8830054986A /* CachedAsyncImage.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CachedAsyncImage.swift; sourceTree = "<group>"; };
+		49CC06532D77F8E40054986A /* ProfileView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ProfileView.swift; sourceTree = "<group>"; };
+		49CC06552D77FA8E0054986A /* EnhancedPlayNowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EnhancedPlayNowView.swift; sourceTree = "<group>"; };
+		49CC06572D7801910054986A /* LeagueSubmissionView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LeagueSubmissionView.swift; sourceTree = "<group>"; };
+		9CB92DB52D46C34F00AE6B05 /* CourseSearchView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CourseSearchView.swift; sourceTree = "<group>"; };
+		9CB92DB72D46C54E00AE6B05 /* GolfCourse.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GolfCourse.swift; sourceTree = "<group>"; };
+		9CB92DBB2D47365B00AE6B05 /* League.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = League.swift; sourceTree = "<group>"; };
+		9CB92DC12D47367E00AE6B05 /* SearchLeaguesView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SearchLeaguesView.swift; sourceTree = "<group>"; };
+		9CB92DC32D47368B00AE6B05 /* LeagueService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LeagueService.swift; sourceTree = "<group>"; };
+		9CB92DC52D47369D00AE6B05 /* ScoreService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ScoreService.swift; sourceTree = "<group>"; };
+		9CB92DC72D4736AE00AE6B05 /* LeagueDetailView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LeagueDetailView.swift; sourceTree = "<group>"; };
+		9CB92DC92D4739CD00AE6B05 /* Score.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Score.swift; sourceTree = "<group>"; };
+		9CB92DCB2D473F8400AE6B05 /* UserService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UserService.swift; sourceTree = "<group>"; };
+		9CB92DCD2D473F9500AE6B05 /* CreateLeagueView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CreateLeagueView.swift; sourceTree = "<group>"; };
+		EA0D9BDE2C23CB0B0045669C /* Aldo.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = Aldo.entitlements; sourceTree = "<group>"; };
+		EA0D9BE12C23CFCF0045669C /* ActivityAndTransportPromptView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ActivityAndTransportPromptView.swift; sourceTree = "<group>"; };
+		EA0D9BE32C23D0470045669C /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
+		EA0D9BEB2C23D2A70045669C /* Aldo_WatchApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = Aldo_WatchApp.swift; path = ../Aldo/Aldo_WatchApp.swift; sourceTree = "<group>"; };
+		EA0D9BF02C23D37C0045669C /* WatchWorkoutManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = WatchWorkoutManager.swift; path = ../Aldo/WatchWorkoutManager.swift; sourceTree = "<group>"; };
+		EA0D9BF32C23D3B30045669C /* iOSWorkoutManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = iOSWorkoutManager.swift; sourceTree = "<group>"; };
+		EA0D9C042C27D4E70045669C /* HealthKitIntegration.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = HealthKitIntegration.swift; sourceTree = "<group>"; };
+		EA4B94A52C27DB1300899DF1 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
+		EA4B94A72C27E93900899DF1 /* IndividualHoleView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; name = IndividualHoleView.swift; path = ../IndividualHoleView.swift; sourceTree = "<group>"; };
+		EA4B94A92C28716300899DF1 /* WorkoutView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkoutView.swift; sourceTree = "<group>"; };
+		EA8878B82C2A202E0033C943 /* Friend.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Friend.swift; sourceTree = "<group>"; };
+		EA8878BC2C2A23630033C943 /* AppUser.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppUser.swift; sourceTree = "<group>"; };
+		EA8878BE2C2B3C8F0033C943 /* WorkoutStats.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WorkoutStats.swift; sourceTree = "<group>"; };
+		EAE40D5A2C29AC6800B6DD64 /* FriendsListView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FriendsListView.swift; sourceTree = "<group>"; };
 		EAE8EB272C1A898D00E30653 /* Aldo.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Aldo.app; sourceTree = BUILT_PRODUCTS_DIR; };
 		EAE8EB2A2C1A898D00E30653 /* AldoApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AldoApp.swift; sourceTree = "<group>"; };
 		EAE8EB2C2C1A898D00E30653 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
@@ -46,6 +211,29 @@
 		EAE8EB432C1A899100E30653 /* AldoUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = AldoUITests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
 		EAE8EB472C1A899100E30653 /* AldoUITests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AldoUITests.swift; sourceTree = "<group>"; };
 		EAE8EB492C1A899100E30653 /* AldoUITestsLaunchTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AldoUITestsLaunchTests.swift; sourceTree = "<group>"; };
+		EAE8EB5A2C1A89EA00E30653 /* Aldo.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Aldo.app; sourceTree = BUILT_PRODUCTS_DIR; };
+		EAE8EB5C2C1A89EA00E30653 /* Aldo_Watch_AppApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Aldo_Watch_AppApp.swift; sourceTree = "<group>"; };
+		EAE8EB5E2C1A89EA00E30653 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
+		EAE8EB602C1A89ED00E30653 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
+		EAE8EB632C1A89ED00E30653 /* Preview Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = "Preview Assets.xcassets"; sourceTree = "<group>"; };
+		EAE8EB692C1A89EE00E30653 /* Aldo Watch AppTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "Aldo Watch AppTests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
+		EAE8EB6D2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Aldo_Watch_App_Watch_AppTests.swift; sourceTree = "<group>"; };
+		EAE8EB732C1A89EE00E30653 /* Aldo Watch AppUITests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = "Aldo Watch AppUITests.xctest"; sourceTree = BUILT_PRODUCTS_DIR; };
+		EAE8EB772C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Aldo_Watch_App_Watch_AppUITests.swift; sourceTree = "<group>"; };
+		EAE8EB792C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift; sourceTree = "<group>"; };
+		EAE8EB892C1A8D2100E30653 /* WelcomeView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = WelcomeView.swift; sourceTree = "<group>"; };
+		EAE8EB8B2C1A8D5D00E30653 /* LoginView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LoginView.swift; sourceTree = "<group>"; };
+		EAE8EB8D2C1A8D7F00E30653 /* SignUpView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SignUpView.swift; sourceTree = "<group>"; };
+		EAE8EB8F2C1A8D9800E30653 /* AuthenticationManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AuthenticationManager.swift; sourceTree = "<group>"; };
+		EAE8EB912C1A8E1D00E30653 /* MainView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainView.swift; sourceTree = "<group>"; };
+		EAE8EB932C1A931D00E30653 /* UserModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = UserModel.swift; sourceTree = "<group>"; };
+		EAE8EB952C1A933B00E30653 /* FriendRequestView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = FriendRequestView.swift; sourceTree = "<group>"; };
+		EAE8EB972C1A93AB00E30653 /* ActivityView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ActivityView.swift; sourceTree = "<group>"; };
+		EAE8EB992C1A947800E30653 /* LogScoreView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LogScoreView.swift; sourceTree = "<group>"; };
+		EAE8EB9B2C1A94EC00E30653 /* ScoreEntryView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ScoreEntryView.swift; sourceTree = "<group>"; };
+		EAE8EB9D2C1A951800E30653 /* SettingsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SettingsView.swift; sourceTree = "<group>"; };
+		EAE8EB9F2C1A976E00E30653 /* ImagePicker.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImagePicker.swift; sourceTree = "<group>"; };
+		EAE8EBA32C1A995E00E30653 /* GoogleService-Info.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; path = "GoogleService-Info.plist"; sourceTree = SOURCE_ROOT; };
 /* End PBXFileReference section */
 
 /* Begin PBXFrameworksBuildPhase section */
@@ -53,6 +241,40 @@
 			isa = PBXFrameworksBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				EA0D9BAB2C1AAACD0045669C /* FirebaseDatabase in Frameworks */,
+				EA0D9BB92C1AAACD0045669C /* FirebaseFunctionsCombine-Community in Frameworks */,
+				EA0D9BB12C1AAACD0045669C /* FirebaseFirestore in Frameworks */,
+				EA0D9B9C2C1AA9500045669C /* FirebaseAnalyticsSwift in Frameworks */,
+				EA0D9B982C1AA9500045669C /* FirebaseAnalytics in Frameworks */,
+				EA0D9B9A2C1AA9500045669C /* FirebaseAnalyticsOnDeviceConversion in Frameworks */,
+				EA0D9BD52C23C8930045669C /* FacebookAEM in Frameworks */,
+				EA0D9BB52C1AAACD0045669C /* FirebaseFirestoreSwift in Frameworks */,
+				EA0D9BC32C1AAACD0045669C /* FirebaseMLModelDownloader in Frameworks */,
+				EA0D9BD72C23C8930045669C /* FacebookBasics in Frameworks */,
+				EA0D9BA02C1AA9500045669C /* FirebaseAppCheck in Frameworks */,
+				EA0D9B9E2C1AA9500045669C /* FirebaseAnalyticsWithoutAdIdSupport in Frameworks */,
+				EA0D9BC12C1AAACD0045669C /* FirebaseMessaging in Frameworks */,
+				EA0D9BA52C1AAACD0045669C /* FirebaseAuth in Frameworks */,
+				EA0D9BC92C1AAACD0045669C /* FirebaseRemoteConfigSwift in Frameworks */,
+				EA0D9BD92C23C8930045669C /* FacebookCore in Frameworks */,
+				EA0D9BA92C1AAACD0045669C /* FirebaseCrashlytics in Frameworks */,
+				EA0D9BDD2C23C8930045669C /* FacebookLogin in Frameworks */,
+				EA0D9BBB2C1AAACD0045669C /* FirebaseInAppMessaging-Beta in Frameworks */,
+				EA0D9BAD2C1AAACD0045669C /* FirebaseDatabaseSwift in Frameworks */,
+				4910B9072D617E1800C0FCAF /* SwiftSMTP in Frameworks */,
+				EA0D9BCD2C1AAACD0045669C /* FirebaseStorageCombine-Community in Frameworks */,
+				EA0D9BC72C1AAACD0045669C /* FirebaseRemoteConfig in Frameworks */,
+				EA0D9BB72C1AAACD0045669C /* FirebaseFunctions in Frameworks */,
+				EA0D9BA32C1AAACD0045669C /* FirebaseAppDistribution-Beta in Frameworks */,
+				EA0D9BC52C1AAACD0045669C /* FirebasePerformance in Frameworks */,
+				EA0D9BA72C1AAACD0045669C /* FirebaseAuthCombine-Community in Frameworks */,
+				EA0D9BCB2C1AAACD0045669C /* FirebaseStorage in Frameworks */,
+				EA0D9BBD2C1AAACD0045669C /* FirebaseInAppMessagingSwift-Beta in Frameworks */,
+				EA0D9BCF2C1AAACD0045669C /* FirebaseVertexAI-Preview in Frameworks */,
+				EA0D9BD22C1AADFF0045669C /* SDWebImageSwiftUI in Frameworks */,
+				EA0D9BAF2C1AAACD0045669C /* FirebaseDynamicLinks in Frameworks */,
+				EA0D9BB32C1AAACD0045669C /* FirebaseFirestoreCombine-Community in Frameworks */,
+				EA0D9BBF2C1AAACD0045669C /* FirebaseInstallations in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -70,16 +292,48 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		EAE8EB572C1A89EA00E30653 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EAE8EB662C1A89EE00E30653 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EAE8EB702C1A89EE00E30653 /* Frameworks */ = {
+			isa = PBXFrameworksBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXFrameworksBuildPhase section */
 
 /* Begin PBXGroup section */
+		EA0D9BA12C1AAACD0045669C /* Frameworks */ = {
+			isa = PBXGroup;
+			children = (
+			);
+			name = Frameworks;
+			sourceTree = "<group>";
+		};
 		EAE8EB1E2C1A898D00E30653 = {
 			isa = PBXGroup;
 			children = (
 				EAE8EB292C1A898D00E30653 /* Aldo */,
 				EAE8EB3C2C1A899100E30653 /* AldoTests */,
 				EAE8EB462C1A899100E30653 /* AldoUITests */,
+				EAE8EB5B2C1A89EA00E30653 /* Aldo Watch App Watch App */,
+				EAE8EB6C2C1A89EE00E30653 /* Aldo Watch App Watch AppTests */,
+				EAE8EB762C1A89EE00E30653 /* Aldo Watch App Watch AppUITests */,
 				EAE8EB282C1A898D00E30653 /* Products */,
+				EA0D9BA12C1AAACD0045669C /* Frameworks */,
 			);
 			sourceTree = "<group>";
 		};
@@ -89,6 +343,9 @@
 				EAE8EB272C1A898D00E30653 /* Aldo.app */,
 				EAE8EB392C1A899100E30653 /* AldoTests.xctest */,
 				EAE8EB432C1A899100E30653 /* AldoUITests.xctest */,
+				EAE8EB5A2C1A89EA00E30653 /* Aldo.app */,
+				EAE8EB692C1A89EE00E30653 /* Aldo Watch AppTests.xctest */,
+				EAE8EB732C1A89EE00E30653 /* Aldo Watch AppUITests.xctest */,
 			);
 			name = Products;
 			sourceTree = "<group>";
@@ -96,11 +353,28 @@
 		EAE8EB292C1A898D00E30653 /* Aldo */ = {
 			isa = PBXGroup;
 			children = (
+				49CC06512D77F8830054986A /* CachedAsyncImage.swift */,
+				49CC064F2D77F8790054986A /* ImageCache.swift */,
+				49CC064D2D77F8380054986A /* NetworkMonitor.swift */,
+				49CC064B2D77F8280054986A /* FirestoreManager.swift */,
+				4910B9032D617D7300C0FCAF /* EmailService.swift */,
+				4910B9012D617D4E00C0FCAF /* NotificationService.swift */,
+				EA0D9BDE2C23CB0B0045669C /* Aldo.entitlements */,
 				EAE8EB2A2C1A898D00E30653 /* AldoApp.swift */,
-				EAE8EB2C2C1A898D00E30653 /* ContentView.swift */,
+				EA0D9BE32C23D0470045669C /* AppDelegate.swift */,
+				EAE8EB8F2C1A8D9800E30653 /* AuthenticationManager.swift */,
+				EAE8EB932C1A931D00E30653 /* UserModel.swift */,
+				EAE8EBA32C1A995E00E30653 /* GoogleService-Info.plist */,
+				EAE8EB882C1A8C3600E30653 /* Views */,
 				EAE8EB2E2C1A898D00E30653 /* Item.swift */,
+				EA0D9BF32C23D3B30045669C /* iOSWorkoutManager.swift */,
 				EAE8EB302C1A899000E30653 /* Assets.xcassets */,
 				EAE8EB322C1A899000E30653 /* Preview Content */,
+				EA0D9C042C27D4E70045669C /* HealthKitIntegration.swift */,
+				EA4B94A52C27DB1300899DF1 /* Info.plist */,
+				EA8878B82C2A202E0033C943 /* Friend.swift */,
+				EA8878BC2C2A23630033C943 /* AppUser.swift */,
+				EA8878BE2C2B3C8F0033C943 /* WorkoutStats.swift */,
 			);
 			path = Aldo;
 			sourceTree = "<group>";
@@ -130,6 +404,84 @@
 			path = AldoUITests;
 			sourceTree = "<group>";
 		};
+		EAE8EB5B2C1A89EA00E30653 /* Aldo Watch App Watch App */ = {
+			isa = PBXGroup;
+			children = (
+				EAE8EB5C2C1A89EA00E30653 /* Aldo_Watch_AppApp.swift */,
+				EA0D9BEB2C23D2A70045669C /* Aldo_WatchApp.swift */,
+				EA0D9BF02C23D37C0045669C /* WatchWorkoutManager.swift */,
+				EAE8EB5E2C1A89EA00E30653 /* ContentView.swift */,
+				EA4B94A92C28716300899DF1 /* WorkoutView.swift */,
+				EAE8EB602C1A89ED00E30653 /* Assets.xcassets */,
+				EAE8EB622C1A89ED00E30653 /* Preview Content */,
+			);
+			path = "Aldo Watch App Watch App";
+			sourceTree = "<group>";
+		};
+		EAE8EB622C1A89ED00E30653 /* Preview Content */ = {
+			isa = PBXGroup;
+			children = (
+				EAE8EB632C1A89ED00E30653 /* Preview Assets.xcassets */,
+			);
+			path = "Preview Content";
+			sourceTree = "<group>";
+		};
+		EAE8EB6C2C1A89EE00E30653 /* Aldo Watch App Watch AppTests */ = {
+			isa = PBXGroup;
+			children = (
+				EAE8EB6D2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppTests.swift */,
+			);
+			path = "Aldo Watch App Watch AppTests";
+			sourceTree = "<group>";
+		};
+		EAE8EB762C1A89EE00E30653 /* Aldo Watch App Watch AppUITests */ = {
+			isa = PBXGroup;
+			children = (
+				EAE8EB772C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITests.swift */,
+				EAE8EB792C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift */,
+			);
+			path = "Aldo Watch App Watch AppUITests";
+			sourceTree = "<group>";
+		};
+		EAE8EB882C1A8C3600E30653 /* Views */ = {
+			isa = PBXGroup;
+			children = (
+				EA0D9BE12C23CFCF0045669C /* ActivityAndTransportPromptView.swift */,
+				EAE8EB972C1A93AB00E30653 /* ActivityView.swift */,
+				4910B8FB2D6173F100C0FCAF /* AddMembersView.swift */,
+				49A241E12D62E7350099D6FF /* AddScoreView.swift */,
+				4910B8FF2D6174B100C0FCAF /* AddUsersView.swift */,
+				EAE8EB2C2C1A898D00E30653 /* ContentView.swift */,
+				9CB92DB52D46C34F00AE6B05 /* CourseSearchView.swift */,
+				9CB92DCD2D473F9500AE6B05 /* CreateLeagueView.swift */,
+				49CC06552D77FA8E0054986A /* EnhancedPlayNowView.swift */,
+				EAE8EB952C1A933B00E30653 /* FriendRequestView.swift */,
+				EAE40D5A2C29AC6800B6DD64 /* FriendsListView.swift */,
+				9CB92DB72D46C54E00AE6B05 /* GolfCourse.swift */,
+				EAE8EB9F2C1A976E00E30653 /* ImagePicker.swift */,
+				EA4B94A72C27E93900899DF1 /* IndividualHoleView.swift */,
+				9CB92DBB2D47365B00AE6B05 /* League.swift */,
+				9CB92DC72D4736AE00AE6B05 /* LeagueDetailView.swift */,
+				9CB92DC32D47368B00AE6B05 /* LeagueService.swift */,
+				49CC06572D7801910054986A /* LeagueSubmissionView.swift */,
+				EAE8EB8B2C1A8D5D00E30653 /* LoginView.swift */,
+				EAE8EB992C1A947800E30653 /* LogScoreView.swift */,
+				EAE8EB912C1A8E1D00E30653 /* MainView.swift */,
+				49A241DF2D6237950099D6FF /* PhoneVerificationView.swift */,
+				49CC06532D77F8E40054986A /* ProfileView.swift */,
+				9CB92DC92D4739CD00AE6B05 /* Score.swift */,
+				EAE8EB9B2C1A94EC00E30653 /* ScoreEntryView.swift */,
+				9CB92DC52D47369D00AE6B05 /* ScoreService.swift */,
+				9CB92DC12D47367E00AE6B05 /* SearchLeaguesView.swift */,
+				EAE8EB9D2C1A951800E30653 /* SettingsView.swift */,
+				EAE8EB8D2C1A8D7F00E30653 /* SignUpView.swift */,
+				49A241E32D62E7550099D6FF /* User.swift */,
+				9CB92DCB2D473F8400AE6B05 /* UserService.swift */,
+				EAE8EB892C1A8D2100E30653 /* WelcomeView.swift */,
+			);
+			path = Views;
+			sourceTree = "<group>";
+		};
 /* End PBXGroup section */
 
 /* Begin PBXNativeTarget section */
@@ -140,12 +492,50 @@
 				EAE8EB232C1A898D00E30653 /* Sources */,
 				EAE8EB242C1A898D00E30653 /* Frameworks */,
 				EAE8EB252C1A898D00E30653 /* Resources */,
+				EAE8EB812C1A89EE00E30653 /* Embed Watch Content */,
 			);
 			buildRules = (
 			);
 			dependencies = (
+				EAE8EB7C2C1A89EE00E30653 /* PBXTargetDependency */,
 			);
 			name = Aldo;
+			packageProductDependencies = (
+				EA0D9B972C1AA9500045669C /* FirebaseAnalytics */,
+				EA0D9B992C1AA9500045669C /* FirebaseAnalyticsOnDeviceConversion */,
+				EA0D9B9B2C1AA9500045669C /* FirebaseAnalyticsSwift */,
+				EA0D9B9D2C1AA9500045669C /* FirebaseAnalyticsWithoutAdIdSupport */,
+				EA0D9B9F2C1AA9500045669C /* FirebaseAppCheck */,
+				EA0D9BA22C1AAACD0045669C /* FirebaseAppDistribution-Beta */,
+				EA0D9BA42C1AAACD0045669C /* FirebaseAuth */,
+				EA0D9BA62C1AAACD0045669C /* FirebaseAuthCombine-Community */,
+				EA0D9BA82C1AAACD0045669C /* FirebaseCrashlytics */,
+				EA0D9BAA2C1AAACD0045669C /* FirebaseDatabase */,
+				EA0D9BAC2C1AAACD0045669C /* FirebaseDatabaseSwift */,
+				EA0D9BAE2C1AAACD0045669C /* FirebaseDynamicLinks */,
+				EA0D9BB02C1AAACD0045669C /* FirebaseFirestore */,
+				EA0D9BB22C1AAACD0045669C /* FirebaseFirestoreCombine-Community */,
+				EA0D9BB42C1AAACD0045669C /* FirebaseFirestoreSwift */,
+				EA0D9BB62C1AAACD0045669C /* FirebaseFunctions */,
+				EA0D9BB82C1AAACD0045669C /* FirebaseFunctionsCombine-Community */,
+				EA0D9BBA2C1AAACD0045669C /* FirebaseInAppMessaging-Beta */,
+				EA0D9BBC2C1AAACD0045669C /* FirebaseInAppMessagingSwift-Beta */,
+				EA0D9BBE2C1AAACD0045669C /* FirebaseInstallations */,
+				EA0D9BC02C1AAACD0045669C /* FirebaseMessaging */,
+				EA0D9BC22C1AAACD0045669C /* FirebaseMLModelDownloader */,
+				EA0D9BC42C1AAACD0045669C /* FirebasePerformance */,
+				EA0D9BC62C1AAACD0045669C /* FirebaseRemoteConfig */,
+				EA0D9BC82C1AAACD0045669C /* FirebaseRemoteConfigSwift */,
+				EA0D9BCA2C1AAACD0045669C /* FirebaseStorage */,
+				EA0D9BCC2C1AAACD0045669C /* FirebaseStorageCombine-Community */,
+				EA0D9BCE2C1AAACD0045669C /* FirebaseVertexAI-Preview */,
+				EA0D9BD12C1AADFF0045669C /* SDWebImageSwiftUI */,
+				EA0D9BD42C23C8930045669C /* FacebookAEM */,
+				EA0D9BD62C23C8930045669C /* FacebookBasics */,
+				EA0D9BD82C23C8930045669C /* FacebookCore */,
+				EA0D9BDC2C23C8930045669C /* FacebookLogin */,
+				4910B9062D617E1800C0FCAF /* SwiftSMTP */,
+			);
 			productName = Aldo;
 			productReference = EAE8EB272C1A898D00E30653 /* Aldo.app */;
 			productType = "com.apple.product-type.application";
@@ -186,6 +576,59 @@
 			productReference = EAE8EB432C1A899100E30653 /* AldoUITests.xctest */;
 			productType = "com.apple.product-type.bundle.ui-testing";
 		};
+		EAE8EB592C1A89EA00E30653 /* Aldo Watch App */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = EAE8EB7E2C1A89EE00E30653 /* Build configuration list for PBXNativeTarget "Aldo Watch App" */;
+			buildPhases = (
+				EAE8EB562C1A89EA00E30653 /* Sources */,
+				EAE8EB572C1A89EA00E30653 /* Frameworks */,
+				EAE8EB582C1A89EA00E30653 /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+			);
+			name = "Aldo Watch App";
+			productName = "Aldo Watch App Watch App";
+			productReference = EAE8EB5A2C1A89EA00E30653 /* Aldo.app */;
+			productType = "com.apple.product-type.application";
+		};
+		EAE8EB682C1A89EE00E30653 /* Aldo Watch AppTests */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = EAE8EB822C1A89EE00E30653 /* Build configuration list for PBXNativeTarget "Aldo Watch AppTests" */;
+			buildPhases = (
+				EAE8EB652C1A89EE00E30653 /* Sources */,
+				EAE8EB662C1A89EE00E30653 /* Frameworks */,
+				EAE8EB672C1A89EE00E30653 /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				EAE8EB6B2C1A89EE00E30653 /* PBXTargetDependency */,
+			);
+			name = "Aldo Watch AppTests";
+			productName = "Aldo Watch App Watch AppTests";
+			productReference = EAE8EB692C1A89EE00E30653 /* Aldo Watch AppTests.xctest */;
+			productType = "com.apple.product-type.bundle.unit-test";
+		};
+		EAE8EB722C1A89EE00E30653 /* Aldo Watch AppUITests */ = {
+			isa = PBXNativeTarget;
+			buildConfigurationList = EAE8EB852C1A89EE00E30653 /* Build configuration list for PBXNativeTarget "Aldo Watch AppUITests" */;
+			buildPhases = (
+				EAE8EB6F2C1A89EE00E30653 /* Sources */,
+				EAE8EB702C1A89EE00E30653 /* Frameworks */,
+				EAE8EB712C1A89EE00E30653 /* Resources */,
+			);
+			buildRules = (
+			);
+			dependencies = (
+				EAE8EB752C1A89EE00E30653 /* PBXTargetDependency */,
+			);
+			name = "Aldo Watch AppUITests";
+			productName = "Aldo Watch App Watch AppUITests";
+			productReference = EAE8EB732C1A89EE00E30653 /* Aldo Watch AppUITests.xctest */;
+			productType = "com.apple.product-type.bundle.ui-testing";
+		};
 /* End PBXNativeTarget section */
 
 /* Begin PBXProject section */
@@ -207,6 +650,17 @@
 						CreatedOnToolsVersion = 15.4;
 						TestTargetID = EAE8EB262C1A898D00E30653;
 					};
+					EAE8EB592C1A89EA00E30653 = {
+						CreatedOnToolsVersion = 15.4;
+					};
+					EAE8EB682C1A89EE00E30653 = {
+						CreatedOnToolsVersion = 15.4;
+						TestTargetID = EAE8EB592C1A89EA00E30653;
+					};
+					EAE8EB722C1A89EE00E30653 = {
+						CreatedOnToolsVersion = 15.4;
+						TestTargetID = EAE8EB592C1A89EA00E30653;
+					};
 				};
 			};
 			buildConfigurationList = EAE8EB222C1A898D00E30653 /* Build configuration list for PBXProject "Aldo" */;
@@ -218,6 +672,12 @@
 				Base,
 			);
 			mainGroup = EAE8EB1E2C1A898D00E30653;
+			packageReferences = (
+				EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */,
+				EA0D9BD02C1AADFF0045669C /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */,
+				EA0D9BD32C23C8920045669C /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */,
+				4910B9052D617DE200C0FCAF /* XCRemoteSwiftPackageReference "Swift-SMTP" */,
+			);
 			productRefGroup = EAE8EB282C1A898D00E30653 /* Products */;
 			projectDirPath = "";
 			projectRoot = "";
@@ -225,6 +685,9 @@
 				EAE8EB262C1A898D00E30653 /* Aldo */,
 				EAE8EB382C1A899100E30653 /* AldoTests */,
 				EAE8EB422C1A899100E30653 /* AldoUITests */,
+				EAE8EB592C1A89EA00E30653 /* Aldo Watch App */,
+				EAE8EB682C1A89EE00E30653 /* Aldo Watch AppTests */,
+				EAE8EB722C1A89EE00E30653 /* Aldo Watch AppUITests */,
 			);
 		};
 /* End PBXProject section */
@@ -236,6 +699,7 @@
 			files = (
 				EAE8EB342C1A899000E30653 /* Preview Assets.xcassets in Resources */,
 				EAE8EB312C1A899000E30653 /* Assets.xcassets in Resources */,
+				EAE8EBA42C1A995E00E30653 /* GoogleService-Info.plist in Resources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -253,6 +717,29 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		EAE8EB582C1A89EA00E30653 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				EAE8EB642C1A89ED00E30653 /* Preview Assets.xcassets in Resources */,
+				EAE8EB612C1A89ED00E30653 /* Assets.xcassets in Resources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EAE8EB672C1A89EE00E30653 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EAE8EB712C1A89EE00E30653 /* Resources */ = {
+			isa = PBXResourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXResourcesBuildPhase section */
 
 /* Begin PBXSourcesBuildPhase section */
@@ -260,9 +747,54 @@
 			isa = PBXSourcesBuildPhase;
 			buildActionMask = 2147483647;
 			files = (
+				EAE8EB982C1A93AB00E30653 /* ActivityView.swift in Sources */,
+				49CC06562D77FA8E0054986A /* EnhancedPlayNowView.swift in Sources */,
+				49CC064C2D77F8280054986A /* FirestoreManager.swift in Sources */,
+				9CB92DBC2D47365C00AE6B05 /* League.swift in Sources */,
 				EAE8EB2D2C1A898D00E30653 /* ContentView.swift in Sources */,
+				EAE8EB922C1A8E1D00E30653 /* MainView.swift in Sources */,
+				9CB92DB62D46C35C00AE6B05 /* CourseSearchView.swift in Sources */,
+				49A241E22D62E7350099D6FF /* AddScoreView.swift in Sources */,
+				EA0D9BF42C23D3B30045669C /* iOSWorkoutManager.swift in Sources */,
+				9CB92DCC2D473F8400AE6B05 /* UserService.swift in Sources */,
+				4910B9022D617D4E00C0FCAF /* NotificationService.swift in Sources */,
 				EAE8EB2F2C1A898D00E30653 /* Item.swift in Sources */,
+				EAE8EB902C1A8D9800E30653 /* AuthenticationManager.swift in Sources */,
+				EA8878BD2C2A23630033C943 /* AppUser.swift in Sources */,
+				EA8878BF2C2B3C8F0033C943 /* WorkoutStats.swift in Sources */,
+				4910B9042D617D7300C0FCAF /* EmailService.swift in Sources */,
 				EAE8EB2B2C1A898D00E30653 /* AldoApp.swift in Sources */,
+				49A241E02D6237950099D6FF /* PhoneVerificationView.swift in Sources */,
+				9CB92DC42D47368B00AE6B05 /* LeagueService.swift in Sources */,
+				9CB92DC82D4736AE00AE6B05 /* LeagueDetailView.swift in Sources */,
+				49A241E42D62E7550099D6FF /* User.swift in Sources */,
+				EAE8EB8C2C1A8D5D00E30653 /* LoginView.swift in Sources */,
+				EAE8EB9E2C1A951800E30653 /* SettingsView.swift in Sources */,
+				49CC06502D77F8790054986A /* ImageCache.swift in Sources */,
+				4910B8FC2D6173F100C0FCAF /* AddMembersView.swift in Sources */,
+				EAE8EB962C1A933B00E30653 /* FriendRequestView.swift in Sources */,
+				9CB92DC22D47367E00AE6B05 /* SearchLeaguesView.swift in Sources */,
+				4910B9002D6174B100C0FCAF /* AddUsersView.swift in Sources */,
+				EAE8EB8E2C1A8D7F00E30653 /* SignUpView.swift in Sources */,
+				EA4B94A82C27E93A00899DF1 /* IndividualHoleView.swift in Sources */,
+				EAE8EB942C1A931D00E30653 /* UserModel.swift in Sources */,
+				EAE8EB9C2C1A94EC00E30653 /* ScoreEntryView.swift in Sources */,
+				49CC064E2D77F8380054986A /* NetworkMonitor.swift in Sources */,
+				EAE8EBA02C1A976E00E30653 /* ImagePicker.swift in Sources */,
+				EA0D9BE22C23CFCF0045669C /* ActivityAndTransportPromptView.swift in Sources */,
+				EAE8EB9A2C1A947800E30653 /* LogScoreView.swift in Sources */,
+				EAE40D5B2C29AC6800B6DD64 /* FriendsListView.swift in Sources */,
+				9CB92DC62D47369D00AE6B05 /* ScoreService.swift in Sources */,
+				EA0D9BE42C23D0470045669C /* AppDelegate.swift in Sources */,
+				EA0D9C052C27D4E70045669C /* HealthKitIntegration.swift in Sources */,
+				EAE8EB8A2C1A8D2100E30653 /* WelcomeView.swift in Sources */,
+				49CC06542D77F8E40054986A /* ProfileView.swift in Sources */,
+				9CB92DB82D46C56000AE6B05 /* GolfCourse.swift in Sources */,
+				9CB92DCA2D4739CD00AE6B05 /* Score.swift in Sources */,
+				EA8878B92C2A202E0033C943 /* Friend.swift in Sources */,
+				49CC06522D77F8830054986A /* CachedAsyncImage.swift in Sources */,
+				9CB92DCE2D473F9500AE6B05 /* CreateLeagueView.swift in Sources */,
+				49CC06582D7801910054986A /* LeagueSubmissionView.swift in Sources */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -283,6 +815,36 @@
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
+		EAE8EB562C1A89EA00E30653 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				EA0D9C062C27D4E70045669C /* HealthKitIntegration.swift in Sources */,
+				EA0D9BF22C23D37C0045669C /* WatchWorkoutManager.swift in Sources */,
+				EA0D9BF62C23D59C0045669C /* Aldo_WatchApp.swift in Sources */,
+				EAE8EB5F2C1A89EA00E30653 /* ContentView.swift in Sources */,
+				EA4B94AA2C28716300899DF1 /* WorkoutView.swift in Sources */,
+				EAE8EB5D2C1A89EA00E30653 /* Aldo_Watch_AppApp.swift in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EAE8EB652C1A89EE00E30653 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				EAE8EB6E2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppTests.swift in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
+		EAE8EB6F2C1A89EE00E30653 /* Sources */ = {
+			isa = PBXSourcesBuildPhase;
+			buildActionMask = 2147483647;
+			files = (
+				EAE8EB7A2C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITestsLaunchTests.swift in Sources */,
+				EAE8EB782C1A89EE00E30653 /* Aldo_Watch_App_Watch_AppUITests.swift in Sources */,
+			);
+			runOnlyForDeploymentPostprocessing = 0;
+		};
 /* End PBXSourcesBuildPhase section */
 
 /* Begin PBXTargetDependency section */
@@ -296,6 +858,21 @@
 			target = EAE8EB262C1A898D00E30653 /* Aldo */;
 			targetProxy = EAE8EB442C1A899100E30653 /* PBXContainerItemProxy */;
 		};
+		EAE8EB6B2C1A89EE00E30653 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = EAE8EB592C1A89EA00E30653 /* Aldo Watch App */;
+			targetProxy = EAE8EB6A2C1A89EE00E30653 /* PBXContainerItemProxy */;
+		};
+		EAE8EB752C1A89EE00E30653 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = EAE8EB592C1A89EA00E30653 /* Aldo Watch App */;
+			targetProxy = EAE8EB742C1A89EE00E30653 /* PBXContainerItemProxy */;
+		};
+		EAE8EB7C2C1A89EE00E30653 /* PBXTargetDependency */ = {
+			isa = PBXTargetDependency;
+			target = EAE8EB592C1A89EA00E30653 /* Aldo Watch App */;
+			targetProxy = EAE8EB7B2C1A89EE00E30653 /* PBXContainerItemProxy */;
+		};
 /* End PBXTargetDependency section */
 
 /* Begin XCBuildConfiguration section */
@@ -421,19 +998,29 @@
 		EAE8EB4E2C1A899100E30653 /* Debug */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
+				CODE_SIGN_ENTITLEMENTS = Aldo/Aldo.entitlements;
 				CODE_SIGN_STYLE = Automatic;
 				CURRENT_PROJECT_VERSION = 1;
 				DEVELOPMENT_ASSET_PATHS = "\"Aldo/Preview Content\"";
 				DEVELOPMENT_TEAM = A2F9MS5L95;
+				DONT_GENERATE_INFOPLIST_FILE = YES;
+				ENABLE_APP_SANDBOX = NO;
 				ENABLE_PREVIEWS = YES;
-				GENERATE_INFOPLIST_FILE = YES;
+				ENABLE_USER_SCRIPT_SANDBOXING = YES;
+				GENERATE_INFOPLIST_FILE = NO;
+				INFOPLIST_FILE = "$(SRCROOT)/Aldo/Info.plist";
+				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.sports";
+				INFOPLIST_KEY_NSHealthClinicalHealthRecordsShareUsageDescription = "This app wants to record your data";
+				INFOPLIST_KEY_NSHealthShareUsageDescription = "This app wants to read your health data";
 				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
+				INFOPLIST_PREPROCESS = YES;
 				LD_RUNPATH_SEARCH_PATHS = (
 					"$(inherited)",
 					"@executable_path/Frameworks",
@@ -450,19 +1037,29 @@
 		EAE8EB4F2C1A899100E30653 /* Release */ = {
 			isa = XCBuildConfiguration;
 			buildSettings = {
+				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
 				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
 				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
+				CODE_SIGN_ENTITLEMENTS = Aldo/Aldo.entitlements;
 				CODE_SIGN_STYLE = Automatic;
 				CURRENT_PROJECT_VERSION = 1;
 				DEVELOPMENT_ASSET_PATHS = "\"Aldo/Preview Content\"";
 				DEVELOPMENT_TEAM = A2F9MS5L95;
+				DONT_GENERATE_INFOPLIST_FILE = YES;
+				ENABLE_APP_SANDBOX = NO;
 				ENABLE_PREVIEWS = YES;
-				GENERATE_INFOPLIST_FILE = YES;
+				ENABLE_USER_SCRIPT_SANDBOXING = YES;
+				GENERATE_INFOPLIST_FILE = NO;
+				INFOPLIST_FILE = "$(SRCROOT)/Aldo/Info.plist";
+				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.sports";
+				INFOPLIST_KEY_NSHealthClinicalHealthRecordsShareUsageDescription = "This app wants to record your data";
+				INFOPLIST_KEY_NSHealthShareUsageDescription = "This app wants to read your health data";
 				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
 				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
 				INFOPLIST_KEY_UILaunchScreen_Generation = YES;
 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
 				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
+				INFOPLIST_PREPROCESS = YES;
 				LD_RUNPATH_SEARCH_PATHS = (
 					"$(inherited)",
 					"@executable_path/Frameworks",
@@ -552,6 +1149,150 @@
 			};
 			name = Release;
 		};
+		EAE8EB7F2C1A89EE00E30653 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
+				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
+				CODE_SIGN_STYLE = Automatic;
+				CURRENT_PROJECT_VERSION = 1;
+				DEVELOPMENT_ASSET_PATHS = "\"Aldo Watch App Watch App/Preview Content\"";
+				DEVELOPMENT_TEAM = A2F9MS5L95;
+				ENABLE_APP_SANDBOX = NO;
+				ENABLE_PREVIEWS = YES;
+				ENABLE_USER_SCRIPT_SANDBOXING = YES;
+				GENERATE_INFOPLIST_FILE = YES;
+				INFOPLIST_KEY_UISupportedInterfaceOrientations = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown";
+				INFOPLIST_KEY_WKCompanionAppBundleIdentifier = Aldo.Aldo;
+				LD_RUNPATH_SEARCH_PATHS = (
+					"$(inherited)",
+					"@executable_path/Frameworks",
+				);
+				MARKETING_VERSION = 1.0;
+				PRODUCT_BUNDLE_IDENTIFIER = Aldo.Aldo.watchkitapp;
+				PRODUCT_NAME = Aldo;
+				SDKROOT = watchos;
+				SKIP_INSTALL = YES;
+				SWIFT_EMIT_LOC_STRINGS = YES;
+				SWIFT_VERSION = 5.0;
+				TARGETED_DEVICE_FAMILY = 4;
+				WATCHOS_DEPLOYMENT_TARGET = 10.5;
+			};
+			name = Debug;
+		};
+		EAE8EB802C1A89EE00E30653 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
+				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
+				CODE_SIGN_STYLE = Automatic;
+				CURRENT_PROJECT_VERSION = 1;
+				DEVELOPMENT_ASSET_PATHS = "\"Aldo Watch App Watch App/Preview Content\"";
+				DEVELOPMENT_TEAM = A2F9MS5L95;
+				ENABLE_APP_SANDBOX = NO;
+				ENABLE_PREVIEWS = YES;
+				ENABLE_USER_SCRIPT_SANDBOXING = YES;
+				GENERATE_INFOPLIST_FILE = YES;
+				INFOPLIST_KEY_UISupportedInterfaceOrientations = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown";
+				INFOPLIST_KEY_WKCompanionAppBundleIdentifier = Aldo.Aldo;
+				LD_RUNPATH_SEARCH_PATHS = (
+					"$(inherited)",
+					"@executable_path/Frameworks",
+				);
+				MARKETING_VERSION = 1.0;
+				PRODUCT_BUNDLE_IDENTIFIER = Aldo.Aldo.watchkitapp;
+				PRODUCT_NAME = Aldo;
+				SDKROOT = watchos;
+				SKIP_INSTALL = YES;
+				SWIFT_EMIT_LOC_STRINGS = YES;
+				SWIFT_VERSION = 5.0;
+				TARGETED_DEVICE_FAMILY = 4;
+				WATCHOS_DEPLOYMENT_TARGET = 10.5;
+			};
+			name = Release;
+		};
+		EAE8EB832C1A89EE00E30653 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
+				BUNDLE_LOADER = "$(TEST_HOST)";
+				CODE_SIGN_STYLE = Automatic;
+				CURRENT_PROJECT_VERSION = 1;
+				DEVELOPMENT_TEAM = A2F9MS5L95;
+				GENERATE_INFOPLIST_FILE = YES;
+				MARKETING_VERSION = 1.0;
+				PRODUCT_BUNDLE_IDENTIFIER = "Aldo.Aldo-Watch-App-Watch-AppTests";
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = watchos;
+				SWIFT_EMIT_LOC_STRINGS = NO;
+				SWIFT_VERSION = 5.0;
+				TARGETED_DEVICE_FAMILY = 4;
+				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Aldo Watch App Watch App.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Aldo Watch App Watch App";
+				WATCHOS_DEPLOYMENT_TARGET = 10.5;
+			};
+			name = Debug;
+		};
+		EAE8EB842C1A89EE00E30653 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
+				BUNDLE_LOADER = "$(TEST_HOST)";
+				CODE_SIGN_STYLE = Automatic;
+				CURRENT_PROJECT_VERSION = 1;
+				DEVELOPMENT_TEAM = A2F9MS5L95;
+				GENERATE_INFOPLIST_FILE = YES;
+				MARKETING_VERSION = 1.0;
+				PRODUCT_BUNDLE_IDENTIFIER = "Aldo.Aldo-Watch-App-Watch-AppTests";
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = watchos;
+				SWIFT_EMIT_LOC_STRINGS = NO;
+				SWIFT_VERSION = 5.0;
+				TARGETED_DEVICE_FAMILY = 4;
+				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Aldo Watch App Watch App.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Aldo Watch App Watch App";
+				WATCHOS_DEPLOYMENT_TARGET = 10.5;
+			};
+			name = Release;
+		};
+		EAE8EB862C1A89EE00E30653 /* Debug */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
+				CODE_SIGN_STYLE = Automatic;
+				CURRENT_PROJECT_VERSION = 1;
+				DEVELOPMENT_TEAM = A2F9MS5L95;
+				GENERATE_INFOPLIST_FILE = YES;
+				MARKETING_VERSION = 1.0;
+				PRODUCT_BUNDLE_IDENTIFIER = "Aldo.Aldo-Watch-App-Watch-AppUITests";
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = watchos;
+				SWIFT_EMIT_LOC_STRINGS = NO;
+				SWIFT_VERSION = 5.0;
+				TARGETED_DEVICE_FAMILY = 4;
+				TEST_TARGET_NAME = "Aldo Watch App Watch App";
+				WATCHOS_DEPLOYMENT_TARGET = 10.5;
+			};
+			name = Debug;
+		};
+		EAE8EB872C1A89EE00E30653 /* Release */ = {
+			isa = XCBuildConfiguration;
+			buildSettings = {
+				ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES = YES;
+				CODE_SIGN_STYLE = Automatic;
+				CURRENT_PROJECT_VERSION = 1;
+				DEVELOPMENT_TEAM = A2F9MS5L95;
+				GENERATE_INFOPLIST_FILE = YES;
+				MARKETING_VERSION = 1.0;
+				PRODUCT_BUNDLE_IDENTIFIER = "Aldo.Aldo-Watch-App-Watch-AppUITests";
+				PRODUCT_NAME = "$(TARGET_NAME)";
+				SDKROOT = watchos;
+				SWIFT_EMIT_LOC_STRINGS = NO;
+				SWIFT_VERSION = 5.0;
+				TARGETED_DEVICE_FAMILY = 4;
+				TEST_TARGET_NAME = "Aldo Watch App Watch App";
+				WATCHOS_DEPLOYMENT_TARGET = 10.5;
+			};
+			name = Release;
+		};
 /* End XCBuildConfiguration section */
 
 /* Begin XCConfigurationList section */
@@ -591,7 +1332,242 @@
 			defaultConfigurationIsVisible = 0;
 			defaultConfigurationName = Release;
 		};
+		EAE8EB7E2C1A89EE00E30653 /* Build configuration list for PBXNativeTarget "Aldo Watch App" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				EAE8EB7F2C1A89EE00E30653 /* Debug */,
+				EAE8EB802C1A89EE00E30653 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		EAE8EB822C1A89EE00E30653 /* Build configuration list for PBXNativeTarget "Aldo Watch AppTests" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				EAE8EB832C1A89EE00E30653 /* Debug */,
+				EAE8EB842C1A89EE00E30653 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
+		EAE8EB852C1A89EE00E30653 /* Build configuration list for PBXNativeTarget "Aldo Watch AppUITests" */ = {
+			isa = XCConfigurationList;
+			buildConfigurations = (
+				EAE8EB862C1A89EE00E30653 /* Debug */,
+				EAE8EB872C1A89EE00E30653 /* Release */,
+			);
+			defaultConfigurationIsVisible = 0;
+			defaultConfigurationName = Release;
+		};
 /* End XCConfigurationList section */
+
+/* Begin XCRemoteSwiftPackageReference section */
+		4910B9052D617DE200C0FCAF /* XCRemoteSwiftPackageReference "Swift-SMTP" */ = {
+			isa = XCRemoteSwiftPackageReference;
+			repositoryURL = "https://github.com/IBM-Swift/Swift-SMTP";
+			requirement = {
+				kind = upToNextMajorVersion;
+				minimumVersion = 6.0.0;
+			};
+		};
+		EA0D9BD02C1AADFF0045669C /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */ = {
+			isa = XCRemoteSwiftPackageReference;
+			repositoryURL = "https://github.com/SDWebImage/SDWebImageSwiftUI";
+			requirement = {
+				kind = upToNextMajorVersion;
+				minimumVersion = 3.0.4;
+			};
+		};
+		EA0D9BD32C23C8920045669C /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */ = {
+			isa = XCRemoteSwiftPackageReference;
+			repositoryURL = "https://github.com/facebook/facebook-ios-sdk";
+			requirement = {
+				kind = upToNextMajorVersion;
+				minimumVersion = 14.1.0;
+			};
+		};
+		EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */ = {
+			isa = XCRemoteSwiftPackageReference;
+			repositoryURL = "https://github.com/firebase/firebase-ios-sdk";
+			requirement = {
+				kind = upToNextMajorVersion;
+				minimumVersion = 10.27.0;
+			};
+		};
+/* End XCRemoteSwiftPackageReference section */
+
+/* Begin XCSwiftPackageProductDependency section */
+		4910B9062D617E1800C0FCAF /* SwiftSMTP */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = 4910B9052D617DE200C0FCAF /* XCRemoteSwiftPackageReference "Swift-SMTP" */;
+			productName = SwiftSMTP;
+		};
+		EA0D9B972C1AA9500045669C /* FirebaseAnalytics */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseAnalytics;
+		};
+		EA0D9B992C1AA9500045669C /* FirebaseAnalyticsOnDeviceConversion */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseAnalyticsOnDeviceConversion;
+		};
+		EA0D9B9B2C1AA9500045669C /* FirebaseAnalyticsSwift */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseAnalyticsSwift;
+		};
+		EA0D9B9D2C1AA9500045669C /* FirebaseAnalyticsWithoutAdIdSupport */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseAnalyticsWithoutAdIdSupport;
+		};
+		EA0D9B9F2C1AA9500045669C /* FirebaseAppCheck */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseAppCheck;
+		};
+		EA0D9BA22C1AAACD0045669C /* FirebaseAppDistribution-Beta */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseAppDistribution-Beta";
+		};
+		EA0D9BA42C1AAACD0045669C /* FirebaseAuth */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseAuth;
+		};
+		EA0D9BA62C1AAACD0045669C /* FirebaseAuthCombine-Community */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseAuthCombine-Community";
+		};
+		EA0D9BA82C1AAACD0045669C /* FirebaseCrashlytics */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseCrashlytics;
+		};
+		EA0D9BAA2C1AAACD0045669C /* FirebaseDatabase */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseDatabase;
+		};
+		EA0D9BAC2C1AAACD0045669C /* FirebaseDatabaseSwift */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseDatabaseSwift;
+		};
+		EA0D9BAE2C1AAACD0045669C /* FirebaseDynamicLinks */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseDynamicLinks;
+		};
+		EA0D9BB02C1AAACD0045669C /* FirebaseFirestore */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseFirestore;
+		};
+		EA0D9BB22C1AAACD0045669C /* FirebaseFirestoreCombine-Community */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseFirestoreCombine-Community";
+		};
+		EA0D9BB42C1AAACD0045669C /* FirebaseFirestoreSwift */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseFirestoreSwift;
+		};
+		EA0D9BB62C1AAACD0045669C /* FirebaseFunctions */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseFunctions;
+		};
+		EA0D9BB82C1AAACD0045669C /* FirebaseFunctionsCombine-Community */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseFunctionsCombine-Community";
+		};
+		EA0D9BBA2C1AAACD0045669C /* FirebaseInAppMessaging-Beta */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseInAppMessaging-Beta";
+		};
+		EA0D9BBC2C1AAACD0045669C /* FirebaseInAppMessagingSwift-Beta */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseInAppMessagingSwift-Beta";
+		};
+		EA0D9BBE2C1AAACD0045669C /* FirebaseInstallations */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseInstallations;
+		};
+		EA0D9BC02C1AAACD0045669C /* FirebaseMessaging */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseMessaging;
+		};
+		EA0D9BC22C1AAACD0045669C /* FirebaseMLModelDownloader */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseMLModelDownloader;
+		};
+		EA0D9BC42C1AAACD0045669C /* FirebasePerformance */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebasePerformance;
+		};
+		EA0D9BC62C1AAACD0045669C /* FirebaseRemoteConfig */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseRemoteConfig;
+		};
+		EA0D9BC82C1AAACD0045669C /* FirebaseRemoteConfigSwift */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseRemoteConfigSwift;
+		};
+		EA0D9BCA2C1AAACD0045669C /* FirebaseStorage */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = FirebaseStorage;
+		};
+		EA0D9BCC2C1AAACD0045669C /* FirebaseStorageCombine-Community */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseStorageCombine-Community";
+		};
+		EA0D9BCE2C1AAACD0045669C /* FirebaseVertexAI-Preview */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EAE8EBA52C1A99ED00E30653 /* XCRemoteSwiftPackageReference "firebase-ios-sdk" */;
+			productName = "FirebaseVertexAI-Preview";
+		};
+		EA0D9BD12C1AADFF0045669C /* SDWebImageSwiftUI */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EA0D9BD02C1AADFF0045669C /* XCRemoteSwiftPackageReference "SDWebImageSwiftUI" */;
+			productName = SDWebImageSwiftUI;
+		};
+		EA0D9BD42C23C8930045669C /* FacebookAEM */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EA0D9BD32C23C8920045669C /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */;
+			productName = FacebookAEM;
+		};
+		EA0D9BD62C23C8930045669C /* FacebookBasics */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EA0D9BD32C23C8920045669C /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */;
+			productName = FacebookBasics;
+		};
+		EA0D9BD82C23C8930045669C /* FacebookCore */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EA0D9BD32C23C8920045669C /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */;
+			productName = FacebookCore;
+		};
+		EA0D9BDC2C23C8930045669C /* FacebookLogin */ = {
+			isa = XCSwiftPackageProductDependency;
+			package = EA0D9BD32C23C8920045669C /* XCRemoteSwiftPackageReference "facebook-ios-sdk" */;
+			productName = FacebookLogin;
+		};
+/* End XCSwiftPackageProductDependency section */
 	};
 	rootObject = EAE8EB1F2C1A898D00E30653 /* Project object */;
 }
diff --git a/Aldo.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved b/Aldo.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
new file mode 100644
index 0000000..152dc0f
--- /dev/null
+++ b/Aldo.xcodeproj/project.xcworkspace/xcshareddata/swiftpm/Package.resolved
@@ -0,0 +1,204 @@
+{
+  "originHash" : "498e56f7c6018866d37fbe1e7e1c880ff1496395541e10f83aedece06188f115",
+  "pins" : [
+    {
+      "identity" : "abseil-cpp-binary",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/abseil-cpp-binary.git",
+      "state" : {
+        "revision" : "748c7837511d0e6a507737353af268484e1745e2",
+        "version" : "1.2024011601.1"
+      }
+    },
+    {
+      "identity" : "app-check",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/app-check.git",
+      "state" : {
+        "revision" : "076b241a625e25eac22f8849be256dfb960fcdfe",
+        "version" : "10.19.1"
+      }
+    },
+    {
+      "identity" : "bluecryptor",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/Kitura/BlueCryptor.git",
+      "state" : {
+        "revision" : "cec97c24b111351e70e448972a7d3fe68a756d6d",
+        "version" : "2.0.2"
+      }
+    },
+    {
+      "identity" : "bluesocket",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/Kitura/BlueSocket.git",
+      "state" : {
+        "revision" : "7b23a867008e0027bfd6f4d398d44720707bc8ca",
+        "version" : "2.0.4"
+      }
+    },
+    {
+      "identity" : "bluesslservice",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/Kitura/BlueSSLService.git",
+      "state" : {
+        "revision" : "b27a94d063962dfa1bba9f79814c4ef202cf33a4",
+        "version" : "2.0.2"
+      }
+    },
+    {
+      "identity" : "facebook-ios-sdk",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/facebook/facebook-ios-sdk",
+      "state" : {
+        "revision" : "c19607d535864533523d1f437c84035e5fb101cf",
+        "version" : "14.1.0"
+      }
+    },
+    {
+      "identity" : "firebase-ios-sdk",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/firebase/firebase-ios-sdk",
+      "state" : {
+        "revision" : "8bcaf973b1d84e119b7c7c119abad72ed460979f",
+        "version" : "10.27.0"
+      }
+    },
+    {
+      "identity" : "googleappmeasurement",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/GoogleAppMeasurement.git",
+      "state" : {
+        "revision" : "70df02431e216bed98dd461e0c4665889245ba70",
+        "version" : "10.27.0"
+      }
+    },
+    {
+      "identity" : "googledatatransport",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/GoogleDataTransport.git",
+      "state" : {
+        "revision" : "a637d318ae7ae246b02d7305121275bc75ed5565",
+        "version" : "9.4.0"
+      }
+    },
+    {
+      "identity" : "googleutilities",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/GoogleUtilities.git",
+      "state" : {
+        "revision" : "57a1d307f42df690fdef2637f3e5b776da02aad6",
+        "version" : "7.13.3"
+      }
+    },
+    {
+      "identity" : "grpc-binary",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/grpc-binary.git",
+      "state" : {
+        "revision" : "e9fad491d0673bdda7063a0341fb6b47a30c5359",
+        "version" : "1.62.2"
+      }
+    },
+    {
+      "identity" : "gtm-session-fetcher",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/gtm-session-fetcher.git",
+      "state" : {
+        "revision" : "0382ca27f22fb3494cf657d8dc356dc282cd1193",
+        "version" : "3.4.1"
+      }
+    },
+    {
+      "identity" : "interop-ios-for-google-sdks",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/interop-ios-for-google-sdks.git",
+      "state" : {
+        "revision" : "2d12673670417654f08f5f90fdd62926dc3a2648",
+        "version" : "100.0.0"
+      }
+    },
+    {
+      "identity" : "leveldb",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/firebase/leveldb.git",
+      "state" : {
+        "revision" : "a0bc79961d7be727d258d33d5a6b2f1023270ba1",
+        "version" : "1.22.5"
+      }
+    },
+    {
+      "identity" : "loggerapi",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/Kitura/LoggerAPI.git",
+      "state" : {
+        "revision" : "e82d34eab3f0b05391082b11ea07d3b70d2f65bb",
+        "version" : "1.9.200"
+      }
+    },
+    {
+      "identity" : "nanopb",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/firebase/nanopb.git",
+      "state" : {
+        "revision" : "b7e1104502eca3a213b46303391ca4d3bc8ddec1",
+        "version" : "2.30910.0"
+      }
+    },
+    {
+      "identity" : "promises",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/google/promises.git",
+      "state" : {
+        "revision" : "540318ecedd63d883069ae7f1ed811a2df00b6ac",
+        "version" : "2.4.0"
+      }
+    },
+    {
+      "identity" : "sdwebimage",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/SDWebImage/SDWebImage.git",
+      "state" : {
+        "revision" : "b8523c1642f3c142b06dd98443ea7c48343a4dfd",
+        "version" : "5.19.3"
+      }
+    },
+    {
+      "identity" : "sdwebimageswiftui",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/SDWebImage/SDWebImageSwiftUI",
+      "state" : {
+        "revision" : "b7af5e6bd9c2987e41730400d1baad13d74a141a",
+        "version" : "3.0.4"
+      }
+    },
+    {
+      "identity" : "swift-log",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/apple/swift-log.git",
+      "state" : {
+        "revision" : "96a2f8a0fa41e9e09af4585e2724c4e825410b91",
+        "version" : "1.6.2"
+      }
+    },
+    {
+      "identity" : "swift-protobuf",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/apple/swift-protobuf.git",
+      "state" : {
+        "revision" : "9f0c76544701845ad98716f3f6a774a892152bcb",
+        "version" : "1.26.0"
+      }
+    },
+    {
+      "identity" : "swift-smtp",
+      "kind" : "remoteSourceControl",
+      "location" : "https://github.com/IBM-Swift/Swift-SMTP",
+      "state" : {
+        "revision" : "4b7666bb8cee33f0cb367786af17b9a2ebb63047",
+        "version" : "6.0.0"
+      }
+    }
+  ],
+  "version" : 3
+}
diff --git a/Aldo.xcodeproj/xcuserdata/akatsifis.xcuserdatad/xcschemes/xcschememanagement.plist b/Aldo.xcodeproj/xcuserdata/akatsifis.xcuserdatad/xcschemes/xcschememanagement.plist
index e54dff5..7706901 100644
--- a/Aldo.xcodeproj/xcuserdata/akatsifis.xcuserdatad/xcschemes/xcschememanagement.plist
+++ b/Aldo.xcodeproj/xcuserdata/akatsifis.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -4,11 +4,52 @@
 <dict>
 	<key>SchemeUserState</key>
 	<dict>
+		<key>Aldo Watch App (Notification).xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>2</integer>
+		</dict>
+		<key>Aldo Watch App Watch App (Notification).xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>2</integer>
+		</dict>
+		<key>Aldo Watch App Watch App.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>1</integer>
+		</dict>
+		<key>Aldo Watch App.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>1</integer>
+		</dict>
 		<key>Aldo.xcscheme_^#shared#^_</key>
 		<dict>
 			<key>orderHint</key>
 			<integer>0</integer>
 		</dict>
+		<key>Promises (Playground) 1.xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+			<key>orderHint</key>
+			<integer>3</integer>
+		</dict>
+		<key>Promises (Playground) 2.xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+			<key>orderHint</key>
+			<integer>4</integer>
+		</dict>
+		<key>Promises (Playground).xcscheme</key>
+		<dict>
+			<key>isShown</key>
+			<false/>
+			<key>orderHint</key>
+			<integer>2</integer>
+		</dict>
 	</dict>
 </dict>
 </plist>
diff --git a/Aldo.xcodeproj/xcuserdata/andrew.xcuserdatad/xcschemes/xcschememanagement.plist b/Aldo.xcodeproj/xcuserdata/andrew.xcuserdatad/xcschemes/xcschememanagement.plist
new file mode 100644
index 0000000..d49554d
--- /dev/null
+++ b/Aldo.xcodeproj/xcuserdata/andrew.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>SchemeUserState</key>
+	<dict>
+		<key>Aldo Watch App.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>1</integer>
+		</dict>
+		<key>Aldo.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>0</integer>
+		</dict>
+	</dict>
+</dict>
+</plist>
diff --git a/Aldo.xcodeproj/xcuserdata/andrewkatsifis.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist b/Aldo.xcodeproj/xcuserdata/andrewkatsifis.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
new file mode 100644
index 0000000..6d9c534
--- /dev/null
+++ b/Aldo.xcodeproj/xcuserdata/andrewkatsifis.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Bucket
+   uuid = "93C1F4BA-3485-4A8E-AEE8-75FAE96A5AC9"
+   type = "1"
+   version = "2.0">
+</Bucket>
diff --git a/Aldo.xcodeproj/xcuserdata/andrewkatsifis.xcuserdatad/xcschemes/xcschememanagement.plist b/Aldo.xcodeproj/xcuserdata/andrewkatsifis.xcuserdatad/xcschemes/xcschememanagement.plist
new file mode 100644
index 0000000..d49554d
--- /dev/null
+++ b/Aldo.xcodeproj/xcuserdata/andrewkatsifis.xcuserdatad/xcschemes/xcschememanagement.plist
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>SchemeUserState</key>
+	<dict>
+		<key>Aldo Watch App.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>1</integer>
+		</dict>
+		<key>Aldo.xcscheme_^#shared#^_</key>
+		<dict>
+			<key>orderHint</key>
+			<integer>0</integer>
+		</dict>
+	</dict>
+</dict>
+</plist>
diff --git a/Aldo.xcworkspace/contents.xcworkspacedata b/Aldo.xcworkspace/contents.xcworkspacedata
new file mode 100644
index 0000000..ae68586
--- /dev/null
+++ b/Aldo.xcworkspace/contents.xcworkspacedata
@@ -0,0 +1,10 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Workspace
+   version = "1.0">
+   <FileRef
+      location = "group:Aldo.xcodeproj">
+   </FileRef>
+   <FileRef
+      location = "group:Pods/Pods.xcodeproj">
+   </FileRef>
+</Workspace>
diff --git a/Aldo/Aldo.entitlements b/Aldo/Aldo.entitlements
new file mode 100644
index 0000000..c3ecd3f
--- /dev/null
+++ b/Aldo/Aldo.entitlements
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>com.apple.developer.applesignin</key>
+	<array>
+		<string>Default</string>
+	</array>
+	<key>com.apple.developer.authentication-services.autofill-credential-provider</key>
+	<true/>
+	<key>com.apple.developer.healthkit</key>
+	<true/>
+	<key>com.apple.developer.healthkit.access</key>
+	<array/>
+</dict>
+</plist>
diff --git a/Aldo/AldoApp.swift b/Aldo/AldoApp.swift
index 1a1f044..3ac7845 100644
--- a/Aldo/AldoApp.swift
+++ b/Aldo/AldoApp.swift
@@ -6,27 +6,24 @@
 //
 
 import SwiftUI
-import SwiftData
+import Firebase
 
 @main
 struct AldoApp: App {
-    var sharedModelContainer: ModelContainer = {
-        let schema = Schema([
-            Item.self,
-        ])
-        let modelConfiguration = ModelConfiguration(schema: schema, isStoredInMemoryOnly: false)
+    @StateObject private var workoutManager = iOSWorkoutManager()
+    @StateObject private var authManager = AuthenticationManager()
+    @StateObject private var networkMonitor = NetworkMonitor()
 
-        do {
-            return try ModelContainer(for: schema, configurations: [modelConfiguration])
-        } catch {
-            fatalError("Could not create ModelContainer: \(error)")
-        }
-    }()
+    init() {
+        FirebaseApp.configure() // Initialize Firebase
+    }
 
     var body: some Scene {
         WindowGroup {
             ContentView()
+                .environmentObject(workoutManager)
+                .environmentObject(authManager)
+                .environmentObject(networkMonitor)
         }
-        .modelContainer(sharedModelContainer)
     }
 }
diff --git a/Aldo/Aldo_WatchApp.swift b/Aldo/Aldo_WatchApp.swift
new file mode 100644
index 0000000..357a0ba
--- /dev/null
+++ b/Aldo/Aldo_WatchApp.swift
@@ -0,0 +1,19 @@
+//
+//  Aldo_WatchApp.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/19/24.
+//
+
+import SwiftUI
+
+struct Aldo_WatchApp: App {
+    @StateObject var workoutManager = WatchWorkoutManager() // Initialize the workout manager
+
+    var body: some Scene {
+        WindowGroup {
+            ContentView() // Your initial view
+                .environmentObject(workoutManager) // Provide the workout manager to the environment
+        }
+    }
+}
diff --git a/Aldo/AppDelegate.swift b/Aldo/AppDelegate.swift
new file mode 100644
index 0000000..baad3b0
--- /dev/null
+++ b/Aldo/AppDelegate.swift
@@ -0,0 +1,81 @@
+//  AppDelegate.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/19/24.
+//
+import UIKit
+import HealthKit
+import Firebase
+import FirebaseMessaging
+
+class AppDelegate: UIResponder, UIApplicationDelegate, MessagingDelegate {
+
+    let healthStore = HKHealthStore()
+
+    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
+        // Request HealthKit authorization
+        requestHealthAuthorization()
+        
+        // Setup Firebase messaging
+        setupFirebaseMessaging()
+        
+        return true
+    }
+
+    func requestHealthAuthorization() {
+        guard HKHealthStore.isHealthDataAvailable() else {
+            return
+        }
+
+        let allTypes = Set([
+            HKObjectType.workoutType(),
+            HKObjectType.quantityType(forIdentifier: .heartRate)!
+        ])
+
+        healthStore.requestAuthorization(toShare: allTypes, read: allTypes) { success, error in
+            if !success {
+                // Handle the error here.
+                print("HealthKit authorization failed: \(error?.localizedDescription ?? "Unknown error")")
+            }
+        }
+    }
+    
+    func setupFirebaseMessaging() {
+        Messaging.messaging().delegate = self
+        
+        // Register for remote notifications
+        UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .badge, .sound]) { success, error in
+            if let error = error {
+                print("Error requesting notification permissions: \(error.localizedDescription)")
+            }
+        }
+        
+        UIApplication.shared.registerForRemoteNotifications()
+    }
+    
+    // MARK: - Messaging Delegate Methods
+    
+    func messaging(_ messaging: Messaging, didReceiveRegistrationToken fcmToken: String?) {
+        guard let token = fcmToken else { return }
+        print("Firebase registration token: \(token)")
+        
+        // Save the token
+        UserService.shared.saveFCMToken(token) { success in
+            if success {
+                print("FCM token saved successfully")
+            } else {
+                print("Failed to save FCM token")
+            }
+        }
+    }
+    
+    // MARK: - Remote Notification Registration
+    
+    func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
+        Messaging.messaging().apnsToken = deviceToken
+    }
+    
+    func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Error) {
+        print("Failed to register for remote notifications: \(error.localizedDescription)")
+    }
+}
diff --git a/Aldo/AppUser.swift b/Aldo/AppUser.swift
new file mode 100644
index 0000000..656366c
--- /dev/null
+++ b/Aldo/AppUser.swift
@@ -0,0 +1,20 @@
+//
+//  AppUser.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/24/24.
+//
+
+
+import Foundation
+
+struct AppUser: Identifiable, Hashable {
+    let id = UUID()
+    let username: String
+    let profilePicture: String
+    var isFriendRequestPending: Bool
+
+    func hash(into hasher: inout Hasher) {
+        hasher.combine(id)
+    }
+}
diff --git a/Aldo/Assets.xcassets/AppIcon.appiconset/Contents.json b/Aldo/Assets.xcassets/AppIcon.appiconset/Contents.json
index 13613e3..dfe6263 100644
--- a/Aldo/Assets.xcassets/AppIcon.appiconset/Contents.json
+++ b/Aldo/Assets.xcassets/AppIcon.appiconset/Contents.json
@@ -1,6 +1,7 @@
 {
   "images" : [
     {
+      "filename" : "F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.jpeg",
       "idiom" : "universal",
       "platform" : "ios",
       "size" : "1024x1024"
diff --git a/Aldo/Assets.xcassets/AppIcon.appiconset/F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.jpeg b/Aldo/Assets.xcassets/AppIcon.appiconset/F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.jpeg
new file mode 100644
index 0000000..6edfd6d
Binary files /dev/null and b/Aldo/Assets.xcassets/AppIcon.appiconset/F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.jpeg differ
diff --git a/Aldo/Assets.xcassets/Armitage.imageset/Armitage.png b/Aldo/Assets.xcassets/Armitage.imageset/Armitage.png
new file mode 100644
index 0000000..7822629
Binary files /dev/null and b/Aldo/Assets.xcassets/Armitage.imageset/Armitage.png differ
diff --git a/Aldo/Assets.xcassets/Armitage.imageset/Contents.json b/Aldo/Assets.xcassets/Armitage.imageset/Contents.json
new file mode 100644
index 0000000..fad9c47
--- /dev/null
+++ b/Aldo/Assets.xcassets/Armitage.imageset/Contents.json
@@ -0,0 +1,21 @@
+{
+  "images" : [
+    {
+      "filename" : "Armitage.png",
+      "idiom" : "universal",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo/Assets.xcassets/F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.imageset/Contents.json b/Aldo/Assets.xcassets/F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.imageset/Contents.json
new file mode 100644
index 0000000..a19a549
--- /dev/null
+++ b/Aldo/Assets.xcassets/F0378EA8-C4F3-4F01-8362-39C1FD7844AB_1_102_o.imageset/Contents.json
@@ -0,0 +1,20 @@
+{
+  "images" : [
+    {
+      "idiom" : "universal",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo/Assets.xcassets/Golf.imageset/Contents.json b/Aldo/Assets.xcassets/Golf.imageset/Contents.json
new file mode 100644
index 0000000..3a69017
--- /dev/null
+++ b/Aldo/Assets.xcassets/Golf.imageset/Contents.json
@@ -0,0 +1,21 @@
+{
+  "images" : [
+    {
+      "filename" : "golf-golf-tournament-golf-course-golf-players.jpg",
+      "idiom" : "universal",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo/Assets.xcassets/Golf.imageset/golf-golf-tournament-golf-course-golf-players.jpg b/Aldo/Assets.xcassets/Golf.imageset/golf-golf-tournament-golf-course-golf-players.jpg
new file mode 100644
index 0000000..2faa202
Binary files /dev/null and b/Aldo/Assets.xcassets/Golf.imageset/golf-golf-tournament-golf-course-golf-players.jpg differ
diff --git a/Aldo/Assets.xcassets/newAldo.imageset/Contents.json b/Aldo/Assets.xcassets/newAldo.imageset/Contents.json
new file mode 100644
index 0000000..72c3ec2
--- /dev/null
+++ b/Aldo/Assets.xcassets/newAldo.imageset/Contents.json
@@ -0,0 +1,21 @@
+{
+  "images" : [
+    {
+      "filename" : "IMG_3025.png",
+      "idiom" : "universal",
+      "scale" : "1x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "2x"
+    },
+    {
+      "idiom" : "universal",
+      "scale" : "3x"
+    }
+  ],
+  "info" : {
+    "author" : "xcode",
+    "version" : 1
+  }
+}
diff --git a/Aldo/Assets.xcassets/newAldo.imageset/IMG_3025.png b/Aldo/Assets.xcassets/newAldo.imageset/IMG_3025.png
new file mode 100644
index 0000000..79b6bb5
Binary files /dev/null and b/Aldo/Assets.xcassets/newAldo.imageset/IMG_3025.png differ
diff --git a/Aldo/AuthenticationManager.swift b/Aldo/AuthenticationManager.swift
new file mode 100644
index 0000000..ea0f789
--- /dev/null
+++ b/Aldo/AuthenticationManager.swift
@@ -0,0 +1,452 @@
+//
+//  AuthenticationManager.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+import SwiftUI
+import Combine
+import Firebase
+import FirebaseAuth
+import FirebaseFirestore
+
+class AuthenticationManager: ObservableObject {
+    // Authentication state
+    @Published var isAuthenticated = false
+    @Published var isLoading = false
+    @Published var authError: String?
+    
+    // User data
+    @Published var currentUser: Models.User?
+    @Published var users: [AppUser] = []
+    @Published var friendRequests: [AppUser] = []
+    
+    // Phone verification
+    @Published var verificationID: String?
+    @Published var isPhoneVerificationInProgress = false
+    
+    // Service
+    private let userService = UserService.shared
+    
+    // Cancellables
+    private var cancellables = Set<AnyCancellable>()
+    
+    init() {
+        // Set up subscriber for user changes
+        userService.$currentUser
+            .sink { [weak self] user in
+                self?.currentUser = user
+            }
+            .store(in: &cancellables)
+    }
+    
+    // MARK: - Phone Verification
+    
+    func sendVerificationCode(to phoneNumber: String, completion: @escaping (Bool, String?) -> Void) {
+        isPhoneVerificationInProgress = true
+        
+        PhoneAuthProvider.provider().verifyPhoneNumber(phoneNumber, uiDelegate: nil) { [weak self] verificationID, error in
+            guard let self = self else { return }
+            self.isPhoneVerificationInProgress = false
+            
+            if let error = error {
+                print("Error sending verification code: \(error.localizedDescription)")
+                completion(false, error.localizedDescription)
+                return
+            }
+            
+            if let verificationID = verificationID {
+                self.verificationID = verificationID
+                completion(true, nil)
+            } else {
+                completion(false, "No verification ID returned")
+            }
+        }
+    }
+    
+    func verifyCode(code: String, completion: @escaping (Bool, String?) -> Void) {
+        guard let verificationID = verificationID else {
+            completion(false, "Missing verification ID. Please request a new code.")
+            return
+        }
+        
+        let credential = PhoneAuthProvider.provider().credential(withVerificationID: verificationID, verificationCode: code)
+        
+        Auth.auth().signIn(with: credential) { [weak self] authResult, error in
+            guard let self = self else { return }
+            
+            if let error = error {
+                print("Error verifying code: \(error.localizedDescription)")
+                completion(false, error.localizedDescription)
+                return
+            }
+            
+            // Successfully verified phone number
+            if let user = authResult?.user {
+                // Update the user's phone number in Firestore
+                if let currentUserID = self.currentUser?.id {
+                    let db = Firestore.firestore()
+                    db.collection("users").document(currentUserID).updateData([
+                        "phoneNumber": user.phoneNumber ?? ""
+                    ]) { error in
+                        if let error = error {
+                            print("Error updating phone number: \(error.localizedDescription)")
+                        }
+                    }
+                }
+                
+                completion(true, nil)
+            } else {
+                completion(false, "Failed to authenticate with the verification code")
+            }
+        }
+    }
+    
+    // MARK: - Authentication Methods
+    
+    func signIn(email: String, password: String, completion: @escaping (Bool, String?) -> Void) {
+        isLoading = true
+        authError = nil
+        
+        Auth.auth().signIn(withEmail: email, password: password) { [weak self] authResult, error in
+            guard let self = self else { return }
+            
+            if let error = error {
+                self.isLoading = false
+                self.authError = error.localizedDescription
+                completion(false, error.localizedDescription)
+                return
+            }
+            
+            // Successfully signed in, fetch the user data
+            self.userService.fetchCurrentUser { result in
+                self.isLoading = false
+                
+                switch result {
+                case .success(let user):
+                    self.isAuthenticated = true
+                    self.currentUser = user
+                    completion(true, nil)
+                    
+                case .failure(let error):
+                    self.authError = error.localizedDescription
+                    completion(false, error.localizedDescription)
+                }
+            }
+        }
+    }
+    
+    func signUp(email: String, password: String, username: String, completion: @escaping (Bool) -> Void) {
+        isLoading = true
+        authError = nil
+        
+        Auth.auth().createUser(withEmail: email, password: password) { [weak self] authResult, error in
+            guard let self = self else { return }
+            
+            if let error = error {
+                self.isLoading = false
+                self.authError = error.localizedDescription
+                completion(false)
+                return
+            }
+            
+            if let uid = authResult?.user.uid {
+                // Create basic user document
+                let newUser = Models.User(
+                    id: uid,
+                    username: username,
+                    firstName: "",
+                    lastName: "",
+                    email: email,
+                    phoneNumber: "",
+                    friends: [],
+                    scores: [],
+                    steps: 0
+                )
+                
+                let db = Firestore.firestore()
+                db.collection("users").document(uid).setData(newUser.toDictionary()) { error in
+                    self.isLoading = false
+                    
+                    if let error = error {
+                        self.authError = error.localizedDescription
+                        completion(false)
+                        return
+                    }
+                    
+                    self.currentUser = newUser
+                    self.isAuthenticated = true
+                    completion(true)
+                }
+            } else {
+                self.isLoading = false
+                self.authError = "Failed to get user ID"
+                completion(false)
+            }
+        }
+    }
+    
+    func checkLoginStatus() {
+        if let user = Auth.auth().currentUser {
+            // User is logged in, fetch their data
+            isLoading = true
+            
+            userService.fetchCurrentUser { [weak self] result in
+                guard let self = self else { return }
+                self.isLoading = false
+                
+                switch result {
+                case .success(let user):
+                    self.currentUser = user
+                    self.isAuthenticated = true
+                    
+                case .failure(let error):
+                    print("Error fetching user data: \(error.localizedDescription)")
+                    self.authError = error.localizedDescription
+                    
+                    // For development/testing, still authenticate the user even if fetching fails
+                    self.isAuthenticated = true
+                    self.currentUser = Models.User(
+                        id: user.uid,
+                        username: "test@example.com",
+                        firstName: "",
+                        lastName: "",
+                        email: user.email ?? "test@example.com",
+                        phoneNumber: "",
+                        friends: [],
+                        scores: [],
+                        steps: 0
+                    )
+                }
+            }
+        } else {
+            // For development/testing, auto-authenticate
+            self.isAuthenticated = true
+            self.currentUser = Models.User(
+                id: "testUser",
+                username: "test@example.com",
+                firstName: "",
+                lastName: "",
+                email: "test@example.com",
+                phoneNumber: "",
+                friends: [],
+                scores: [],
+                steps: 0
+            )
+        }
+    }
+    
+    func logout() {
+        do {
+            try Auth.auth().signOut()
+            isAuthenticated = false
+            currentUser = nil
+            authError = nil
+        } catch {
+            authError = error.localizedDescription
+            print("Error signing out: \(error.localizedDescription)")
+        }
+    }
+    
+    // MARK: - User Fetching
+    
+    func fetchUsers(completion: @escaping ([AppUser]) -> Void) {
+        let db = Firestore.firestore()
+        db.collection("users").getDocuments { (snapshot, error) in
+            if let error = error {
+                print("Error fetching users: \(error)")
+                return
+            }
+
+            guard let documents = snapshot?.documents else {
+                print("No users found")
+                return
+            }
+
+            let users = documents.map { doc -> AppUser in
+                let data = doc.data()
+                let username = data["username"] as? String ?? ""
+                let profilePicture = data["profilePicture"] as? String ?? ""
+                let isFriendRequestPending = data["isFriendRequestPending"] as? Bool ?? false
+                return AppUser(username: username, profilePicture: profilePicture, isFriendRequestPending: isFriendRequestPending)
+            }
+            self.users = users
+            completion(users)
+        }
+    }
+    
+    // MARK: - Friend Management
+    
+    func fetchFriendRequests() {
+        guard let userId = Auth.auth().currentUser?.uid else { return }
+        
+        let db = Firestore.firestore()
+        db.collection("friendRequests")
+            .whereField("receiverId", isEqualTo: userId)
+            .whereField("status", isEqualTo: "pending")
+            .getDocuments { [weak self] snapshot, error in
+                guard let self = self else { return }
+                
+                if let error = error {
+                    print("Error fetching friend requests: \(error.localizedDescription)")
+                    return
+                }
+                
+                // Process friend requests
+                if let documents = snapshot?.documents {
+                    // Convert to AppUser objects
+                    let requests = documents.compactMap { doc -> AppUser? in
+                        let senderId = doc.data()["senderId"] as? String ?? ""
+                        
+                        // Fetch sender info
+                        let userRef = db.collection("users").document(senderId)
+                        // Note: This should be optimized with a batched get in a production app
+                        
+                        // For now, we'll just create a placeholder
+                        return AppUser(username: "User \(senderId)", profilePicture: "", isFriendRequestPending: true)
+                    }
+                    
+                    self.friendRequests = requests
+                }
+            }
+    }
+    
+    func acceptFriendRequest(_ user: AppUser, completion: @escaping (Bool) -> Void) {
+        guard let currentUserId = Auth.auth().currentUser?.uid else {
+            completion(false)
+            return
+        }
+        
+        // Since we're using a placeholder model, we need to first get the real user ID
+        let db = Firestore.firestore()
+        
+        // This is a simplification - in a real app you'd need to handle this properly
+        // Here we assume the username format is "User <ID>"
+        let components = user.username.components(separatedBy: " ")
+        guard components.count > 1, let userId = components.last else {
+            completion(false)
+            return
+        }
+        
+        // Find the friend request
+        db.collection("friendRequests")
+            .whereField("senderId", isEqualTo: userId)
+            .whereField("receiverId", isEqualTo: currentUserId)
+            .whereField("status", isEqualTo: "pending")
+            .getDocuments { snapshot, error in
+                if let error = error {
+                    print("Error finding friend request: \(error.localizedDescription)")
+                    completion(false)
+                    return
+                }
+                
+                guard let document = snapshot?.documents.first else {
+                    print("Friend request not found")
+                    completion(false)
+                    return
+                }
+                
+                // Update the request status
+                document.reference.updateData([
+                    "status": "accepted"
+                ]) { error in
+                    if let error = error {
+                        print("Error updating friend request: \(error.localizedDescription)")
+                        completion(false)
+                        return
+                    }
+                    
+                    // Add each user to the other's friends list
+                    let batch = db.batch()
+                    
+                    // Add friend to current user's friends list
+                    let currentUserRef = db.collection("users").document(currentUserId)
+                    batch.updateData([
+                        "friends": FieldValue.arrayUnion([userId])
+                    ], forDocument: currentUserRef)
+                    
+                    // Add current user to friend's friends list
+                    let friendRef = db.collection("users").document(userId)
+                    batch.updateData([
+                        "friends": FieldValue.arrayUnion([currentUserId])
+                    ], forDocument: friendRef)
+                    
+                    // Commit the batch
+                    batch.commit { error in
+                        if let error = error {
+                            print("Error updating friends lists: \(error.localizedDescription)")
+                            completion(false)
+                        } else {
+                            // Remove from friend requests
+                            if let index = self.friendRequests.firstIndex(where: { $0.id == user.id }) {
+                                self.friendRequests.remove(at: index)
+                            }
+                            completion(true)
+                        }
+                    }
+                }
+            }
+    }
+    
+    func sendFriendRequest(to userId: String, completion: @escaping (Bool) -> Void) {
+        guard let currentUserId = Auth.auth().currentUser?.uid else {
+            completion(false)
+            return
+        }
+        
+        let db = Firestore.firestore()
+        
+        // Check if a request already exists
+        db.collection("friendRequests")
+            .whereField("senderId", isEqualTo: currentUserId)
+            .whereField("receiverId", isEqualTo: userId)
+            .getDocuments { snapshot, error in
+                if let error = error {
+                    print("Error checking for existing friend request: \(error.localizedDescription)")
+                    completion(false)
+                    return
+                }
+                
+                if let document = snapshot?.documents.first {
+                    // Request already exists
+                    let status = document.data()["status"] as? String ?? ""
+                    
+                    if status == "pending" {
+                        print("Friend request already sent")
+                        completion(false)
+                    } else if status == "accepted" {
+                        print("Already friends")
+                        completion(false)
+                    } else if status == "declined" {
+                        // Update the declined request to pending
+                        document.reference.updateData([
+                            "status": "pending",
+                            "timestamp": FieldValue.serverTimestamp()
+                        ]) { error in
+                            if let error = error {
+                                print("Error updating friend request: \(error.localizedDescription)")
+                                completion(false)
+                            } else {
+                                completion(true)
+                            }
+                        }
+                    }
+                } else {
+                    // Create a new friend request
+                    db.collection("friendRequests").addDocument(data: [
+                        "senderId": currentUserId,
+                        "receiverId": userId,
+                        "status": "pending",
+                        "timestamp": FieldValue.serverTimestamp()
+                    ]) { error in
+                        if let error = error {
+                            print("Error sending friend request: \(error.localizedDescription)")
+                            completion(false)
+                        } else {
+                            completion(true)
+                        }
+                    }
+                }
+            }
+    }
+}
diff --git a/Aldo/CachedAsyncImage.swift b/Aldo/CachedAsyncImage.swift
new file mode 100644
index 0000000..410d8b8
--- /dev/null
+++ b/Aldo/CachedAsyncImage.swift
@@ -0,0 +1,87 @@
+import SwiftUI
+
+struct CachedAsyncImage<Content: View, Placeholder: View>: View {
+    private let url: URL?
+    private let scale: CGFloat
+    private let transaction: Transaction
+    private let content: (Image) -> Content
+    private let placeholder: () -> Placeholder
+    
+    @State private var cachedImage: UIImage?
+    
+    init(
+        url: URL?,
+        scale: CGFloat = 1.0,
+        transaction: Transaction = Transaction(),
+        @ViewBuilder content: @escaping (Image) -> Content,
+        @ViewBuilder placeholder: @escaping () -> Placeholder
+    ) {
+        self.url = url
+        self.scale = scale
+        self.transaction = transaction
+        self.content = content
+        self.placeholder = placeholder
+    }
+    
+    var body: some View {
+        ZStack {
+            if let cachedImage = cachedImage {
+                content(Image(uiImage: cachedImage))
+            } else {
+                AsyncImage(
+                    url: url,
+                    scale: scale,
+                    transaction: transaction
+                ) { phase in
+                    switch phase {
+                    case .success(let image):
+                        content(image)
+                            .onAppear {
+                                if let url = url {
+                                    let urlString = url.absoluteString
+                                    if let uiImage = toUIImage(from: image) {
+                                        cachedImage = uiImage
+                                        ImageCache.shared.saveImage(uiImage, for: urlString)
+                                    }
+                                }
+                            }
+                    case .failure:
+                        placeholder()
+                    case .empty:
+                        placeholder()
+                    @unknown default:
+                        placeholder()
+                    }
+                }
+            }
+        }
+        .onAppear {
+            loadFromCache()
+        }
+    }
+    
+    private func loadFromCache() {
+        if let url = url {
+            let urlString = url.absoluteString
+            if let image = ImageCache.shared.getImage(for: urlString) {
+                self.cachedImage = image
+            }
+        }
+    }
+    
+    private func toUIImage(from image: Image) -> UIImage? {
+        let renderer = ImageRenderer(content: image.resizable().aspectRatio(contentMode: .fill))
+        return renderer.uiImage
+    }
+}
+
+// Extension to make it easier to use
+extension CachedAsyncImage where Content == Image, Placeholder == ProgressView<EmptyView, EmptyView> {
+    init(url: URL?, scale: CGFloat = 1.0) {
+        self.init(url: url, scale: scale) { image in
+            image
+        } placeholder: {
+            ProgressView()
+        }
+    }
+}
diff --git a/Aldo/ContentView.swift b/Aldo/ContentView.swift
deleted file mode 100644
index 981fd2b..0000000
--- a/Aldo/ContentView.swift
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-//  ContentView.swift
-//  Aldo
-//
-//  Created by Andrew Katsifis on 6/12/24.
-//
-
-import SwiftUI
-import SwiftData
-
-struct ContentView: View {
-    @Environment(\.modelContext) private var modelContext
-    @Query private var items: [Item]
-
-    var body: some View {
-        NavigationSplitView {
-            List {
-                ForEach(items) { item in
-                    NavigationLink {
-                        Text("Item at \(item.timestamp, format: Date.FormatStyle(date: .numeric, time: .standard))")
-                    } label: {
-                        Text(item.timestamp, format: Date.FormatStyle(date: .numeric, time: .standard))
-                    }
-                }
-                .onDelete(perform: deleteItems)
-            }
-            .toolbar {
-                ToolbarItem(placement: .navigationBarTrailing) {
-                    EditButton()
-                }
-                ToolbarItem {
-                    Button(action: addItem) {
-                        Label("Add Item", systemImage: "plus")
-                    }
-                }
-            }
-        } detail: {
-            Text("Select an item")
-        }
-    }
-
-    private func addItem() {
-        withAnimation {
-            let newItem = Item(timestamp: Date())
-            modelContext.insert(newItem)
-        }
-    }
-
-    private func deleteItems(offsets: IndexSet) {
-        withAnimation {
-            for index in offsets {
-                modelContext.delete(items[index])
-            }
-        }
-    }
-}
-
-#Preview {
-    ContentView()
-        .modelContainer(for: Item.self, inMemory: true)
-}
diff --git a/Aldo/EmailService.swift b/Aldo/EmailService.swift
new file mode 100644
index 0000000..6f10ef3
--- /dev/null
+++ b/Aldo/EmailService.swift
@@ -0,0 +1,33 @@
+import SwiftSMTP
+
+class EmailService {
+    static let shared = EmailService()
+    
+    private init() {}
+    
+    func sendEmail(to user: Models.User, subject: String, body: String) {
+        let smtp = SMTP(
+            hostname: "smtp.gmail.com", // e.g., "smtp.gmail.com"
+            email: "AldoGolfApp@gmail.com",
+            password: "kyfqyh-4gesne-paGkyt" // Use the correct password
+        )
+        
+        let from = Mail.User(name: "Your Name", email: "AldoGolfApp@gmail.com") // Correct order: name first
+        let to = Mail.User(name: user.firstName + " " + user.lastName, email: user.email) // Name first, then email
+        
+        let mail = Mail(
+            from: from,
+            to: [to],
+            subject: subject,
+            text: body
+        )
+        
+        smtp.send(mail) { error in
+            if let error = error {
+                print("Failed to send email: \(error.localizedDescription)")
+            } else {
+                print("Email sent successfully to \(user.username).")
+            }
+        }
+    }
+}
diff --git a/Aldo/FirestoreManager.swift b/Aldo/FirestoreManager.swift
new file mode 100644
index 0000000..9f03cdc
--- /dev/null
+++ b/Aldo/FirestoreManager.swift
@@ -0,0 +1,198 @@
+//
+//  FirestoreManager.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 3/4/25.
+//
+import Firebase
+import FirebaseFirestore
+import FirebaseFirestoreSwift
+
+class FirestoreManager {
+    static let shared = FirestoreManager()
+    private let db: Firestore
+    
+    private init() {
+        // Get the Firestore instance but don't configure it directly
+        // The configuration will be done in AldoApp.swift before FirebaseApp.configure()
+        db = Firestore.firestore()
+    }
+    
+    // Method to configure Firestore settings - call this BEFORE Firebase initialization
+    static func configureFirestore() {
+        let settings = FirestoreSettings()
+        settings.isPersistenceEnabled = true
+        settings.cacheSizeBytes = FirestoreCacheSizeUnlimited
+        Firestore.firestore().settings = settings
+    }
+    
+    // MARK: - Score Management
+    
+    func saveScoreOffline(score: Models.User.Score, userId: String, completion: @escaping (Result<String, Error>) -> Void) {
+        // Create a new document reference with auto-generated ID
+        let scoreRef = db.collection("users").document(userId).collection("pendingScores").document()
+        
+        // Convert score to dictionary
+        let scoreData: [String: Any] = [
+            "id": score.id,
+            "course": score.course,
+            "score": score.score,
+            "date": score.date,
+            "holesPlayed": score.holesPlayed,
+            "steps": score.steps ?? 0,
+            "distance": score.distance ?? 0.0,
+            "caloriesBurned": score.caloriesBurned ?? 0.0,
+            "syncStatus": "pending"
+        ]
+        
+        // Set the data
+        scoreRef.setData(scoreData) { error in
+            if let error = error {
+                completion(.failure(error))
+                return
+            }
+            
+            completion(.success(scoreRef.documentID))
+        }
+    }
+    
+    func syncPendingScores(userId: String, completion: @escaping (Result<Int, Error>) -> Void) {
+        // Get all pending scores
+        db.collection("users").document(userId).collection("pendingScores")
+            .whereField("syncStatus", isEqualTo: "pending")
+            .getDocuments { [weak self] snapshot, error in
+                guard let self = self else { return }
+                
+                if let error = error {
+                    completion(.failure(error))
+                    return
+                }
+                
+                guard let documents = snapshot?.documents, !documents.isEmpty else {
+                    completion(.success(0)) // No pending scores to sync
+                    return
+                }
+                
+                var syncedCount = 0
+                let totalCount = documents.count
+                let group = DispatchGroup()
+                var syncError: Error?
+                
+                // Fetch the user document to get the current scores array
+                group.enter()
+                self.db.collection("users").document(userId).getDocument { userSnapshot, error in
+                    defer { group.leave() }
+                    
+                    if let error = error {
+                        syncError = error
+                        return
+                    }
+                    
+                    guard let userData = userSnapshot?.data() else {
+                        syncError = NSError(domain: "FirestoreManager", code: 404, userInfo: [NSLocalizedDescriptionKey: "User document not found"])
+                        return
+                    }
+                    
+                    // Get current scores
+                    var userScores: [[String: Any]] = []
+                    if let currentScores = userData["scores"] as? [[String: Any]] {
+                        userScores = currentScores
+                    }
+                    
+                    // Add pending scores to the user's scores array
+                    for document in documents {
+                        group.enter()
+                        let scoreData = document.data()
+                        var scoreDict: [String: Any] = [:]
+                        
+                        // Copy relevant fields to the score dictionary
+                        for key in ["id", "course", "score", "date", "holesPlayed", "steps", "distance", "caloriesBurned"] {
+                            if let value = scoreData[key] {
+                                scoreDict[key] = value
+                            }
+                        }
+                        
+                        // Add to user's scores
+                        userScores.append(scoreDict)
+                        
+                        // Mark this pending score as synced
+                        document.reference.updateData(["syncStatus": "synced"]) { error in
+                            defer { group.leave() }
+                            
+                            if let error = error {
+                                print("Error marking score as synced: \(error.localizedDescription)")
+                                return
+                            }
+                            
+                            syncedCount += 1
+                        }
+                    }
+                    
+                    // Update the user document with the new scores array
+                    self.db.collection("users").document(userId).updateData([
+                        "scores": userScores
+                    ]) { error in
+                        if let error = error {
+                            syncError = error
+                        }
+                    }
+                }
+                
+                // When all operations are complete
+                group.notify(queue: .main) {
+                    if let syncError = syncError {
+                        completion(.failure(syncError))
+                    } else {
+                        completion(.success(syncedCount))
+                    }
+                }
+            }
+    }
+    
+    func cleanupSyncedScores(userId: String, completion: @escaping (Result<Int, Error>) -> Void) {
+        // Find all synced scores older than 7 days
+        let oneWeekAgo = Calendar.current.date(byAdding: .day, value: -7, to: Date()) ?? Date()
+        
+        db.collection("users").document(userId).collection("pendingScores")
+            .whereField("syncStatus", isEqualTo: "synced")
+            .whereField("date", isLessThan: oneWeekAgo)
+            .getDocuments { snapshot, error in
+                if let error = error {
+                    completion(.failure(error))
+                    return
+                }
+                
+                guard let documents = snapshot?.documents, !documents.isEmpty else {
+                    completion(.success(0)) // No old scores to clean up
+                    return
+                }
+                
+                let batch = self.db.batch()
+                
+                // Add delete operations to batch
+                for document in documents {
+                    batch.deleteDocument(document.reference)
+                }
+                
+                // Commit batch
+                batch.commit { error in
+                    if let error = error {
+                        completion(.failure(error))
+                    } else {
+                        completion(.success(documents.count))
+                    }
+                }
+            }
+    }
+    
+    // MARK: - Network state monitoring
+    
+    func addNetworkListener(onNetworkAvailable: @escaping () -> Void) {
+        db.collection("users").document("networkTest").addSnapshotListener { _, error in
+            if error == nil {
+                // If we can successfully listen to Firestore, we have network connectivity
+                onNetworkAvailable()
+            }
+        }
+    }
+}
diff --git a/Aldo/Friend.swift b/Aldo/Friend.swift
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/Aldo/Friend.swift
@@ -0,0 +1 @@
+
diff --git a/Aldo/HealthKitIntegration.swift b/Aldo/HealthKitIntegration.swift
new file mode 100644
index 0000000..9adc816
--- /dev/null
+++ b/Aldo/HealthKitIntegration.swift
@@ -0,0 +1,39 @@
+//
+//  HealthKitIntegration.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/22/24.
+//
+import SwiftUI
+import HealthKit
+
+struct HealthkitIntegrationApp: App {
+    
+    private let healthStore: HKHealthStore
+    
+    init() {
+        guard HKHealthStore.isHealthDataAvailable() else {  fatalError("This app requires a device that supports HealthKit") }
+        healthStore = HKHealthStore()
+        requestHealthkitPermissions()
+    }
+    
+    private func requestHealthkitPermissions() {
+        
+        let sampleTypesToRead = Set([
+            HKObjectType.quantityType(forIdentifier: .heartRate)!,
+            HKObjectType.quantityType(forIdentifier: .stepCount)!,
+            HKObjectType.categoryType(forIdentifier: .sleepAnalysis)!,
+        ])
+        
+        healthStore.requestAuthorization(toShare: nil, read: sampleTypesToRead) { (success, error) in
+            print("Request Authorization -- Success: ", success, " Error: ", error ?? "nil")
+        }
+    }
+    
+    var body: some Scene {
+        WindowGroup {
+            ContentView().environmentObject(healthStore)
+        }
+    }
+}
+    extension HKHealthStore: ObservableObject{}
diff --git a/Aldo/ImageCache.swift b/Aldo/ImageCache.swift
new file mode 100644
index 0000000..42b2c3c
--- /dev/null
+++ b/Aldo/ImageCache.swift
@@ -0,0 +1,137 @@
+//
+//  ImageCache.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 3/4/25.
+//
+
+
+import Foundation
+import SwiftUI
+
+class ImageCache {
+    static let shared = ImageCache()
+    
+    private let cache = NSCache<NSString, UIImage>()
+    private let fileManager = FileManager.default
+    private let diskCacheDirectory: URL
+    
+    private init() {
+        // Set up disk cache
+        let cacheDirectory = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first!
+        diskCacheDirectory = cacheDirectory.appendingPathComponent("ImageCache")
+        
+        // Create directory if it doesn't exist
+        if !fileManager.fileExists(atPath: diskCacheDirectory.path) {
+            do {
+                try fileManager.createDirectory(at: diskCacheDirectory, withIntermediateDirectories: true)
+            } catch {
+                print("Error creating disk cache directory: \(error)")
+            }
+        }
+        
+        // Set cache limits
+        cache.countLimit = 100 // Max number of images
+        cache.totalCostLimit = 50 * 1024 * 1024 // 50MB
+    }
+    
+    // MARK: - Memory Cache
+    
+    func getFromMemory(for key: String) -> UIImage? {
+        return cache.object(forKey: key as NSString)
+    }
+    
+    func saveToMemory(_ image: UIImage, for key: String) {
+        // Estimate memory cost (width * height * 4 bytes per pixel)
+        let cost = Int(image.size.width * image.size.height * 4)
+        cache.setObject(image, forKey: key as NSString, cost: cost)
+    }
+    
+    // MARK: - Disk Cache
+    
+    func getFromDisk(for key: String) -> UIImage? {
+        let fileURL = diskCacheDirectory.appendingPathComponent(key.md5Hash)
+        
+        if fileManager.fileExists(atPath: fileURL.path) {
+            do {
+                let data = try Data(contentsOf: fileURL)
+                if let image = UIImage(data: data) {
+                    // If found on disk, also cache in memory
+                    saveToMemory(image, for: key)
+                    return image
+                }
+            } catch {
+                print("Error reading image from disk: \(error)")
+            }
+        }
+        
+        return nil
+    }
+    
+    func saveToDisk(_ image: UIImage, for key: String) {
+        let fileURL = diskCacheDirectory.appendingPathComponent(key.md5Hash)
+        
+        // Convert image to data (using JPEG for photos, PNG for UI elements)
+        guard let data = image.jpegData(compressionQuality: 0.8) else { return }
+        
+        do {
+            try data.write(to: fileURL)
+        } catch {
+            print("Error writing image to disk: \(error)")
+        }
+    }
+    
+    // MARK: - Combined Operations
+    
+    func getImage(for key: String) -> UIImage? {
+        // First try memory cache
+        if let cachedImage = getFromMemory(for: key) {
+            return cachedImage
+        }
+        
+        // Then try disk cache
+        return getFromDisk(for: key)
+    }
+    
+    func saveImage(_ image: UIImage, for key: String) {
+        // Save to both memory and disk
+        saveToMemory(image, for: key)
+        saveToDisk(image, for: key)
+    }
+    
+    // MARK: - Cache Management
+    
+    func clearMemoryCache() {
+        cache.removeAllObjects()
+    }
+    
+    func clearDiskCache() {
+        do {
+            let contents = try fileManager.contentsOfDirectory(at: diskCacheDirectory, includingPropertiesForKeys: nil)
+            for fileURL in contents {
+                try fileManager.removeItem(at: fileURL)
+            }
+        } catch {
+            print("Error clearing disk cache: \(error)")
+        }
+    }
+}
+
+// MARK: - Helper Extensions
+
+extension String {
+    // Convert string to MD5 hash for safer filenames
+    var md5Hash: String {
+        let data = Data(self.utf8)
+        var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))
+        
+        _ = data.withUnsafeBytes { buffer in
+            CC_MD5(buffer.baseAddress, CC_LONG(data.count), &digest)
+        }
+        
+        return digest.map { String(format: "%02x", $0) }.joined()
+    }
+}
+
+// Import CommonCrypto for MD5 hashing
+import CommonCrypto
\ No newline at end of file
diff --git a/Aldo/IndividualHoleView.swift b/Aldo/IndividualHoleView.swift
new file mode 100644
index 0000000..79c1994
--- /dev/null
+++ b/Aldo/IndividualHoleView.swift
@@ -0,0 +1,89 @@
+//  IndividualHoleView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/23/24.
+//
+
+
+import SwiftUI
+
+struct IndividualHoleView: View {
+    @Binding var score: Int
+    var holeNumber: Int
+    var totalHoles: Int
+    @ObservedObject var workoutManager: iOSWorkoutManager
+    @Environment(\.presentationMode) var presentationMode
+
+    var body: some View {
+        VStack {
+            // Workout stats at the top
+            VStack {
+                Text("Steps: \(workoutManager.steps)")
+                Text("Distance: \(String(format: "%.2f", workoutManager.distance)) miles")
+                Text("Calories: \(String(format: "%.2f", workoutManager.caloriesBurned)) kcal")
+            }
+            .padding()
+
+            // Hole details and score input
+            VStack {
+                Text("Hole \(holeNumber)")
+                    .font(.largeTitle)
+                    .fontWeight(.bold)
+                    .padding(.bottom, 20)
+
+                Stepper(value: $score, in: 0...10) {
+                    Text("Score: \(score)")
+                        .font(.title)
+                }
+                .padding()
+
+                HStack {
+                    Button(action: {
+                        if holeNumber > 1 {
+                            // Navigate to previous hole
+                            presentationMode.wrappedValue.dismiss()
+                        }
+                    }) {
+                        Text("Previous Hole")
+                            .font(.title2)
+                            .padding()
+                            .frame(maxWidth: .infinity)
+                            .background(Color.gray.opacity(0.2))
+                            .cornerRadius(10)
+                    }
+                    .disabled(holeNumber == 1)
+
+                    Button(action: {
+                        if holeNumber < totalHoles {
+                            // Navigate to next hole
+                            presentationMode.wrappedValue.dismiss()
+                        }
+                    }) {
+                        Text("Next Hole")
+                            .font(.title2)
+                            .padding()
+                            .frame(maxWidth: .infinity)
+                            .background(Color.blue)
+                            .foregroundColor(.white)
+                            .cornerRadius(10)
+                    }
+                    .disabled(holeNumber == totalHoles)
+                }
+                .padding(.top, 20)
+            }
+
+            Spacer()
+        }
+        .navigationBarBackButtonHidden(true)
+        .navigationBarItems(leading: Button(action: {
+            presentationMode.wrappedValue.dismiss()
+        }) {
+            HStack {
+                Image(systemName: "arrow.left")
+                Text("Back to Round")
+            }
+        })
+        .padding()
+        .navigationTitle("Hole \(holeNumber)")
+    }
+}
diff --git a/Aldo/Info.plist b/Aldo/Info.plist
new file mode 100644
index 0000000..d904aeb
--- /dev/null
+++ b/Aldo/Info.plist
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+    <!-- Application Info -->
+    <key>CFBundleIdentifier</key>
+    <string>Aldo.Aldo</string> <!-- Your app's bundle identifier -->
+    <key>CFBundleName</key>
+    <string>Aldo</string>
+    <key>CFBundleDisplayName</key>
+    <string>Aldo</string>
+    <key>CFBundleVersion</key>
+    <string>1.0</string> <!-- Build version -->
+    <key>CFBundleShortVersionString</key>
+    <string>1.0</string> <!-- Release version -->
+    <key>CFBundleExecutable</key>
+    <string>Aldo</string> <!-- This should match your app's executable name, usually the target name without an extension -->
+    <key>UILaunchStoryboardName</key>
+    <string>LaunchScreen</string> <!-- Your launch storyboard name -->
+    
+    <!-- HealthKit Permissions -->
+    <key>NSHealthShareUsageDescription</key>
+    <string>This app requires access to read your HealthKit data for analyzing workouts.</string>
+    <key>NSHealthUpdateUsageDescription</key>
+    <string>This app requires access to update your HealthKit data for tracking workouts.</string>
+    
+    <!-- Other Required Permissions (if any) -->
+    <!-- Add other keys as needed for your app's functionality -->
+    <key>CFBundleURLTypes</key>
+    <array>
+        <dict>
+            <key>CFBundleURLSchemes</key>
+            <array>
+                <string>app-1-836691343900-ios-4e1458e8bcab5c6f3f3dd9</string>
+            </array>
+        </dict>
+    </array>
+</dict>
+</plist>
diff --git a/Aldo/NetworkMonitor.swift b/Aldo/NetworkMonitor.swift
new file mode 100644
index 0000000..1d0223e
--- /dev/null
+++ b/Aldo/NetworkMonitor.swift
@@ -0,0 +1,75 @@
+//
+//  NetworkMonitor.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 3/4/25.
+//
+
+
+import Foundation
+import Network
+import FirebaseAuth
+
+class NetworkMonitor: ObservableObject {
+    private let networkMonitor = NWPathMonitor()
+    private let queue = DispatchQueue(label: "NetworkMonitor")
+    @Published var isConnected = true
+    @Published var connectionType: ConnectionType = .unknown
+    
+    enum ConnectionType {
+        case wifi
+        case cellular
+        case wired
+        case unknown
+    }
+    
+    init() {
+        networkMonitor.pathUpdateHandler = { [weak self] path in
+            DispatchQueue.main.async {
+                self?.isConnected = path.status == .satisfied
+                self?.determineConnectionType(path)
+                
+                // If connection is re-established, sync pending data
+                if path.status == .satisfied {
+                    self?.syncPendingData()
+                }
+            }
+        }
+        networkMonitor.start(queue: queue)
+    }
+    
+    deinit {
+        networkMonitor.cancel()
+    }
+    
+    private func determineConnectionType(_ path: NWPath) {
+        if path.usesInterfaceType(.wifi) {
+            connectionType = .wifi
+        } else if path.usesInterfaceType(.cellular) {
+            connectionType = .cellular
+        } else if path.usesInterfaceType(.wiredEthernet) {
+            connectionType = .wired
+        } else {
+            connectionType = .unknown
+        }
+    }
+    
+    private func syncPendingData() {
+        guard let userId = Auth.auth().currentUser?.uid else { return }
+        
+        // Sync pending scores
+        FirestoreManager.shared.syncPendingScores(userId: userId) { result in
+            switch result {
+            case .success(let count):
+                if count > 0 {
+                    print("Successfully synced \(count) pending scores")
+                    
+                    // Clean up old synced data
+                    FirestoreManager.shared.cleanupSyncedScores(userId: userId) { _ in }
+                }
+            case .failure(let error):
+                print("Failed to sync pending scores: \(error.localizedDescription)")
+            }
+        }
+    }
+}
diff --git a/Aldo/NotificationService.swift b/Aldo/NotificationService.swift
new file mode 100644
index 0000000..52fb631
--- /dev/null
+++ b/Aldo/NotificationService.swift
@@ -0,0 +1,59 @@
+import Firebase
+
+class NotificationService {
+    static let shared = NotificationService()
+
+    private init() {}
+
+    func sendPushNotification(to user: Models.User) {
+        // This will send a push notification to a specific user based on their FCM token
+        guard let fcmToken = user.fcmToken else {
+            print("No FCM token available for user")
+            return
+        }
+
+        let message = [
+            "to": fcmToken,
+            "notification": [
+                "title": "You've been added to the league!",
+                "body": "Join the game and track your progress."
+            ],
+            "priority": "high"
+        ] as [String : Any]
+
+        // Send the request to Firebase Cloud Messaging
+        sendFCMRequest(message)
+    }
+
+    private func sendFCMRequest(_ message: [String: Any]) {
+        let url = URL(string: "https://fcm.googleapis.com/fcm/send")!
+        var request = URLRequest(url: url)
+        request.httpMethod = "POST"
+        request.addValue("key=YOUR_FCM_SERVER_KEY", forHTTPHeaderField: "Authorization") // Replace with your server key
+        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
+        
+        do {
+            let jsonData = try JSONSerialization.data(withJSONObject: message, options: [])
+            request.httpBody = jsonData
+        } catch {
+            print("Failed to serialize FCM message: \(error.localizedDescription)")
+            return
+        }
+
+        // Perform the network request to send the notification
+        let task = URLSession.shared.dataTask(with: request) { data, response, error in
+            if let error = error {
+                print("Error sending push notification: \(error.localizedDescription)")
+                return
+            }
+
+            if let response = response as? HTTPURLResponse, response.statusCode == 200 {
+                print("Push notification sent successfully")
+            } else {
+                print("Failed to send push notification")
+            }
+        }
+
+        task.resume()
+    }
+}
diff --git a/Aldo/UserModel.swift b/Aldo/UserModel.swift
new file mode 100644
index 0000000..0b95393
--- /dev/null
+++ b/Aldo/UserModel.swift
@@ -0,0 +1,138 @@
+// UserModel.swift
+// Aldo
+//
+// Created by Andrew Katsifis on 6/12/24.
+
+import Foundation
+import FirebaseFirestore
+
+struct Models {
+    struct User: Identifiable, Codable {
+        let id: String
+        var username: String
+        var firstName: String
+        var lastName: String
+        var email: String
+        var phoneNumber: String
+        var bio: String = ""
+        var location: String = ""
+        var friends: [String]
+        var scores: [Score]
+        var steps: Int
+        var profilePicture: String?
+        var notificationsEnabled: Bool = true
+        var selectedLanguage: String = "English"
+        var fcmToken: String?
+
+        struct Score: Codable, Identifiable {
+            var id: String
+            let course: String
+            let score: Int
+            let date: Date
+            let holesPlayed: String
+            var steps: Int?
+            var distance: Double?
+            var caloriesBurned: Double?
+        }
+        
+        // Convert to dictionary for Firebase
+        func toDictionary() -> [String: Any] {
+            return [
+                "username": username,
+                "firstName": firstName,
+                "lastName": lastName,
+                "email": email,
+                "phoneNumber": phoneNumber,
+                "bio": bio,
+                "location": location,
+                "profilePicture": profilePicture ?? "",
+                "fcmToken": fcmToken ?? "",
+                "friends": friends,
+                "scores": scores.map { score in
+                    return [
+                        "id": score.id,
+                        "course": score.course,
+                        "score": score.score,
+                        "date": score.date,
+                        "holesPlayed": score.holesPlayed,
+                        "steps": score.steps ?? 0,
+                        "distance": score.distance ?? 0.0,
+                        "caloriesBurned": score.caloriesBurned ?? 0.0
+                    ]
+                },
+                "steps": steps,
+                "notificationsEnabled": notificationsEnabled,
+                "selectedLanguage": selectedLanguage
+            ]
+        }
+        
+        // Parse from dictionary from Firebase
+        static func fromDictionary(_ dict: [String: Any], id: String) -> User? {
+            guard
+                let username = dict["username"] as? String,
+                let email = dict["email"] as? String
+            else {
+                return nil
+            }
+            
+            let firstName = dict["firstName"] as? String ?? ""
+            let lastName = dict["lastName"] as? String ?? ""
+            let phoneNumber = dict["phoneNumber"] as? String ?? ""
+            let bio = dict["bio"] as? String ?? ""
+            let location = dict["location"] as? String ?? ""
+            let profilePicture = dict["profilePicture"] as? String
+            let fcmToken = dict["fcmToken"] as? String
+            let friends = dict["friends"] as? [String] ?? []
+            let notificationsEnabled = dict["notificationsEnabled"] as? Bool ?? true
+            let selectedLanguage = dict["selectedLanguage"] as? String ?? "English"
+            
+            var scores: [Score] = []
+            if let scoresArray = dict["scores"] as? [[String: Any]] {
+                scores = scoresArray.compactMap { scoreDict in
+                    guard
+                        let scoreId = scoreDict["id"] as? String,
+                        let course = scoreDict["course"] as? String,
+                        let score = scoreDict["score"] as? Int
+                    else {
+                        return nil
+                    }
+                    
+                    let date = (scoreDict["date"] as? Timestamp)?.dateValue() ?? Date()
+                    let holesPlayed = scoreDict["holesPlayed"] as? String ?? "18 Holes"
+                    let steps = scoreDict["steps"] as? Int
+                    let distance = scoreDict["distance"] as? Double
+                    let caloriesBurned = scoreDict["caloriesBurned"] as? Double
+                    
+                    return Score(id: scoreId,
+                                course: course,
+                                score: score,
+                                date: date,
+                                holesPlayed: holesPlayed,
+                                steps: steps,
+                                distance: distance,
+                                caloriesBurned: caloriesBurned)
+                }
+            }
+            
+            let steps = dict["steps"] as? Int ?? 0
+            
+            return User(
+                id: id,
+                username: username,
+                firstName: firstName,
+                lastName: lastName,
+                email: email,
+                phoneNumber: phoneNumber,
+                bio: bio,
+                location: location,
+                friends: friends,
+                scores: scores,
+                steps: steps,
+                profilePicture: profilePicture,
+                notificationsEnabled: notificationsEnabled,
+                selectedLanguage: selectedLanguage,
+                fcmToken: fcmToken
+            )
+        }
+    }
+}
diff --git a/Aldo/Views/ActivityAndTransportPromptView.swift b/Aldo/Views/ActivityAndTransportPromptView.swift
new file mode 100644
index 0000000..08b8d08
--- /dev/null
+++ b/Aldo/Views/ActivityAndTransportPromptView.swift
@@ -0,0 +1,218 @@
+import SwiftUI
+
+struct ActivityAndTransportPromptView: View {
+    @Environment(\.dismiss) var dismiss
+    
+    // State
+    @State private var isTracking: Bool = false
+    @State private var isWalking: Bool = false
+    @State private var step = 0
+    @State private var selectedCourse: GolfCourse? = nil
+    @State private var playNineHoles: Bool = false
+    @State private var showingScoreEntryView = false
+    
+    // Environment
+    @EnvironmentObject var workoutManager: iOSWorkoutManager
+    
+    var body: some View {
+        ZStack {
+            // 1) Blurred background
+            Image("Golf")
+                .resizable()
+                .scaledToFill()
+                .ignoresSafeArea()
+                .blur(radius: 0)
+            
+            VStack(spacing: 0) {
+                // 2) Custom top bar
+                HStack {
+                    Button("Back") {
+                        dismiss()
+                    }
+                    .foregroundColor(.white)
+                    
+                    Spacer()
+                    
+                    Text("Start Round")
+                        .foregroundColor(.white)
+                        .font(.headline)
+                    
+                    Spacer()
+                    
+                    // Empty spacer to balance the layout
+                    Spacer().frame(width: 0)
+                }
+                .padding()
+                .background(Color.black.opacity(0.7))
+                
+                Spacer()
+                
+                // 3) Semi-transparent card for steps
+                VStack(spacing: 20) {
+                    if step == 0 {
+                        stepZeroView
+                    } else if step == 1 {
+                        stepOneView
+                    } else if step == 2 {
+                        stepTwoView
+                    }
+                }
+                .padding()
+                .background(Color.black.opacity(0.6))
+                .cornerRadius(15)
+                .padding()
+                .foregroundColor(.white)
+                
+                Spacer()
+            }
+        }
+        // 4) Hide default nav bar entirely
+        .navigationBarHidden(true)
+        // 5) Sheet for score entry
+        .sheet(isPresented: $showingScoreEntryView) {
+            ScoreEntryView()
+        }
+    }
+    
+    // MARK: - Step 0 View
+    private var stepZeroView: some View {
+        VStack(spacing: 20) {
+            Text("Do you want to track your workout?")
+                .font(.title2)
+                .fontWeight(.bold)
+                .multilineTextAlignment(.center)
+            
+            HStack(spacing: 20) {
+                Button("Yes") {
+                    isTracking = true
+                    step = 1
+                }
+                .buttonStyle(LargePromptButtonStyle())
+                
+                Button("No") {
+                    isTracking = false
+                    step = 1
+                }
+                .buttonStyle(LargePromptButtonStyle())
+            }
+        }
+    }
+    
+    // MARK: - Step 1 View
+    private var stepOneView: some View {
+        VStack(spacing: 20) {
+            Text("Are you walking or riding?")
+                .font(.title2)
+                .fontWeight(.bold)
+                .multilineTextAlignment(.center)
+            
+            HStack(spacing: 20) {
+                Button {
+                    isWalking = true
+                    step = 2
+                } label: {
+                    VStack {
+                        Image(systemName: "figure.walk")
+                            .font(.largeTitle)
+                        Text("Walking")
+                            .font(.title3)
+                    }
+                }
+                .buttonStyle(LargePromptButtonStyle())
+                
+                Button {
+                    isWalking = false
+                    step = 2
+                } label: {
+                    VStack {
+                        Image(systemName: "car.fill")
+                            .font(.largeTitle)
+                        Text("Riding")
+                            .font(.title3)
+                    }
+                }
+                .buttonStyle(LargePromptButtonStyle())
+            }
+        }
+    }
+    
+    // MARK: - Step 2 View
+    private var stepTwoView: some View {
+        VStack(spacing: 20) {
+            Text("Select Course and Holes")
+                .font(.title2)
+                .fontWeight(.bold)
+                .multilineTextAlignment(.center)
+            
+            // Course selection
+            if selectedCourse == nil {
+                NavigationLink(destination: CourseSearchView(selectedCourse: $selectedCourse)) {
+                    Text("Select Course")
+                        .font(.title3)
+                }
+                .buttonStyle(LargePromptButtonStyle())
+            } else {
+                Text("Selected Course: \(selectedCourse?.name ?? "")")
+                    .font(.title3)
+            }
+            
+            // 9 or 18 holes
+            VStack(spacing: 10) {
+                Toggle("Play 9 Holes", isOn: $playNineHoles)
+                    .toggleStyle(SwitchToggleStyle(tint: .green))
+                    .font(.title3)
+                
+                if playNineHoles {
+                    Text("Playing 9 Holes")
+                } else {
+                    Text("Playing 18 Holes")
+                }
+            }
+            
+            // "Let's Go" button
+            Button {
+                if isTracking {
+                    workoutManager.startWorkoutOnWatch()
+                }
+                showingScoreEntryView = true
+            } label: {
+                Text("Let's Go")
+                    .font(.title3)
+            }
+            .buttonStyle(LetsGoButtonStyle())
+        }
+    }
+}
+
+// MARK: - Custom Button Styles
+
+/// LargePromptButtonStyle makes buttons roughly twice as large as the previous small style.
+struct LargePromptButtonStyle: ButtonStyle {
+    func makeBody(configuration: Configuration) -> some View {
+        configuration.label
+            .font(.title3) // Larger font than .headline
+            .padding(.vertical, 16)  // Double the vertical padding
+            .padding(.horizontal, 32)  // Double the horizontal padding
+            .background(Color.black.opacity(configuration.isPressed ? 0.8 : 1))
+            .foregroundColor(.white)
+            .cornerRadius(10)
+    }
+}
+
+struct LetsGoButtonStyle: ButtonStyle {
+    func makeBody(configuration: Configuration) -> some View {
+        configuration.label
+            .frame(maxWidth: .infinity)
+            .padding()
+            .background(Color.green.opacity(configuration.isPressed ? 0.8 : 1))
+            .foregroundColor(.white)
+            .cornerRadius(10)
+    }
+}
+
+struct ActivityAndTransportPromptView_Previews: PreviewProvider {
+    static var previews: some View {
+        ActivityAndTransportPromptView()
+            .environmentObject(iOSWorkoutManager())
+    }
+}
diff --git a/Aldo/Views/ActivityView.swift b/Aldo/Views/ActivityView.swift
new file mode 100644
index 0000000..150603c
--- /dev/null
+++ b/Aldo/Views/ActivityView.swift
@@ -0,0 +1,156 @@
+//
+//  ActivityView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+import SwiftUI
+
+
+import FirebaseFirestore
+import FirebaseFirestoreSwift
+
+struct ActivityView: View {
+    @State private var user: User? // Current user's data
+    @State private var friends: [Friend] = []
+    @State private var showingAddScoreSheet = false
+    
+    var body: some View {
+        NavigationView {
+            VStack {
+                if let user = user {
+                    List {
+                        // User's Activity Section
+                        Section(header: Text("Your Activity")) {
+                            ForEach(user.scores, id: \.course) { score in
+                                HStack(alignment: .top) {
+                                    // Display user's profile picture if available
+                                    if let profilePicture = user.profilePicture, let url = URL(string: profilePicture) {
+                                        AsyncImage(url: url) { image in
+                                            image.resizable()
+                                                .aspectRatio(contentMode: .fit)
+                                                .frame(width: 50, height: 50)
+                                                .clipShape(Circle())
+                                        } placeholder: {
+                                            ProgressView()
+                                        }
+                                    }
+                                    VStack(alignment: .leading) {
+                                        Text("\(user.firstName) \(user.lastName) (\(user.username))")
+                                            .font(.headline)
+                                        Text("Course: \(score.course)")
+                                        Text("Score: \(score.score)")
+                                        // For simplicity, we use the current date as a placeholder.
+                                        Text("Date: \(formatDate(Date()))")
+                                        Text("Holes: 18")
+                                    }
+                                }
+                                .padding(.vertical, 5)
+                            }
+                        }
+                        
+                        // Friends' Activity Section
+                        Section(header: Text("Friends' Activity")) {
+                            ForEach(friends) { friend in
+                                VStack(alignment: .leading) {
+                                    HStack {
+                                        if let profileImageURL = friend.profileImageURL {
+                                            AsyncImage(url: profileImageURL) { image in
+                                                image.resizable()
+                                                    .aspectRatio(contentMode: .fit)
+                                                    .frame(width: 50, height: 50)
+                                                    .clipShape(Circle())
+                                            } placeholder: {
+                                                ProgressView()
+                                            }
+                                        }
+                                        Text(friend.username)
+                                            .font(.headline)
+                                    }
+                                    ForEach(friend.rounds) { round in
+                                        VStack(alignment: .leading) {
+                                            Text("Course: \(round.course)")
+                                            Text("Score: \(round.scores.map(String.init).joined(separator: ", "))")
+                                            Text("Date: \(formatDate(round.date))")
+                                            Text("Holes: \(round.scores.count)")
+                                        }
+                                        .padding(.vertical, 5)
+                                    }
+                                }
+                                .padding(.bottom, 10)
+                            }
+                        }
+                    }
+                    .listStyle(InsetGroupedListStyle())
+                } else {
+                    // If user data isn't loaded yet, show a progress indicator.
+                    ProgressView()
+                }
+                
+                // Add Score Button at the bottom
+                Button("Add Score") {
+                    showingAddScoreSheet = true
+                }
+                .font(.title2)
+                .padding()
+                .frame(maxWidth: .infinity)
+                .background(Color.blue)
+                .foregroundColor(.white)
+                .cornerRadius(10)
+                .shadow(radius: 5)
+                .padding()
+            }
+            .navigationTitle("Activity")
+            .onAppear(perform: fetchActivityData)
+            .sheet(isPresented: $showingAddScoreSheet) {
+                // Present AddScoreView only if user data is available.
+                if let user = user {
+                    AddScoreView(currentUserId: user.id)
+                } else {
+                    Text("Loading...")
+                }
+            }
+        }
+    }
+    
+    private func fetchActivityData() {
+        let db = Firestore.firestore()
+        
+        // Fetch current user's data.
+        db.collection("users").document("CURRENT_USER_ID") // Replace with your dynamic user ID.
+            .getDocument { snapshot, error in
+                if let error = error {
+                    print("Error fetching user: \(error.localizedDescription)")
+                    return
+                }
+                if let snapshot = snapshot {
+                    self.user = try? snapshot.data(as: User.self)
+                }
+            }
+        
+        // Fetch friends' data.
+        db.collection("friends").getDocuments { snapshot, error in
+            if let error = error {
+                print("Error fetching friends: \(error.localizedDescription)")
+                return
+            }
+            if let documents = snapshot?.documents {
+                self.friends = documents.compactMap { doc in
+                    try? doc.data(as: Friend.self)
+                }
+            }
+        }
+    }
+    
+    private func formatDate(_ date: Date) -> String {
+        let formatter = DateFormatter()
+        formatter.dateStyle = .medium
+        return formatter.string(from: date)
+    }
+}
+
+struct ActivityView_Previews: PreviewProvider {
+    static var previews: some View {
+        ActivityView()
+    }
+}
diff --git a/Aldo/Views/AddMembersView.swift b/Aldo/Views/AddMembersView.swift
new file mode 100644
index 0000000..5b30ffb
--- /dev/null
+++ b/Aldo/Views/AddMembersView.swift
@@ -0,0 +1,139 @@
+//
+//  AddMembersView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/25/24.
+//
+
+import SwiftUI
+import FirebaseFirestore
+
+struct AddMembersView: View {
+    @State private var searchText = ""
+    @State private var foundUsers: [Models.User] = []
+    @State private var isSearching = false
+    @State private var showAlert = false
+    @State private var alertMessage = ""
+    
+    var body: some View {
+        VStack {
+            // Search bar
+            HStack {
+                Image(systemName: "magnifyingglass")
+                    .foregroundColor(.gray)
+                
+                TextField("Search by username or phone number", text: $searchText)
+                    .onChange(of: searchText) { newValue in
+                        if !newValue.isEmpty && newValue.count >= 3 {
+                            searchUsers(query: newValue)
+                        } else {
+                            foundUsers = []
+                        }
+                    }
+                
+                if !searchText.isEmpty {
+                    Button(action: {
+                        searchText = ""
+                        foundUsers = []
+                    }) {
+                        Image(systemName: "xmark.circle.fill")
+                            .foregroundColor(.gray)
+                    }
+                }
+            }
+            .padding()
+            .background(Color(.systemGray6))
+            .cornerRadius(10)
+            .padding()
+            
+            if isSearching {
+                ProgressView("Searching...")
+            } else if foundUsers.isEmpty && !searchText.isEmpty && searchText.count >= 3 {
+                Text("No users found")
+                    .foregroundColor(.gray)
+                    .padding()
+            } else {
+                // List of users
+                List(foundUsers) { user in
+                    HStack {
+                        if let profilePicture = user.profilePicture, let url = URL(string: profilePicture) {
+                            AsyncImage(url: url) { image in
+                                image
+                                    .resizable()
+                                    .scaledToFill()
+                                    .frame(width: 50, height: 50)
+                                    .clipShape(Circle())
+                            } placeholder: {
+                                Image(systemName: "person.circle.fill")
+                                    .resizable()
+                                    .scaledToFit()
+                                    .frame(width: 50, height: 50)
+                                    .foregroundColor(.gray)
+                            }
+                        } else {
+                            Image(systemName: "person.circle.fill")
+                                .resizable()
+                                .scaledToFit()
+                                .frame(width: 50, height: 50)
+                                .foregroundColor(.gray)
+                        }
+                        
+                        VStack(alignment: .leading) {
+                            Text(user.username)
+                                .font(.headline)
+                            Text(user.phoneNumber)
+                                .font(.subheadline)
+                                .foregroundColor(.gray)
+                        }
+                        
+                        Spacer()
+                        
+                        Button(action: {
+                            addUserToGroup(user)
+                        }) {
+                            Image(systemName: "person.badge.plus")
+                                .foregroundColor(.blue)
+                                .padding()
+                        }
+                    }
+                    .padding(.vertical, 4)
+                }
+            }
+            
+            Spacer()
+        }
+        .navigationTitle("Add Members")
+        .alert(isPresented: $showAlert) {
+            Alert(title: Text("Add Member"), message: Text(alertMessage), dismissButton: .default(Text("OK")))
+        }
+    }
+    
+    private func searchUsers(query: String) {
+        isSearching = true
+        
+        UserService.shared.searchUsers(query: query) { result in
+            isSearching = false
+            
+            switch result {
+            case .success(let users):
+                self.foundUsers = users
+            case .failure(let error):
+                print("Error searching users: \(error.localizedDescription)")
+                self.alertMessage = "Failed to search users: \(error.localizedDescription)"
+                self.showAlert = true
+            }
+        }
+    }
+    
+    private func addUserToGroup(_ user: Models.User) {
+        // Implementation for adding user to group
+        alertMessage = "Added \(user.username) to the group!"
+        showAlert = true
+    }
+}
+
+struct AddMembersView_Previews: PreviewProvider {
+    static var previews: some View {
+        AddMembersView()
+    }
+}
diff --git a/Aldo/Views/AddScoreView.swift b/Aldo/Views/AddScoreView.swift
new file mode 100644
index 0000000..5a59dea
--- /dev/null
+++ b/Aldo/Views/AddScoreView.swift
@@ -0,0 +1,83 @@
+//
+//  AddScoreView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 2/16/25.
+//
+
+
+import SwiftUI
+import FirebaseFirestore
+
+struct AddScoreView: View {
+    @Environment(\.dismiss) var dismiss
+    @State private var roundNumber: String = ""
+    @State private var score: String = ""
+    @State private var alertMessage = ""
+    @State private var showAlert = false
+    
+    // Pass the current user ID so the new round is associated with that user.
+    var currentUserId: String
+
+    var body: some View {
+        NavigationView {
+            Form {
+                Section(header: Text("Add Previous Round Score")) {
+                    TextField("Round Number", text: $roundNumber)
+                        .keyboardType(.numberPad)
+                    TextField("Score", text: $score)
+                        .keyboardType(.numberPad)
+                }
+                
+                Button("Submit") {
+                    addScore()
+                }
+            }
+            .navigationTitle("Add Score")
+            .toolbar {
+                ToolbarItem(placement: .navigationBarLeading) {
+                    Button("Cancel") {
+                        dismiss()
+                    }
+                }
+            }
+            .alert(isPresented: $showAlert) {
+                Alert(title: Text("Error"),
+                      message: Text(alertMessage),
+                      dismissButton: .default(Text("OK")))
+            }
+        }
+    }
+    
+    private func addScore() {
+        guard let roundNumberInt = Int(roundNumber),
+              let scoreInt = Int(score) else {
+            alertMessage = "Please enter valid numbers."
+            showAlert = true
+            return
+        }
+        
+        let db = Firestore.firestore()
+        let newRoundData: [String: Any] = [
+            "userId": currentUserId,
+            "number": roundNumberInt,
+            "score": scoreInt,
+            "createdAt": Timestamp(date: Date())
+        ]
+        
+        db.collection("rounds").addDocument(data: newRoundData) { error in
+            if let error = error {
+                alertMessage = error.localizedDescription
+                showAlert = true
+            } else {
+                dismiss()
+            }
+        }
+    }
+}
+
+struct AddScoreView_Previews: PreviewProvider {
+    static var previews: some View {
+        AddScoreView(currentUserId: "testUser")
+    }
+}
\ No newline at end of file
diff --git a/Aldo/Views/AddUsersView.swift b/Aldo/Views/AddUsersView.swift
new file mode 100644
index 0000000..891f9c6
--- /dev/null
+++ b/Aldo/Views/AddUsersView.swift
@@ -0,0 +1,155 @@
+//
+//  AddUsersView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/25/24.
+//
+
+import SwiftUI
+import FirebaseFirestore
+
+struct AddUsersView: View {
+    @Binding var selectedUsers: [Models.User]
+    @State private var searchText = ""
+    @State private var foundUsers: [Models.User] = []
+    @State private var isSearching = false
+    @State private var showAlert = false
+    @State private var alertMessage = ""
+    
+    // Init with optional binding for compatibility with existing code
+    init(selectedUsers: Binding<[Models.User]>? = nil) {
+        self._selectedUsers = selectedUsers ?? .constant([])
+    }
+    
+    var body: some View {
+        VStack {
+            // Search bar
+            HStack {
+                Image(systemName: "magnifyingglass")
+                    .foregroundColor(.gray)
+                
+                TextField("Search by username or phone number", text: $searchText)
+                    .onChange(of: searchText) { newValue in
+                        if !newValue.isEmpty && newValue.count >= 3 {
+                            searchUsers(query: newValue)
+                        } else {
+                            foundUsers = []
+                        }
+                    }
+                
+                if !searchText.isEmpty {
+                    Button {
+                        searchText = ""
+                        foundUsers = []
+                    } label: {
+                        Image(systemName: "xmark.circle.fill")
+                            .foregroundColor(.gray)
+                    }
+                }
+            }
+            .padding()
+            .background(Color(.systemGray6))
+            .cornerRadius(10)
+            .padding()
+            
+            if isSearching {
+                ProgressView("Searching...")
+            } else if foundUsers.isEmpty && !searchText.isEmpty && searchText.count >= 3 {
+                Text("No users found")
+                    .foregroundColor(.gray)
+                    .padding()
+            } else {
+                // List of users
+                List {
+                    ForEach(foundUsers) { user in
+                        HStack {
+                            if let profilePicture = user.profilePicture, let url = URL(string: profilePicture) {
+                                AsyncImage(url: url) { image in
+                                    image
+                                        .resizable()
+                                        .scaledToFill()
+                                        .frame(width: 50, height: 50)
+                                        .clipShape(Circle())
+                                } placeholder: {
+                                    Image(systemName: "person.circle.fill")
+                                        .resizable()
+                                        .scaledToFit()
+                                        .frame(width: 50, height: 50)
+                                        .foregroundColor(.gray)
+                                }
+                            } else {
+                                Image(systemName: "person.circle.fill")
+                                    .resizable()
+                                    .scaledToFit()
+                                    .frame(width: 50, height: 50)
+                                    .foregroundColor(.gray)
+                            }
+                            
+                            VStack(alignment: .leading) {
+                                Text(user.username)
+                                    .font(.headline)
+                                Text(user.phoneNumber)
+                                    .font(.subheadline)
+                                    .foregroundColor(.gray)
+                            }
+                            
+                            Spacer()
+                            
+                            Button {
+                                toggleUserSelection(user)
+                            } label: {
+                                Image(systemName: isUserSelected(user) ? "checkmark.circle.fill" : "plus.circle")
+                                    .foregroundColor(isUserSelected(user) ? .green : .blue)
+                                    .font(.title2)
+                            }
+                        }
+                        .padding(.vertical, 4)
+                    }
+                }
+            }
+            
+            Spacer()
+        }
+        .navigationTitle("Add Users")
+        .alert(isPresented: $showAlert) {
+            Alert(title: Text("User Selection"), message: Text(alertMessage), dismissButton: .default(Text("OK")))
+        }
+    }
+    
+    private func searchUsers(query: String) {
+        isSearching = true
+        
+        UserService.shared.searchUsers(query: query) { result in
+            isSearching = false
+            
+            switch result {
+            case .success(let users):
+                self.foundUsers = users
+            case .failure(let error):
+                print("Error searching users: \(error.localizedDescription)")
+                self.alertMessage = "Failed to search users: \(error.localizedDescription)"
+                self.showAlert = true
+            }
+        }
+    }
+    
+    private func toggleUserSelection(_ user: Models.User) {
+        if isUserSelected(user) {
+            // Remove user if already selected
+            selectedUsers.removeAll { $0.id == user.id }
+        } else {
+            // Add user if not selected
+            selectedUsers.append(user)
+        }
+    }
+    
+    private func isUserSelected(_ user: Models.User) -> Bool {
+        return selectedUsers.contains { $0.id == user.id }
+    }
+}
+
+struct AddUsersView_Previews: PreviewProvider {
+    static var previews: some View {
+        AddUsersView()
+    }
+}
diff --git a/Aldo/Views/ContentView.swift b/Aldo/Views/ContentView.swift
new file mode 100644
index 0000000..f81b4ce
--- /dev/null
+++ b/Aldo/Views/ContentView.swift
@@ -0,0 +1,37 @@
+//
+//  ContentView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+import SwiftUI
+
+struct ContentView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @EnvironmentObject var workoutManager: iOSWorkoutManager
+    @EnvironmentObject var networkMonitor: NetworkMonitor
+    
+    var body: some View {
+        Group {
+            if authManager.isAuthenticated {
+                MainView()
+                    .environmentObject(workoutManager)
+                    .environmentObject(networkMonitor)
+            } else {
+                WelcomeView()
+            }
+        }
+        .onAppear {
+            authManager.checkLoginStatus()
+        }
+    }
+}
+
+struct ContentView_Previews: PreviewProvider {
+    static var previews: some View {
+        ContentView()
+            .environmentObject(AuthenticationManager())
+            .environmentObject(iOSWorkoutManager())
+            .environmentObject(NetworkMonitor())
+    }
+}
diff --git a/Aldo/Views/CourseSearchView.swift b/Aldo/Views/CourseSearchView.swift
new file mode 100644
index 0000000..8322330
--- /dev/null
+++ b/Aldo/Views/CourseSearchView.swift
@@ -0,0 +1,53 @@
+//
+//  CourseSearchview.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 1/26/25.
+//
+import SwiftUI
+
+struct CourseSearchView: View {
+    @Binding var selectedCourse: GolfCourse?
+
+    let courses = [
+        GolfCourse(id: 1, name: "Armitage Golf Club", par: 70),
+        GolfCourse(id: 2, name: "Rich Valley Golf", par: 72), // Par value not specified in available sources
+        GolfCourse(id: 3, name: "Dauphin Highlands Golf Course", par: 72),
+        GolfCourse(id: 4, name: "Cumberland Golf Club", par: 72), // Par value not specified in available sources
+        GolfCourse(id: 5, name: "Mayapple Golf Club", par: 72), // Par value not specified in available sources
+        GolfCourse(id: 6, name: "Carlisle Country Club", par: 72), // Par value not specified in available sources
+        GolfCourse(id: 7, name: "West Shore Country Club", par: 72), // Par value not specified in available sources
+        GolfCourse(id: 8, name: "Walnut Lane Golf Club", par: 62), // Par value not specified in available sources
+        GolfCourse(id: 9, name: "RiverWinds Golf & Tennis Club", par: 72), // Par value not specified in available sources
+        GolfCourse(id: 10, name: "Reading Country Club", par: 71) // Par value not specified in available sources
+    ]
+
+    var body: some View {
+        List(courses) { course in
+            Button(action: {
+                selectedCourse = course
+            }) {
+                HStack {
+                    VStack(alignment: .leading) {
+                        Text(course.name)
+                            .font(.title2)
+                            .bold()
+                        Text("Par \(course.par)")
+                            .font(.subheadline)
+                            .foregroundColor(.gray)
+                    }
+                    Spacer()
+                }
+                .padding()
+            }
+        }
+        .navigationTitle("Select a Course")
+    }
+}
+
+struct CourseSearchView_Previews: PreviewProvider {
+    @State static var previewSelectedCourse: GolfCourse? = nil
+    static var previews: some View {
+        CourseSearchView(selectedCourse: $previewSelectedCourse)
+    }
+}
diff --git a/Aldo/Views/CreateLeagueView.swift b/Aldo/Views/CreateLeagueView.swift
new file mode 100644
index 0000000..0d38c87
--- /dev/null
+++ b/Aldo/Views/CreateLeagueView.swift
@@ -0,0 +1,289 @@
+import SwiftUI
+import FirebaseFirestore
+import Firebase
+
+struct CreateLeagueView: View {
+    @State private var leagueName = ""
+    @State private var searchQuery = ""
+    @State private var selectedUsers: [Models.User] = []
+    @State private var searchResults: [Models.User] = []
+    @State private var isSearching = false
+    @State private var showAlert = false
+    @State private var alertMessage = ""
+    @State private var showAddMembers = false
+    
+    var body: some View {
+        VStack {
+            // League name input
+            TextField("League Name", text: $leagueName)
+                .padding()
+                .background(Color(.systemGray6))
+                .cornerRadius(10)
+                .padding(.horizontal)
+            
+            // Selected members section
+            VStack(alignment: .leading) {
+                Text("Selected Members")
+                    .font(.headline)
+                    .padding(.horizontal)
+                
+                if selectedUsers.isEmpty {
+                    Text("No members selected")
+                        .foregroundColor(.gray)
+                        .padding(.horizontal)
+                } else {
+                    ScrollView(.horizontal, showsIndicators: false) {
+                        HStack {
+                            ForEach(selectedUsers) { user in
+                                VStack {
+                                    if let profilePicture = user.profilePicture, let url = URL(string: profilePicture) {
+                                        AsyncImage(url: url) { image in
+                                            image
+                                                .resizable()
+                                                .scaledToFill()
+                                                .frame(width: 60, height: 60)
+                                                .clipShape(Circle())
+                                        } placeholder: {
+                                            Circle()
+                                                .fill(Color.gray)
+                                                .frame(width: 60, height: 60)
+                                        }
+                                    } else {
+                                        Image(systemName: "person.circle.fill")
+                                            .resizable()
+                                            .scaledToFit()
+                                            .frame(width: 60, height: 60)
+                                            .foregroundColor(.gray)
+                                    }
+                                    
+                                    Text(user.username)
+                                        .font(.caption)
+                                        .lineLimit(1)
+                                }
+                                .frame(width: 70)
+                                .onTapGesture {
+                                    if let index = selectedUsers.firstIndex(where: { $0.id == user.id }) {
+                                        selectedUsers.remove(at: index)
+                                    }
+                                }
+                            }
+                        }
+                        .padding(.horizontal)
+                    }
+                }
+            }
+            .padding(.vertical)
+            
+            // Add members button
+            Button(action: {
+                showAddMembers = true
+            }) {
+                HStack {
+                    Image(systemName: "person.badge.plus")
+                    Text("Add Members")
+                }
+                .padding()
+                .background(Color.blue)
+                .foregroundColor(.white)
+                .cornerRadius(10)
+            }
+            .padding()
+            
+            Spacer()
+            
+            // Create league button
+            Button(action: {
+                createLeague()
+            }) {
+                Text("Create League")
+                    .fontWeight(.bold)
+                    .padding()
+                    .frame(maxWidth: .infinity)
+                    .background(leagueName.isEmpty ? Color.gray : Color.green)
+                    .foregroundColor(.white)
+                    .cornerRadius(10)
+                    .padding(.horizontal)
+            }
+            .disabled(leagueName.isEmpty)
+            .padding(.bottom)
+        }
+        .navigationTitle("Create League")
+        .sheet(isPresented: $showAddMembers) {
+            NavigationView {
+                LeagueMembersView(selectedUsers: $selectedUsers)
+                    .navigationTitle("Add Members")
+                    .toolbar {
+                        ToolbarItem(placement: .navigationBarLeading) {
+                            Button("Done") {
+                                showAddMembers = false
+                            }
+                        }
+                    }
+            }
+        }
+        .alert(isPresented: $showAlert) {
+            Alert(title: Text("League Creation"), message: Text(alertMessage), dismissButton: .default(Text("OK")))
+        }
+    }
+    
+    private func createLeague() {
+        guard !leagueName.isEmpty else { return }
+        guard let currentUser = Auth.auth().currentUser?.uid else {
+            alertMessage = "You must be signed in to create a league"
+            showAlert = true
+            return
+        }
+        
+        // Get user IDs of selected members
+        let memberIds = selectedUsers.map { $0.id }
+        
+        // Create league data
+        let leagueData: [String: Any] = [
+            "name": leagueName,
+            "hostUserId": currentUser,
+            "memberIds": memberIds,
+            "createdAt": Timestamp(date: Date())
+        ]
+        
+        // Save to Firestore
+        let db = Firestore.firestore()
+        db.collection("leagues").addDocument(data: leagueData) { error in
+            if let error = error {
+                alertMessage = "Failed to create league: \(error.localizedDescription)"
+                showAlert = true
+            } else {
+                alertMessage = "League created successfully!"
+                showAlert = true
+                leagueName = ""
+                selectedUsers = []
+            }
+        }
+    }
+}
+
+struct LeagueMembersView: View {
+    @Binding var selectedUsers: [Models.User]
+    @State private var searchText = ""
+    @State private var searchResults: [Models.User] = []
+    @State private var isSearching = false
+    
+    var body: some View {
+        VStack {
+            // Search bar
+            HStack {
+                Image(systemName: "magnifyingglass")
+                    .foregroundColor(.gray)
+                
+                TextField("Search by username or phone number", text: $searchText)
+                    .onChange(of: searchText) { newValue in
+                        if !newValue.isEmpty && newValue.count >= 3 {
+                            searchUsers(query: newValue)
+                        } else {
+                            searchResults = []
+                        }
+                    }
+                
+                if !searchText.isEmpty {
+                    Button(action: {
+                        searchText = ""
+                        searchResults = []
+                    }) {
+                        Image(systemName: "xmark.circle.fill")
+                            .foregroundColor(.gray)
+                    }
+                }
+            }
+            .padding()
+            .background(Color(.systemGray6))
+            .cornerRadius(10)
+            .padding()
+            
+            if isSearching {
+                ProgressView("Searching...")
+            } else if searchResults.isEmpty && !searchText.isEmpty && searchText.count >= 3 {
+                Text("No users found")
+                    .foregroundColor(.gray)
+                    .padding()
+            } else {
+                List {
+                    ForEach(searchResults) { user in
+                        HStack {
+                            if let profilePicture = user.profilePicture, let url = URL(string: profilePicture) {
+                                AsyncImage(url: url) { image in
+                                    image
+                                        .resizable()
+                                        .scaledToFill()
+                                        .frame(width: 50, height: 50)
+                                        .clipShape(Circle())
+                                } placeholder: {
+                                    Circle()
+                                        .fill(Color.gray)
+                                        .frame(width: 50, height: 50)
+                                }
+                            } else {
+                                Image(systemName: "person.circle.fill")
+                                    .resizable()
+                                    .scaledToFit()
+                                    .frame(width: 50, height: 50)
+                                    .foregroundColor(.gray)
+                            }
+                            
+                            VStack(alignment: .leading) {
+                                Text(user.username)
+                                    .font(.headline)
+                                Text(user.phoneNumber)
+                                    .font(.subheadline)
+                                    .foregroundColor(.gray)
+                            }
+                            
+                            Spacer()
+                            
+                            Button(action: {
+                                addUser(user)
+                            }) {
+                                Image(systemName: isUserSelected(user) ? "checkmark.circle.fill" : "plus.circle")
+                                    .foregroundColor(isUserSelected(user) ? .green : .blue)
+                                    .font(.title2)
+                            }
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    private func searchUsers(query: String) {
+        isSearching = true
+        
+        UserService.shared.searchUsers(query: query) { result in
+            isSearching = false
+            
+            switch result {
+            case .success(let users):
+                self.searchResults = users
+            case .failure(let error):
+                print("Error searching users: \(error.localizedDescription)")
+            }
+        }
+    }
+    
+    private func addUser(_ user: Models.User) {
+        if let index = selectedUsers.firstIndex(where: { $0.id == user.id }) {
+            selectedUsers.remove(at: index)
+        } else {
+            selectedUsers.append(user)
+        }
+    }
+    
+    private func isUserSelected(_ user: Models.User) -> Bool {
+        return selectedUsers.contains(where: { $0.id == user.id })
+    }
+}
+
+struct CreateLeagueView_Previews: PreviewProvider {
+    static var previews: some View {
+        NavigationView {
+            CreateLeagueView()
+        }
+    }
+}
diff --git a/Aldo/Views/EnhancedPlayNowView.swift b/Aldo/Views/EnhancedPlayNowView.swift
new file mode 100644
index 0000000..aae64c8
--- /dev/null
+++ b/Aldo/Views/EnhancedPlayNowView.swift
@@ -0,0 +1,902 @@
+import SwiftUI
+import HealthKit
+import Firebase
+
+struct EnhancedPlayNowView: View {
+    // MARK: - State
+    @State private var golfCourse = ""
+    @State private var holeCount = 18
+    @State private var nineHoleSection = "front" // New state for front/back 9 selection
+    @State private var transportMode = TransportMode.walking
+    @State private var isTracking = false
+    @State private var currentHole = 1
+    @State private var scores: [Int] = Array(repeating: 0, count: 18)
+    @State private var notes: [String] = Array(repeating: "", count: 18)
+    @State private var showConfirmation = false
+    @State private var showSummary = false
+    @State private var roundCompleted = false
+    @State private var showLeagueSubmission = false
+    @State private var selectedLeague: String = ""
+    
+    // MARK: - Health Data
+    @State private var startTime: Date?
+    @State private var stepCount = 0
+    @State private var distance = 0.0
+    @State private var calories = 0.0
+    
+    // MARK: - Environment Objects
+    @EnvironmentObject var workoutManager: iOSWorkoutManager
+    @EnvironmentObject var networkMonitor: NetworkMonitor
+    
+    // MARK: - Health Store
+    private let healthStore = HKHealthStore()
+    
+    // MARK: - List of courses
+    let courses = ["Armitage Golf Club", "Rich Valley Golf", "Range End",
+                  "Cumberland Golf Club", "Mayapple Golf Club", "Dauphin Highlands"]
+    
+    enum TransportMode: String, CaseIterable, Identifiable {
+        case walking = "Walking"
+        case cart = "Riding"
+        
+        var id: String { self.rawValue }
+        
+        var icon: String {
+            switch self {
+            case .walking: return "figure.walk"
+            case .cart: return "car.fill"
+            }
+        }
+    }
+    
+    var body: some View {
+        GeometryReader { geometry in
+            ZStack {
+                Image("Golf")
+                    .resizable()
+                    .aspectRatio(contentMode: .fill)
+                    .position(x: UIScreen.main.bounds.width/2, y: UIScreen.main.bounds.height/2) // Center position
+                    .overlay(
+                        LinearGradient(
+                            gradient: Gradient(colors: [Color.black.opacity(0.7), Color.black.opacity(0.4)]),
+                            startPoint: .bottom,
+                            endPoint: .top
+                        )
+                    )
+                    .ignoresSafeArea()
+                
+                if !roundCompleted {
+                    if !isTracking {
+                        // Initial setup screen
+                        setupView(screenWidth: geometry.size.width)
+                    } else {
+                        // Active round screen
+                        activeRoundView(screenWidth: geometry.size.width)
+                    }
+                } else {
+                    // Round summary screen
+                    roundSummaryView(screenWidth: geometry.size.width)
+                }
+            }
+            .alert(isPresented: $showConfirmation) {
+                Alert(
+                    title: Text("Finish Round"),
+                    message: Text("Are you sure you want to finish this round?"),
+                    primaryButton: .destructive(Text("Finish")) {
+                        finishRound()
+                    },
+                    secondaryButton: .cancel()
+                )
+            }
+            .onAppear {
+                requestHealthKitPermissions()
+            }
+        }
+        .sheet(isPresented: $showLeagueSubmission) {
+            LeagueSubmissionView(
+                score: calculateTotalScore(),
+                course: golfCourse,
+                holeCount: holeCount,
+                steps: stepCount,
+                distance: distance,
+                calories: calories,
+                onSubmit: { leagueId in
+                    submitScoreToLeague(leagueId: leagueId)
+                    showLeagueSubmission = false
+                }
+            )
+        }
+    }
+    
+    // MARK: - Setup View
+    func setupView(screenWidth: CGFloat) -> some View {
+        ScrollView {
+            VStack(spacing: 25) {
+                Text("New Round")
+                    .font(.system(size: 36, weight: .bold))
+                    .foregroundColor(.white)
+                    .padding(.top, 20)
+                    .frame(maxWidth: .infinity, alignment: .center)
+                
+                Spacer().frame(height: 20)
+                
+                // Course Selection
+                VStack(alignment: .leading, spacing: 10) {
+                    Text("SELECT COURSE")
+                        .font(.caption)
+                        .foregroundColor(.white.opacity(0.7))
+                    
+                    Picker("Course", selection: $golfCourse) {
+                        Text("Select a course").tag("")
+                        ForEach(courses, id: \.self) { course in
+                            Text(course).tag(course)
+                        }
+                    }
+                    .pickerStyle(MenuPickerStyle())
+                    .padding()
+                    .background(Color.white)
+                    .cornerRadius(12)
+                }
+                .frame(width: screenWidth * 0.9)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Hole Count
+                VStack(alignment: .leading, spacing: 10) {
+                    Text("NUMBER OF HOLES")
+                        .font(.caption)
+                        .foregroundColor(.white.opacity(0.7))
+                    
+                    Picker("Holes", selection: $holeCount) {
+                        Text("9 Holes").tag(9)
+                        Text("18 Holes").tag(18)
+                    }
+                    .pickerStyle(SegmentedPickerStyle())
+                    .padding()
+                    .background(Color.white)
+                    .cornerRadius(12)
+                }
+                .frame(width: screenWidth * 0.9)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Nine Hole Section (Front/Back) - Only show when 9 holes is selected
+                if holeCount == 9 {
+                    VStack(alignment: .leading, spacing: 10) {
+                        Text("WHICH NINE?")
+                            .font(.caption)
+                            .foregroundColor(.white.opacity(0.7))
+                        
+                        Picker("Nine", selection: $nineHoleSection) {
+                            Text("Front 9").tag("front")
+                            Text("Back 9").tag("back")
+                        }
+                        .pickerStyle(SegmentedPickerStyle())
+                        .padding()
+                        .background(Color.white)
+                        .cornerRadius(12)
+                    }
+                    .frame(width: screenWidth * 0.9)
+                    .frame(maxWidth: .infinity, alignment: .center)
+                    .transition(.opacity)
+                    .animation(.easeInOut, value: holeCount)
+                }
+                
+                // Transport Mode
+                VStack(alignment: .leading, spacing: 10) {
+                    Text("HOW ARE YOU PLAYING?")
+                        .font(.caption)
+                        .foregroundColor(.white.opacity(0.7))
+                    
+                    VStack(spacing: 12) {
+                        ForEach(TransportMode.allCases) { mode in
+                            TransportButton(
+                                mode: mode,
+                                isSelected: transportMode == mode,
+                                action: { transportMode = mode },
+                                screenWidth: screenWidth * 0.9
+                            )
+                        }
+                    }
+                }
+                .frame(width: screenWidth * 0.9)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                Spacer().frame(height: 20)
+                
+                // Start Button
+                Button(action: {
+                    print("Start button tapped")
+                    startRound()
+                }) {
+                    Text("Start Round")
+                        .font(.title2)
+                        .fontWeight(.bold)
+                        .foregroundColor(.white)
+                        .frame(width: screenWidth * 0.9)
+                        .padding(.vertical, 16)
+                        .background(golfCourse.isEmpty ? Color.gray : Color.green)
+                        .cornerRadius(15)
+                        .shadow(radius: 5)
+                }
+                .disabled(golfCourse.isEmpty)
+                .padding(.bottom, 30)
+                .frame(maxWidth: .infinity, alignment: .center)
+            }
+            .frame(maxWidth: .infinity)
+        }
+    }
+    
+    // MARK: - Active Round View
+    func activeRoundView(screenWidth: CGFloat) -> some View {
+        ScrollView {
+            VStack(spacing: 20) {
+                // Top section with course name and stats
+                VStack(spacing: 10) {
+                    Text(golfCourse)
+                        .font(.title)
+                        .fontWeight(.bold)
+                        .foregroundColor(.white)
+                        .multilineTextAlignment(.center)
+                        .fixedSize(horizontal: false, vertical: true)
+                        .frame(width: screenWidth * 0.9, alignment: .center)
+                    
+                    // Stats bar
+                    VStack(spacing: 12) {
+                        HStack(spacing: 12) {
+                            StatBox(icon: "figure.walk", value: "\(stepCount)", label: "Steps", width: (screenWidth * 0.9 - 30) / 2)
+                            StatBox(icon: "location.fill", value: "\(holeCount)", label: "Holes", width: (screenWidth * 0.9 - 30) / 2)
+                        }
+                        .frame(maxWidth: .infinity, alignment: .center)
+                        
+                        HStack(spacing: 12) {
+                            StatBox(icon: "flame.fill", value: "\(Int(calories))", label: "Cal", width: (screenWidth * 0.9 - 30) / 2)
+                            StatBox(icon: "arrow.forward", value: String(format: "%.1f", distance), label: "Miles", width: (screenWidth * 0.9 - 30) / 2)
+                        }
+                        .frame(maxWidth: .infinity, alignment: .center)
+                    }
+                }
+                .padding()
+                .background(Color.black.opacity(0.5))
+                .cornerRadius(15)
+                .frame(width: screenWidth * 0.9)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Current hole display
+                ZStack {
+                    Circle()
+                        .fill(Color.green)
+                        .frame(width: 140, height: 140)
+                        .shadow(radius: 10)
+                    
+                    VStack {
+                        Text("HOLE")
+                            .font(.system(size: 16, weight: .semibold))
+                        
+                        Text("\(currentHole)")
+                            .font(.system(size: 60, weight: .bold))
+                    }
+                    .foregroundColor(.white)
+                }
+                .padding(.vertical, 20)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Score input
+                VStack(spacing: 10) {
+                    Text("SCORE")
+                        .font(.headline)
+                        .foregroundColor(.white)
+                    
+                    HStack(spacing: 20) {
+                        Button(action: { decrementScore() }) {
+                            Image(systemName: "minus.circle.fill")
+                                .font(.system(size: 30))
+                                .foregroundColor(.white)
+                        }
+                        
+                        Text("\(scores[currentHole - 1])")
+                            .font(.system(size: 48, weight: .bold))
+                            .foregroundColor(.white)
+                            .frame(width: 80)
+                        
+                        Button(action: { incrementScore() }) {
+                            Image(systemName: "plus.circle.fill")
+                                .font(.system(size: 30))
+                                .foregroundColor(.white)
+                        }
+                    }
+                    .padding()
+                    .background(Color.black.opacity(0.5))
+                    .cornerRadius(15)
+                    .frame(width: screenWidth * 0.9)
+                    .frame(maxWidth: .infinity, alignment: .center)
+                    
+                }
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                Spacer().frame(height: 20)
+                
+                // Navigation buttons
+                VStack(spacing: 15) {
+                    Button(action: { nextHole() }) {
+                        HStack {
+                            Text(currentHole == holeCount ? "Finish Round" : "Next Hole")
+                            Image(systemName: "chevron.right")
+                        }
+                        .padding()
+                        .frame(width: screenWidth * 0.9)
+                        .background(Color.blue)
+                        .foregroundColor(.white)
+                        .cornerRadius(12)
+                    }
+                    .frame(maxWidth: .infinity, alignment: .center)
+                    
+                    Button(action: { previousHole() }) {
+                        HStack {
+                            Image(systemName: "chevron.left")
+                            Text("Previous Hole")
+                        }
+                        .padding()
+                        .frame(width: screenWidth * 0.9)
+                        .background(currentHole > 1 ? Color.blue : Color.gray)
+                        .foregroundColor(.white)
+                        .cornerRadius(12)
+                    }
+                    .disabled(currentHole <= 1)
+                    .frame(maxWidth: .infinity, alignment: .center)
+                }
+                .padding(.bottom, 30)
+                .frame(maxWidth: .infinity, alignment: .center)
+            }
+            .padding(.top, 20)
+            .frame(maxWidth: .infinity)
+        }
+        .onAppear {
+            startHealthKitMonitoring()
+        }
+    }
+    
+    // MARK: - Round Summary View
+    func roundSummaryView(screenWidth: CGFloat) -> some View {
+        ScrollView {
+            VStack(spacing: 20) {
+                Text("Round Complete!")
+                    .font(.system(size: 32, weight: .bold))
+                    .foregroundColor(.white)
+                    .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Course and date info
+                VStack(spacing: 5) {
+                    Text(golfCourse)
+                        .font(.title2)
+                        .foregroundColor(.white)
+                        .multilineTextAlignment(.center)
+                        .frame(maxWidth: .infinity, alignment: .center)
+                    
+                    Text(formattedDate())
+                        .font(.subheadline)
+                        .foregroundColor(.white.opacity(0.8))
+                        .frame(maxWidth: .infinity, alignment: .center)
+                }
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Total score
+                VStack {
+                    Text("TOTAL SCORE")
+                        .font(.headline)
+                        .foregroundColor(.white.opacity(0.7))
+                    
+                    Text("\(calculateTotalScore())")
+                        .font(.system(size: 60, weight: .bold))
+                        .foregroundColor(.white)
+                }
+                .padding(.vertical, 20)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Health stats
+                VStack(spacing: 12) {
+                    Text("ACTIVITY STATS")
+                        .font(.headline)
+                        .foregroundColor(.white.opacity(0.7))
+                    
+                    VStack(spacing: 12) {
+                        HStack(spacing: 12) {
+                            StatBox(icon: "clock", value: formattedDuration(), label: "Duration", width: (screenWidth * 0.9 - 24) / 2)
+                            StatBox(icon: "flame.fill", value: "\(Int(calories))", label: "Calories", width: (screenWidth * 0.9 - 24) / 2)
+                        }
+                        .frame(maxWidth: .infinity, alignment: .center)
+                        
+                        HStack(spacing: 12) {
+                            StatBox(icon: "figure.walk", value: "\(stepCount)", label: "Steps", width: (screenWidth * 0.9 - 24) / 2)
+                            StatBox(icon: "arrow.forward", value: String(format: "%.1f", distance), label: "Miles", width: (screenWidth * 0.9 - 24) / 2)
+                        }
+                        .frame(maxWidth: .infinity, alignment: .center)
+                    }
+                }
+                .padding()
+                .background(Color.black.opacity(0.5))
+                .cornerRadius(15)
+                .frame(width: screenWidth * 0.9)
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Scorecard
+                VStack(spacing: 10) {
+                    Text("SCORECARD")
+                        .font(.headline)
+                        .foregroundColor(.white.opacity(0.7))
+                    
+                    VStack(spacing: 0) {
+                        // Header row
+                        HStack {
+                            Text("Hole")
+                                .frame(width: 60, alignment: .leading)
+                            
+                            Spacer()
+                            
+                            Text("Score")
+                                .frame(width: 60, alignment: .trailing)
+                        }
+                        .padding(.vertical, 10)
+                        .padding(.horizontal)
+                        .background(Color.gray.opacity(0.5))
+                        .foregroundColor(.white)
+                        
+                        // Score rows
+                        ForEach(0..<holeCount, id: \.self) { index in
+                            VStack(spacing: 0) {
+                                HStack {
+                                    Text("Hole \(index + 1 + (holeCount == 9 && nineHoleSection == "back" ? 9 : 0))")
+                                        .frame(width: 60, alignment: .leading)
+                                    
+                                    Spacer()
+                                    
+                                    Text("\(scores[index])")
+                                        .frame(width: 60, alignment: .trailing)
+                                }
+                                .padding(.vertical, 10)
+                                .padding(.horizontal)
+                                
+                                if index < holeCount - 1 {
+                                    Divider()
+                                        .background(Color.gray.opacity(0.3))
+                                }
+                            }
+                        }
+                    }
+                    .background(Color.white.opacity(0.1))
+                    .cornerRadius(12)
+                    .frame(width: screenWidth * 0.9)
+                }
+                .frame(maxWidth: .infinity, alignment: .center)
+                
+                // Action buttons
+                VStack(spacing: 15) {
+                    Button(action: {
+                        saveRoundToFirebase()
+                    }) {
+                        Text("Save Round")
+                            .font(.title3)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .frame(width: screenWidth * 0.9)
+                            .padding(.vertical, 16)
+                            .background(Color.green)
+                            .cornerRadius(15)
+                    }
+                    .frame(maxWidth: .infinity, alignment: .center)
+                    
+                    Button(action: {
+                        showLeagueSubmission = true
+                    }) {
+                        Text("Submit to League")
+                            .font(.title3)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .frame(width: screenWidth * 0.9)
+                            .padding(.vertical, 16)
+                            .background(Color.orange)
+                            .cornerRadius(15)
+                    }
+                    .frame(maxWidth: .infinity, alignment: .center)
+                    
+                    Button(action: {
+                        shareRound()
+                    }) {
+                        HStack {
+                            Image(systemName: "square.and.arrow.up")
+                            Text("Share Results")
+                        }
+                        .font(.title3)
+                        .fontWeight(.bold)
+                        .foregroundColor(.white)
+                        .frame(width: screenWidth * 0.9)
+                        .padding(.vertical, 16)
+                        .background(Color.blue)
+                        .cornerRadius(15)
+                    }
+                    .frame(maxWidth: .infinity, alignment: .center)
+                    
+                    Button(action: {
+                        resetAndStartNewRound()
+                    }) {
+                        Text("New Round")
+                            .font(.title3)
+                            .fontWeight(.bold)
+                            .foregroundColor(.black)
+                            .frame(width: screenWidth * 0.9)
+                            .padding(.vertical, 16)
+                            .background(Color.white)
+                            .cornerRadius(15)
+                    }
+                    .frame(maxWidth: .infinity, alignment: .center)
+                }
+                .padding(.bottom, 30)
+            }
+            .padding(.top, 30)
+            .frame(maxWidth: .infinity)
+        }
+    }
+    
+    // MARK: - Component Views
+    
+    struct TransportButton: View {
+        let mode: TransportMode
+        let isSelected: Bool
+        let action: () -> Void
+        let screenWidth: CGFloat
+        
+        var body: some View {
+            Button(action: action) {
+                HStack {
+                    Image(systemName: mode.icon)
+                        .font(.system(size: 24))
+                        .frame(width: 30)
+                    
+                    Text(mode.rawValue)
+                        .font(.system(size: 16))
+                    
+                    Spacer()
+                }
+                .padding()
+                .frame(width: screenWidth)
+                .background(isSelected ? Color.blue : Color.white)
+                .foregroundColor(isSelected ? .white : .black)
+                .cornerRadius(12)
+                .shadow(radius: isSelected ? 5 : 0)
+            }
+            .frame(maxWidth: .infinity, alignment: .center)
+        }
+    }
+    
+    struct StatBox: View {
+        let icon: String
+        let value: String
+        let label: String
+        let width: CGFloat
+        
+        var body: some View {
+            VStack(spacing: 5) {
+                HStack(spacing: 5) {
+                    Image(systemName: icon)
+                        .font(.system(size: 14))
+                        .foregroundColor(.gray)
+                    
+                    Text(value)
+                        .font(.system(size: 18, weight: .bold))
+                        .lineLimit(1)
+                        .minimumScaleFactor(0.7)
+                }
+                
+                Text(label)
+                    .font(.system(size: 12))
+                    .foregroundColor(.gray)
+            }
+            .padding()
+            .frame(width: width)
+            .background(Color.white)
+            .cornerRadius(10)
+        }
+    }
+    
+    // MARK: - Functions
+    
+    private func startRound() {
+        print("Starting round with: Course: \(golfCourse), Holes: \(holeCount), Section: \(nineHoleSection)")
+        isTracking = true
+        startTime = Date()
+        
+        // Set starting hole based on front/back selection
+        if holeCount == 9 && nineHoleSection == "back" {
+            currentHole = 10
+        } else {
+            currentHole = 1
+        }
+        
+        // Reset scores
+        scores = Array(repeating: 0, count: 18)
+        notes = Array(repeating: "", count: 18)
+        
+        // Start workout tracking
+        workoutManager.startWorkoutOnWatch()
+    }
+    
+    private func incrementScore() {
+        let scoreIndex = currentHole - 1
+        if scores[scoreIndex] < 10 {
+            scores[scoreIndex] += 1
+            print("Incremented score for hole \(currentHole) to \(scores[scoreIndex])")
+        }
+    }
+    
+    private func decrementScore() {
+        let scoreIndex = currentHole - 1
+        if scores[scoreIndex] > 0 {
+            scores[scoreIndex] -= 1
+            print("Decremented score for hole \(currentHole) to \(scores[scoreIndex])")
+        }
+    }
+    
+    private func nextHole() {
+        if holeCount == 9 && nineHoleSection == "back" {
+            if currentHole < 18 {
+                currentHole += 1
+            } else {
+                showConfirmation = true
+            }
+        } else {
+            if currentHole < holeCount {
+                currentHole += 1
+            } else {
+                showConfirmation = true
+            }
+        }
+    }
+    
+    private func previousHole() {
+        if holeCount == 9 && nineHoleSection == "back" {
+            if currentHole > 10 {
+                currentHole -= 1
+            }
+        } else {
+            if currentHole > 1 {
+                currentHole -= 1
+            }
+        }
+    }
+    
+    private func finishRound() {
+        // Stop activity monitoring
+        workoutManager.endWorkoutOnWatch()
+        stopHealthKitMonitoring()
+        
+        // Mark as completed
+        roundCompleted = true
+    }
+    
+    private func saveRoundToFirebase() {
+        guard let userId = Auth.auth().currentUser?.uid else {
+            // Handle error - user not logged in
+            return
+        }
+        
+        let roundData = createRoundData()
+        
+        // Create a score entry
+        let scoreEntry = Models.User.Score(
+            id: UUID().uuidString,
+            course: golfCourse,
+            score: calculateTotalScore(),
+            date: Date(),
+            holesPlayed: "\(holeCount) Holes" + (holeCount == 9 ? " (\(nineHoleSection == "front" ? "Front" : "Back"))" : ""),
+            steps: stepCount,
+            distance: distance,
+            caloriesBurned: calories
+        )
+        
+        if networkMonitor.isConnected {
+            // Save directly to Firebase
+            UserService.shared.addScore(score: scoreEntry) { result in
+                switch result {
+                case .success(_):
+                    print("Round saved successfully")
+                case .failure(let error):
+                    print("Error saving round: \(error.localizedDescription)")
+                }
+            }
+        } else {
+            // Save offline
+            if let userId = Auth.auth().currentUser?.uid {
+                FirestoreManager.shared.saveScoreOffline(score: scoreEntry, userId: userId) { result in
+                    switch result {
+                    case .success(_):
+                        print("Round saved offline")
+                    case .failure(let error):
+                        print("Error saving round offline: \(error.localizedDescription)")
+                    }
+                }
+            }
+        }
+    }
+    
+    private func submitScoreToLeague(leagueId: String) {
+        guard let userId = Auth.auth().currentUser?.uid else {
+            return
+        }
+        
+        let db = Firestore.firestore()
+        
+        // Create a new round document in the league's rounds collection
+        let roundData: [String: Any] = [
+            "userId": userId,
+            "course": golfCourse,
+            "score": calculateTotalScore(),
+            "date": Timestamp(date: Date()),
+            "holeCount": holeCount,
+            "nineHoleSection": holeCount == 9 ? nineHoleSection : "full",
+            "transportMode": transportMode.rawValue,
+            "healthData": [
+                "steps": stepCount,
+                "distance": distance,
+                "calories": calories
+            ]
+        ]
+        
+        db.collection("leagues").document(leagueId).collection("rounds").addDocument(data: roundData) { error in
+            if let error = error {
+                print("Error submitting score to league: \(error.localizedDescription)")
+            } else {
+                print("Score successfully submitted to league")
+            }
+        }
+    }
+    
+    private func shareRound() {
+        var shareText = "I just finished a round at \(golfCourse)!\n"
+        shareText += "Total Score: \(calculateTotalScore())\n"
+        
+        if holeCount == 9 {
+            shareText += "Holes Played: \(holeCount) (\(nineHoleSection == "front" ? "Front 9" : "Back 9"))\n"
+        } else {
+            shareText += "Holes Played: \(holeCount)\n"
+        }
+        
+        shareText += "Steps: \(stepCount)\n"
+        shareText += "Calories Burned: \(Int(calories))\n"
+        
+        let activityVC = UIActivityViewController(activityItems: [shareText], applicationActivities: nil)
+        
+        // Present the activity view controller
+        if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
+           let rootViewController = windowScene.windows.first?.rootViewController {
+            rootViewController.present(activityVC, animated: true)
+        }
+    }
+    
+    private func createRoundData() -> [String: Any] {
+        let duration = calculateDuration()
+        
+        var roundData: [String: Any] = [
+            "course": golfCourse,
+            "date": Date(),
+            "duration": duration,
+            "holeCount": holeCount,
+            "scores": scores,
+            "notes": notes,
+            "totalScore": calculateTotalScore(),
+            "transportMode": transportMode.rawValue,
+            "healthData": [
+                "steps": stepCount,
+                "distance": distance,
+                "calories": calories
+            ]
+        ]
+        
+        if holeCount == 9 {
+            roundData["nineHoleSection"] = nineHoleSection
+        }
+        
+        return roundData
+    }
+    
+    private func resetAndStartNewRound() {
+        // Reset state
+        golfCourse = ""
+        holeCount = 18
+        nineHoleSection = "front"
+        transportMode = .walking
+        isTracking = false
+        currentHole = 1
+        scores = Array(repeating: 0, count: 18)
+        notes = Array(repeating: "", count: 18)
+        roundCompleted = false
+        
+        // Reset health data
+        startTime = nil
+        stepCount = 0
+        distance = 0.0
+        calories = 0.0
+    }
+    
+    // MARK: - Helper Functions
+    
+    private func calculateTotalScore() -> Int {
+        if holeCount == 9 && nineHoleSection == "back" {
+            return scores.prefix(9).reduce(0, +)
+        } else {
+            return scores.prefix(holeCount).reduce(0, +)
+        }
+    }
+    
+    private func calculateDuration() -> TimeInterval {
+        guard let start = startTime else { return 0 }
+        return Date().timeIntervalSince(start)
+    }
+    
+    private func formattedDate() -> String {
+        let formatter = DateFormatter()
+        formatter.dateStyle = .medium
+        formatter.timeStyle = .none
+        return formatter.string(from: Date())
+    }
+    
+    private func formattedDuration() -> String {
+        let duration = calculateDuration()
+        let hours = Int(duration) / 3600
+        let minutes = (Int(duration) % 3600) / 60
+        
+        if hours > 0 {
+            return "\(hours)h \(minutes)m"
+        } else {
+            return "\(minutes)m"
+        }
+    }
+    
+    // MARK: - HealthKit Functions
+    
+    private func requestHealthKitPermissions() {
+        guard HKHealthStore.isHealthDataAvailable() else { return }
+        
+        let typesToRead: Set<HKObjectType> = [
+            HKQuantityType.quantityType(forIdentifier: .stepCount)!,
+            HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning)!,
+            HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned)!
+        ]
+        
+        healthStore.requestAuthorization(toShare: nil, read: typesToRead) { success, error in
+            if !success {
+                print("HealthKit authorization failed: \(String(describing: error))")
+            }
+        }
+    }
+    
+    private func startHealthKitMonitoring() {
+        // This would be expanded to actually query the HealthKit store
+        // and set up observers for real-time updates
+        
+        // For this example, we'll simulate health data updates with a timer
+        Timer.scheduledTimer(withTimeInterval: 10, repeats: true) { _ in
+            DispatchQueue.main.async {
+                // Simulate health data changes based on transport mode
+                if transportMode == .walking {
+                    stepCount += Int.random(in: 50...200)
+                    distance += Double.random(in: 0.02...0.1)
+                    calories += Double.random(in: 5...20)
+                } else {
+                    stepCount += Int.random(in: 5...30)
+                    distance += Double.random(in: 0.02...0.1)
+                    calories += Double.random(in: 1...10)
+                }
+            }
+        }
+    }
+    
+    private func stopHealthKitMonitoring() {
+        // This would stop any active observers or queries
+    }
+}
+
+struct EnhancedPlayNowView_Previews: PreviewProvider {
+    static var previews: some View {
+        EnhancedPlayNowView()
+            .environmentObject(iOSWorkoutManager())
+            .environmentObject(NetworkMonitor())
+    }
+}
diff --git a/Aldo/Views/FriendRequestView.swift b/Aldo/Views/FriendRequestView.swift
new file mode 100644
index 0000000..af166e5
--- /dev/null
+++ b/Aldo/Views/FriendRequestView.swift
@@ -0,0 +1,52 @@
+//
+//  FriendRequestView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import SwiftUI
+
+struct FriendRequestView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+
+    var body: some View {
+        List {
+            ForEach(authManager.friendRequests, id: \.id) { user in
+                HStack {
+                    Text(user.username)
+                    Spacer()
+                    Button(action: {
+                        acceptFriendRequest(user)
+                    }) {
+                        Text("Accept")
+                            .padding(8)
+                            .background(Color.green)
+                            .foregroundColor(.white)
+                            .cornerRadius(8)
+                    }
+                }
+            }
+        }
+        .onAppear {
+            authManager.fetchFriendRequests()
+        }
+    }
+
+    private func acceptFriendRequest(_ user: AppUser) {
+        authManager.acceptFriendRequest(user) { success in
+            if success {
+                print("Friend request accepted")
+            } else {
+                print("Failed to accept friend request")
+            }
+        }
+    }
+}
+
+struct FriendRequestView_Previews: PreviewProvider {
+    static var previews: some View {
+        FriendRequestView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/FriendsListView.swift b/Aldo/Views/FriendsListView.swift
new file mode 100644
index 0000000..76c94f0
--- /dev/null
+++ b/Aldo/Views/FriendsListView.swift
@@ -0,0 +1,414 @@
+//
+//  FriendsListView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/25/24.
+//
+
+import SwiftUI
+import Firebase
+import FirebaseFirestore
+
+struct FriendsListView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @State private var showAddUsers = false
+    @State private var friends: [Models.User] = []
+    @State private var isLoading = false
+    @State private var searchText = ""
+    
+    var filteredFriends: [Models.User] {
+        if searchText.isEmpty {
+            return friends
+        } else {
+            return friends.filter { friend in
+                friend.username.localizedCaseInsensitiveContains(searchText) ||
+                friend.phoneNumber.localizedCaseInsensitiveContains(searchText)
+            }
+        }
+    }
+    
+    var body: some View {
+        NavigationView {
+            VStack {
+                // Search bar
+                HStack {
+                    Image(systemName: "magnifyingglass")
+                        .foregroundColor(.gray)
+                    
+                    TextField("Search friends", text: $searchText)
+                    
+                    if !searchText.isEmpty {
+                        Button(action: {
+                            searchText = ""
+                        }) {
+                            Image(systemName: "xmark.circle.fill")
+                                .foregroundColor(.gray)
+                        }
+                    }
+                }
+                .padding()
+                .background(Color(.systemGray6))
+                .cornerRadius(10)
+                .padding()
+                
+                if isLoading {
+                    ProgressView("Loading friends...")
+                        .padding()
+                } else if friends.isEmpty {
+                    VStack(spacing: 20) {
+                        Text("You don't have any friends yet")
+                            .font(.headline)
+                            .foregroundColor(.gray)
+                        
+                        Button(action: {
+                            showAddUsers = true
+                        }) {
+                            HStack {
+                                Image(systemName: "person.badge.plus")
+                                Text("Add Friends")
+                            }
+                            .padding()
+                            .background(Color.blue)
+                            .foregroundColor(.white)
+                            .cornerRadius(10)
+                        }
+                    }
+                    .padding(.top, 50)
+                } else {
+                    List {
+                        ForEach(filteredFriends) { friend in
+                            NavigationLink(destination: FriendDetailView(friend: friend)) {
+                                HStack {
+                                    if let profilePicture = friend.profilePicture, let url = URL(string: profilePicture) {
+                                        AsyncImage(url: url) { image in
+                                            image
+                                                .resizable()
+                                                .scaledToFill()
+                                                .frame(width: 50, height: 50)
+                                                .clipShape(Circle())
+                                        } placeholder: {
+                                            Image(systemName: "person.circle.fill")
+                                                .resizable()
+                                                .scaledToFit()
+                                                .frame(width: 50, height: 50)
+                                                .foregroundColor(.gray)
+                                        }
+                                    } else {
+                                        Image(systemName: "person.circle.fill")
+                                            .resizable()
+                                            .scaledToFit()
+                                            .frame(width: 50, height: 50)
+                                            .foregroundColor(.gray)
+                                    }
+                                    
+                                    VStack(alignment: .leading) {
+                                        Text(friend.username)
+                                            .font(.headline)
+                                        Text(friend.phoneNumber)
+                                            .font(.subheadline)
+                                            .foregroundColor(.gray)
+                                    }
+                                }
+                            }
+                        }
+                        .onDelete(perform: removeFriend)
+                    }
+                }
+            }
+            .navigationTitle("Friends")
+            .toolbar {
+                ToolbarItem(placement: .navigationBarTrailing) {
+                    Button(action: {
+                        showAddUsers = true
+                    }) {
+                        Image(systemName: "person.badge.plus")
+                    }
+                }
+            }
+            .sheet(isPresented: $showAddUsers) {
+                NavigationView {
+                    AddUsersView()
+                        .navigationTitle("Add Friends")
+                        .toolbar {
+                            ToolbarItem(placement: .navigationBarLeading) {
+                                Button("Cancel") {
+                                    showAddUsers = false
+                                }
+                            }
+                        }
+                }
+            }
+            .onAppear {
+                fetchFriends()
+            }
+        }
+    }
+    
+    private func fetchFriends() {
+        guard let currentUser = authManager.currentUser else { return }
+        
+        isLoading = true
+        
+        let db = Firestore.firestore()
+        // For each friend ID in the user's friends list, fetch the corresponding user details
+        let friendIds = currentUser.friends
+        
+        if friendIds.isEmpty {
+            isLoading = false
+            return
+        }
+        
+        let dispatchGroup = DispatchGroup()
+        var fetchedFriends: [Models.User] = []
+        
+        for friendId in friendIds {
+            dispatchGroup.enter()
+            
+            db.collection("users").document(friendId).getDocument { snapshot, error in
+                defer { dispatchGroup.leave() }
+                
+                if let error = error {
+                    print("Error fetching friend data: \(error.localizedDescription)")
+                    return
+                }
+                
+                guard let snapshot = snapshot, snapshot.exists, let data = snapshot.data() else {
+                    print("Friend document doesn't exist for ID: \(friendId)")
+                    return
+                }
+                
+                if let friend = Models.User.fromDictionary(data, id: friendId) {
+                    fetchedFriends.append(friend)
+                }
+            }
+        }
+        
+        dispatchGroup.notify(queue: .main) {
+            self.friends = fetchedFriends
+            self.isLoading = false
+        }
+    }
+    
+    private func removeFriend(at offsets: IndexSet) {
+        guard let currentUser = authManager.currentUser, let currentUserId = Auth.auth().currentUser?.uid else { return }
+        
+        let db = Firestore.firestore()
+        
+        for index in offsets {
+            let friendToRemove = filteredFriends[index]
+            let friendId = friendToRemove.id
+            
+            // Update current user's friends list
+            db.collection("users").document(currentUserId).updateData([
+                "friends": FieldValue.arrayRemove([friendId])
+            ]) { error in
+                if let error = error {
+                    print("Error removing friend from current user: \(error.localizedDescription)")
+                    return
+                }
+                
+                // Update friend's friends list
+                db.collection("users").document(friendId).updateData([
+                    "friends": FieldValue.arrayRemove([currentUserId])
+                ]) { error in
+                    if let error = error {
+                        print("Error removing current user from friend: \(error.localizedDescription)")
+                    }
+                }
+            }
+            
+            // Update local data
+            if let indexInMainList = friends.firstIndex(where: { $0.id == friendId }) {
+                friends.remove(at: indexInMainList)
+            }
+        }
+    }
+}
+
+struct FriendDetailView: View {
+    let friend: Models.User
+    @State private var showingScores = false
+    
+    var body: some View {
+        ScrollView {
+            VStack(alignment: .center, spacing: 20) {
+                // Profile picture
+                if let profilePicture = friend.profilePicture, let url = URL(string: profilePicture) {
+                    AsyncImage(url: url) { image in
+                        image
+                            .resizable()
+                            .scaledToFill()
+                            .frame(width: 120, height: 120)
+                            .clipShape(Circle())
+                            .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                            .shadow(radius: 5)
+                    } placeholder: {
+                        Image(systemName: "person.circle.fill")
+                            .resizable()
+                            .scaledToFit()
+                            .frame(width: 120, height: 120)
+                            .foregroundColor(.gray)
+                    }
+                } else {
+                    Image(systemName: "person.circle.fill")
+                        .resizable()
+                        .scaledToFit()
+                        .frame(width: 120, height: 120)
+                        .foregroundColor(.gray)
+                }
+                
+                // User info
+                Text(friend.username)
+                    .font(.title)
+                    .fontWeight(.bold)
+                
+                HStack {
+                    Image(systemName: "envelope.fill")
+                        .foregroundColor(.gray)
+                    Text(friend.email)
+                        .foregroundColor(.gray)
+                }
+                
+                HStack {
+                    Image(systemName: "phone.fill")
+                        .foregroundColor(.gray)
+                    Text(friend.phoneNumber.isEmpty ? "No phone number" : friend.phoneNumber)
+                        .foregroundColor(.gray)
+                }
+                
+                if !friend.bio.isEmpty {
+                    VStack(alignment: .leading) {
+                        Text("About")
+                            .font(.headline)
+                            .padding(.bottom, 5)
+                        
+                        Text(friend.bio)
+                            .foregroundColor(.secondary)
+                    }
+                    .frame(maxWidth: .infinity, alignment: .leading)
+                    .padding()
+                    .background(Color(.systemGray6))
+                    .cornerRadius(10)
+                    .padding(.horizontal)
+                }
+                
+                // Action buttons
+                Button(action: {
+                    showingScores.toggle()
+                }) {
+                    HStack {
+                        Image(systemName: "list.bullet.clipboard")
+                        Text("View Scores")
+                    }
+                    .padding()
+                    .frame(maxWidth: .infinity)
+                    .background(Color.blue)
+                    .foregroundColor(.white)
+                    .cornerRadius(10)
+                    .padding(.horizontal)
+                }
+                
+                Button(action: {
+                    // Implement message functionality
+                }) {
+                    HStack {
+                        Image(systemName: "message.fill")
+                        Text("Message")
+                    }
+                    .padding()
+                    .frame(maxWidth: .infinity)
+                    .background(Color.green)
+                    .foregroundColor(.white)
+                    .cornerRadius(10)
+                    .padding(.horizontal)
+                }
+                
+                Spacer()
+            }
+            .padding()
+        }
+        .navigationTitle("Friend Details")
+        .sheet(isPresented: $showingScores) {
+            ScoresListView(user: friend)
+        }
+    }
+}
+
+struct ScoresListView: View {
+    let user: Models.User
+    
+    var body: some View {
+        NavigationView {
+            List {
+                if user.scores.isEmpty {
+                    Text("No scores recorded")
+                        .foregroundColor(.gray)
+                        .padding()
+                } else {
+                    ForEach(user.scores.sorted(by: { $0.date > $1.date })) { score in
+                        ScoreRow(score: score)
+                    }
+                }
+            }
+            .navigationTitle("\(user.username)'s Scores")
+            .toolbar {
+                ToolbarItem(placement: .navigationBarTrailing) {
+                    Button("Done") {
+                        // Close sheet
+                    }
+                }
+            }
+        }
+    }
+}
+
+struct ScoreRow: View {
+    let score: Models.User.Score
+    
+    var body: some View {
+        VStack(alignment: .leading) {
+            HStack {
+                Text(score.course)
+                    .font(.headline)
+                Spacer()
+                Text("\(score.score)")
+                    .font(.title2)
+                    .fontWeight(.bold)
+            }
+            
+            HStack {
+                Text(dateFormatter.string(from: score.date))
+                    .font(.subheadline)
+                    .foregroundColor(.gray)
+                Spacer()
+                Text(score.holesPlayed)
+                    .font(.subheadline)
+                    .foregroundColor(.gray)
+            }
+            
+            if let steps = score.steps, steps > 0 {
+                HStack {
+                    Image(systemName: "figure.walk")
+                    Text("\(steps) steps")
+                        .font(.caption)
+                        .foregroundColor(.green)
+                }
+                .padding(.top, 2)
+            }
+        }
+        .padding(.vertical, 4)
+    }
+    
+    private var dateFormatter: DateFormatter {
+        let formatter = DateFormatter()
+        formatter.dateStyle = .medium
+        return formatter
+    }
+}
+
+struct FriendsListView_Previews: PreviewProvider {
+    static var previews: some View {
+        FriendsListView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/GolfCourse.swift b/Aldo/Views/GolfCourse.swift
new file mode 100644
index 0000000..375a140
--- /dev/null
+++ b/Aldo/Views/GolfCourse.swift
@@ -0,0 +1,14 @@
+//
+//  GolfCourse.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 1/26/25.
+//
+
+import Foundation
+
+struct GolfCourse: Identifiable {
+    let id: Int
+    let name: String
+    let par: Int
+}
diff --git a/Aldo/Views/ImagePicker.swift b/Aldo/Views/ImagePicker.swift
new file mode 100644
index 0000000..8d8c7b8
--- /dev/null
+++ b/Aldo/Views/ImagePicker.swift
@@ -0,0 +1,41 @@
+//
+//  ImagePicker.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import SwiftUI
+import UIKit
+
+struct ImagePicker: UIViewControllerRepresentable {
+    @Binding var image: UIImage?
+    
+    func makeUIViewController(context: Context) -> UIImagePickerController {
+        let picker = UIImagePickerController()
+        picker.delegate = context.coordinator
+        return picker
+    }
+    
+    func updateUIViewController(_ uiViewController: UIImagePickerController, context: Context) {}
+    
+    func makeCoordinator() -> Coordinator {
+        Coordinator(self)
+    }
+    
+    class Coordinator: NSObject, UIImagePickerControllerDelegate, UINavigationControllerDelegate {
+        let parent: ImagePicker
+        
+        init(_ parent: ImagePicker) {
+            self.parent = parent
+        }
+        
+        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
+            if let uiImage = info[.originalImage] as? UIImage {
+                parent.image = uiImage
+            }
+            picker.dismiss(animated: true)
+        }
+    }
+}
+
diff --git a/Aldo/Views/League.swift b/Aldo/Views/League.swift
new file mode 100644
index 0000000..fb570e3
--- /dev/null
+++ b/Aldo/Views/League.swift
@@ -0,0 +1,49 @@
+import FirebaseFirestore
+
+struct League {
+    var id: String
+    var name: String
+    var hostUserId: String
+    var members: [String]
+    var course: String
+    var schedule: String
+    var createdAt: Timestamp
+
+    // Initialize the model
+    init(id: String = "", name: String, hostUserId: String, members: [String], course: String, schedule: String, createdAt: Timestamp = Timestamp(date: Date())) {
+        self.id = id
+        self.name = name
+        self.hostUserId = hostUserId
+        self.members = members
+        self.course = course
+        self.schedule = schedule
+        self.createdAt = createdAt
+    }
+
+    // Convert model to Firestore dictionary
+    func toDictionary() -> [String: Any] {
+        return [
+            "name": name,
+            "hostUserId": hostUserId,
+            "members": members,
+            "course": course,
+            "schedule": schedule,
+            "createdAt": createdAt
+        ]
+    }
+
+    // Define Round model here
+    struct Round {
+        var id: String // Add this ID
+        var number: Int
+        var score: Int
+        var createdAt: Timestamp
+    }
+
+    // Define Score model here
+    struct Score {
+        var id: UUID
+        var userId: String
+        var holeScores: [Int]
+    }
+}
diff --git a/Aldo/Views/LeagueDetailView.swift b/Aldo/Views/LeagueDetailView.swift
new file mode 100644
index 0000000..a663bab
--- /dev/null
+++ b/Aldo/Views/LeagueDetailView.swift
@@ -0,0 +1,157 @@
+import SwiftUI
+import FirebaseFirestore
+
+// Assuming your League model is defined in another file as you provided:
+//
+// struct League {
+//     var id: String
+//     var name: String
+//     var hostUserId: String
+//     var members: [String]
+//     var course: String
+//     var schedule: String
+//     var createdAt: Timestamp
+//
+//     init(id: String = "", name: String, hostUserId: String, members: [String], course: String, schedule: String, createdAt: Timestamp = Timestamp(date: Date())) {
+//         self.id = id
+//         self.name = name
+//         self.hostUserId = hostUserId
+//         self.members = members
+//         self.course = course
+//         self.schedule = schedule
+//         self.createdAt = createdAt
+//     }
+//
+//     func toDictionary() -> [String: Any] { ... }
+//
+//     struct Round {
+//         var id: String
+//         var number: Int
+//         var score: Int
+//         var createdAt: Timestamp
+//     }
+//
+//     struct Score { ... }
+// }
+
+struct LeagueDetailView: View {
+    var league: League
+    @State private var rounds: [League.Round] = []
+    
+    var body: some View {
+        VStack {
+            Text(league.name)
+                .font(.title)
+                .padding()
+            
+            if rounds.isEmpty {
+                Text("No rounds yet.")
+                    .foregroundColor(.gray)
+                    .padding()
+            } else {
+                List(rounds, id: \.id) { round in
+                    VStack(alignment: .leading) {
+                        Text("Round \(round.number)")
+                            .font(.headline)
+                        Text("Score: \(round.score)")
+                            .font(.subheadline)
+                        Text("Date: \(round.createdAt.dateValue(), formatter: dateFormatter)")
+                            .font(.caption)
+                    }
+                    .padding(.vertical, 4)
+                }
+                .listStyle(PlainListStyle())
+            }
+            
+            Button("Add Round") {
+                addNewRound()
+            }
+            .font(.title2)
+            .padding()
+            .background(Color.blue)
+            .foregroundColor(.white)
+            .cornerRadius(10)
+            .shadow(radius: 5)
+            .padding()
+            
+            Spacer()
+        }
+        .onAppear {
+            fetchRounds()
+        }
+    }
+    
+    // Fetch rounds from Firestore and map them to League.Round objects.
+    private func fetchRounds() {
+        let db = Firestore.firestore()
+        db.collection("leagues")
+            .document(league.id)
+            .collection("rounds")
+            .order(by: "number")
+            .getDocuments { snapshot, error in
+                if let error = error {
+                    print("Error fetching rounds: \(error.localizedDescription)")
+                } else {
+                    var fetchedRounds: [League.Round] = []
+                    snapshot?.documents.forEach { doc in
+                        let data = doc.data()
+                        let number = data["number"] as? Int ?? 0
+                        let score = data["score"] as? Int ?? 0
+                        let createdAt = data["createdAt"] as? Timestamp ?? Timestamp(date: Date())
+                        let id = doc.documentID
+                        let round = League.Round(id: id, number: number, score: score, createdAt: createdAt)
+                        fetchedRounds.append(round)
+                    }
+                    rounds = fetchedRounds
+                }
+            }
+    }
+    
+    // Create a new round and add it to Firestore.
+    private func addNewRound() {
+        let newRoundNumber = (rounds.last?.number ?? 0) + 1
+        let newRound = League.Round(id: "", number: newRoundNumber, score: 0, createdAt: Timestamp(date: Date()))
+        addRoundToLeague(leagueId: league.id, round: newRound)
+    }
+    
+    private func addRoundToLeague(leagueId: String, round: League.Round) {
+        let roundData: [String: Any] = [
+            "number": round.number,
+            "score": round.score,
+            "createdAt": round.createdAt
+        ]
+        
+        let db = Firestore.firestore()
+        db.collection("leagues")
+            .document(leagueId)
+            .collection("rounds")
+            .addDocument(data: roundData) { error in
+                if let error = error {
+                    print("Error adding round: \(error.localizedDescription)")
+                } else {
+                    print("Round added successfully!")
+                    fetchRounds() // Refresh rounds after adding.
+                }
+            }
+    }
+}
+
+// Date formatter for displaying round creation dates.
+private let dateFormatter: DateFormatter = {
+    let formatter = DateFormatter()
+    formatter.dateStyle = .short
+    formatter.timeStyle = .short
+    return formatter
+}()
+
+struct LeagueDetailView_Previews: PreviewProvider {
+    static var previews: some View {
+        LeagueDetailView(league: League(id: "1",
+                                          name: "Golf League",
+                                          hostUserId: "user123",
+                                          members: ["user123", "user456"],
+                                          course: "Course A",
+                                          schedule: "Weekly",
+                                          createdAt: Timestamp(date: Date())))
+    }
+}
diff --git a/Aldo/Views/LeagueService.swift b/Aldo/Views/LeagueService.swift
new file mode 100644
index 0000000..450cc55
--- /dev/null
+++ b/Aldo/Views/LeagueService.swift
@@ -0,0 +1,121 @@
+import FirebaseFirestore
+
+class LeagueService {
+    static let shared = LeagueService()
+    private let db = Firestore.firestore()
+
+    // MARK: - Check if League Name is Unique
+    func isLeagueNameUnique(name: String, completion: @escaping (Bool) -> Void) {
+        let leaguesRef = db.collection("leagues")
+        
+        leaguesRef.whereField("name", isEqualTo: name).getDocuments { snapshot, error in
+            if let error = error {
+                print("Error checking league name: \(error.localizedDescription)")
+                completion(false)
+                return
+            }
+            
+            if let snapshot = snapshot, snapshot.isEmpty {
+                // League name is unique
+                completion(true)
+            } else {
+                // League name already exists
+                completion(false)
+            }
+        }
+    }
+    
+    // MARK: - Create a New League (Updated to accept individual parameters)
+    func createLeague(name: String, hostUserId: String, members: [String], course: String, schedule: String, completion: @escaping (Bool) -> Void) {
+        // Create the league object
+        let league = League(name: name, hostUserId: hostUserId, members: members, course: course, schedule: schedule, createdAt: Timestamp(date: Date()))
+
+        // Check if league name is unique
+        isLeagueNameUnique(name: league.name) { isUnique in
+            if isUnique {
+                // Add the league to Firestore
+                self.db.collection("leagues").addDocument(data: league.toDictionary()) { error in
+                    if let error = error {
+                        print("Error creating league: \(error.localizedDescription)")
+                        completion(false)
+                    } else {
+                        print("League created successfully!")
+                        completion(true)
+                    }
+                }
+            } else {
+                print("League name already exists.")
+                completion(false)
+            }
+        }
+    }
+    
+    // MARK: - Add Round to League
+    func addRoundToLeague(leagueId: String, round: League.Round, completion: @escaping (Bool) -> Void) {
+        let roundData: [String: Any] = [
+            "number": round.number,
+            "score": round.score,
+            "createdAt": Timestamp(date: Date())
+        ]
+        
+        db.collection("leagues").document(leagueId).collection("rounds").addDocument(data: roundData) { error in
+            if let error = error {
+                print("Error adding round: \(error.localizedDescription)")
+                completion(false)
+            } else {
+                print("Round added successfully!")
+                completion(true)
+            }
+        }
+    }
+    
+    // MARK: - Update Scores for a Round
+    func updateScores(leagueId: String, roundId: String, score: League.Score, completion: @escaping (Bool) -> Void) {
+        let scoreData: [String: Any] = [
+            "userId": score.userId,
+            "holeScores": score.holeScores,
+            "updatedAt": Timestamp(date: Date())
+        ]
+        
+        let scoresRef = db.collection("leagues").document(leagueId).collection("rounds").document(roundId).collection("scores").document(score.id.uuidString)
+        scoresRef.setData(scoreData) { error in
+            if let error = error {
+                print("Error updating score: \(error.localizedDescription)")
+                completion(false)
+            } else {
+                print("Score updated successfully!")
+                completion(true)
+            }
+        }
+    }
+
+    // MARK: - Fetch League Data
+    func fetchLeagueData(leagueId: String, completion: @escaping (League?) -> Void) {
+        db.collection("leagues").document(leagueId).getDocument { document, error in
+            if let error = error {
+                print("Error fetching league data: \(error.localizedDescription)")
+                completion(nil)
+                return
+            }
+            
+            guard let document = document, document.exists else {
+                print("League not found")
+                completion(nil)
+                return
+            }
+            
+            // Map Firestore data to League model
+            let data = document.data()
+            let league = League(
+                id: document.documentID,
+                name: data?["name"] as? String ?? "",
+                hostUserId: data?["hostUserId"] as? String ?? "",
+                members: data?["members"] as? [String] ?? [],
+                course: data?["course"] as? String ?? "",
+                schedule: data?["schedule"] as? String ?? "",
+                createdAt: data?["createdAt"] as? Timestamp ?? Timestamp(date: Date()) // Ensure valid Timestamp
+            )
+            completion(league)
+        }
+    }
+}
diff --git a/Aldo/Views/LeagueSubmissionView.swift b/Aldo/Views/LeagueSubmissionView.swift
new file mode 100644
index 0000000..7c6fc0a
--- /dev/null
+++ b/Aldo/Views/LeagueSubmissionView.swift
@@ -0,0 +1,227 @@
+import SwiftUI
+import Firebase
+import FirebaseFirestore
+
+struct LeagueSubmissionView: View {
+    let score: Int
+    let course: String
+    let holeCount: Int
+    let steps: Int
+    let distance: Double
+    let calories: Double
+    let onSubmit: (String) -> Void
+    
+    @State private var leagues: [LeagueInfo] = []
+    @State private var selectedLeagueId: String = ""
+    @State private var isLoading = true
+    @State private var errorMessage: String? = nil
+    @Environment(\.presentationMode) var presentationMode
+    
+    var body: some View {
+        NavigationView {
+            GeometryReader { geometry in
+                VStack(spacing: 20) {
+                    Text("Submit to League")
+                        .font(.title)
+                        .fontWeight(.bold)
+                        .padding(.top)
+                    
+                    // Score summary
+                    VStack(spacing: 12) {
+                        HStack {
+                            Text("Course:")
+                                .fontWeight(.semibold)
+                            Spacer()
+                            Text(course)
+                        }
+                        
+                        HStack {
+                            Text("Score:")
+                                .fontWeight(.semibold)
+                            Spacer()
+                            Text("\(score)")
+                                .fontWeight(.bold)
+                        }
+                        
+                        HStack {
+                            Text("Holes:")
+                                .fontWeight(.semibold)
+                            Spacer()
+                            Text("\(holeCount)")
+                        }
+                        
+                        HStack {
+                            Text("Steps:")
+                                .fontWeight(.semibold)
+                            Spacer()
+                            Text("\(steps)")
+                        }
+                    }
+                    .padding()
+                    .background(Color(.systemGray6))
+                    .cornerRadius(12)
+                    .padding(.horizontal)
+                    
+                    if isLoading {
+                        ProgressView("Loading leagues...")
+                            .padding()
+                    } else if leagues.isEmpty {
+                        VStack(spacing: 15) {
+                            Text("You don't have any leagues")
+                                .font(.headline)
+                                .foregroundColor(.gray)
+                            
+                            NavigationLink(destination: CreateLeagueView()) {
+                                Text("Create a League")
+                                    .font(.headline)
+                                    .padding()
+                                    .frame(width: geometry.size.width * 0.8)
+                                    .background(Color.blue)
+                                    .foregroundColor(.white)
+                                    .cornerRadius(10)
+                            }
+                        }
+                        .padding()
+                    } else {
+                        // League picker
+                        VStack(alignment: .leading, spacing: 10) {
+                            Text("Choose a League")
+                                .font(.headline)
+                                .padding(.horizontal)
+                            
+                            Picker("Select League", selection: $selectedLeagueId) {
+                                Text("Select a league").tag("")
+                                ForEach(leagues) { league in
+                                    Text(league.name).tag(league.id)
+                                }
+                            }
+                            .pickerStyle(MenuPickerStyle())
+                            .padding()
+                            .background(Color.white)
+                            .cornerRadius(12)
+                            .shadow(radius: 2)
+                            .padding(.horizontal)
+                        }
+                        
+                        if let errorMessage = errorMessage {
+                            Text(errorMessage)
+                                .foregroundColor(.red)
+                                .padding()
+                        }
+                        
+                        Spacer()
+                        
+                        // Submit button
+                        Button(action: {
+                            if !selectedLeagueId.isEmpty {
+                                onSubmit(selectedLeagueId)
+                            }
+                        }) {
+                            Text("Submit Score")
+                                .font(.title3)
+                                .fontWeight(.bold)
+                                .foregroundColor(.white)
+                                .frame(width: geometry.size.width * 0.8)
+                                .padding(.vertical, 16)
+                                .background(selectedLeagueId.isEmpty ? Color.gray : Color.green)
+                                .cornerRadius(15)
+                        }
+                        .disabled(selectedLeagueId.isEmpty)
+                        .padding(.bottom, 30)
+                    }
+                }
+                .frame(width: geometry.size.width)
+                .onAppear {
+                    fetchUserLeagues()
+                }
+                .navigationBarItems(trailing: Button("Cancel") {
+                    presentationMode.wrappedValue.dismiss()
+                })
+            }
+        }
+    }
+    
+    private func fetchUserLeagues() {
+        guard let userId = Auth.auth().currentUser?.uid else {
+            isLoading = false
+            errorMessage = "User not signed in"
+            return
+        }
+        
+        let db = Firestore.firestore()
+        
+        // Get leagues where user is either host or member
+        db.collection("leagues")
+            .whereField("hostUserId", isEqualTo: userId)
+            .getDocuments { [self] (snapshot, error) in
+                if let error = error {
+                    print("Error fetching user's hosted leagues: \(error.localizedDescription)")
+                    self.errorMessage = "Failed to load leagues"
+                    self.isLoading = false
+                    return
+                }
+                
+                var userLeagues: [LeagueInfo] = []
+                
+                // Add hosted leagues
+                if let documents = snapshot?.documents {
+                    for document in documents {
+                        let data = document.data()
+                        let name = data["name"] as? String ?? "Unnamed League"
+                        let league = LeagueInfo(id: document.documentID, name: name)
+                        userLeagues.append(league)
+                    }
+                }
+                
+                // Also fetch leagues where user is a member
+                db.collection("leagues")
+                    .whereField("memberIds", arrayContains: userId)
+                    .getDocuments { [self] (snapshot, error) in
+                        isLoading = false
+                        
+                        if let error = error {
+                            print("Error fetching user's member leagues: \(error.localizedDescription)")
+                            errorMessage = "Failed to load leagues"
+                            return
+                        }
+                        
+                        // Add member leagues
+                        if let documents = snapshot?.documents {
+                            for document in documents {
+                                let data = document.data()
+                                let name = data["name"] as? String ?? "Unnamed League"
+                                let leagueId = document.documentID
+                                
+                                // Only add if not already added (not a host)
+                                if !userLeagues.contains(where: { $0.id == leagueId }) {
+                                    let league = LeagueInfo(id: leagueId, name: name)
+                                    userLeagues.append(league)
+                                }
+                            }
+                        }
+                        
+                        self.leagues = userLeagues
+                    }
+            }
+    }
+}
+
+// Renamed from League to LeagueInfo to avoid conflicts
+struct LeagueInfo: Identifiable {
+    let id: String
+    let name: String
+}
+
+struct LeagueSubmissionView_Previews: PreviewProvider {
+    static var previews: some View {
+        LeagueSubmissionView(
+            score: 85,
+            course: "Armitage Golf Club",
+            holeCount: 18,
+            steps: 12345,
+            distance: 5.2,
+            calories: 430,
+            onSubmit: { _ in }
+        )
+    }
+}
diff --git a/Aldo/Views/LogScoreView.swift b/Aldo/Views/LogScoreView.swift
new file mode 100644
index 0000000..4bc50e5
--- /dev/null
+++ b/Aldo/Views/LogScoreView.swift
@@ -0,0 +1,41 @@
+//
+//  LogScoreView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import SwiftUI
+
+struct LogScoreView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @State private var selectedUser: AppUser?
+    
+    var body: some View {
+        VStack {
+            Picker("Select User", selection: $selectedUser) {
+                ForEach(authManager.users) { user in
+                    Text(user.username).tag(user as AppUser?)
+                }
+            }
+            .pickerStyle(MenuPickerStyle())
+            .padding()
+            
+            if let user = selectedUser {
+                // Display user's scores or other relevant information
+                Text("Selected User: \(user.username)")
+                // Add more views to display user's scores, workout stats, etc.
+            }
+            
+            Spacer()
+        }
+        .navigationTitle("Log Score")
+    }
+}
+
+struct LogScoreView_Previews: PreviewProvider {
+    static var previews: some View {
+        LogScoreView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/LoginView.swift b/Aldo/Views/LoginView.swift
new file mode 100644
index 0000000..b7d4914
--- /dev/null
+++ b/Aldo/Views/LoginView.swift
@@ -0,0 +1,71 @@
+//
+//  LoginView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+// In LoginView.swift
+
+import SwiftUI
+
+struct LoginView: View {
+    @State private var email = ""
+    @State private var password = ""
+    @State private var errorMessage: String? = nil
+    @EnvironmentObject var authManager: AuthenticationManager
+
+    var body: some View {
+        VStack {
+            Text("Login")
+                .font(.largeTitle)
+                .padding(.bottom, 20)
+
+            TextField("Email", text: $email)
+                .padding()
+                .background(Color(.systemGray6))
+                .cornerRadius(10)
+                .padding(.bottom, 10)
+
+            SecureField("Password", text: $password)
+                .padding()
+                .background(Color(.systemGray6))
+                .cornerRadius(10)
+                .padding(.bottom, 20)
+
+            Button(action: {
+                authManager.signIn(email: email, password: password) { success, error in
+                    if success {
+                        // Handle successful login (e.g., navigate to home screen)
+                    } else {
+                        // Show error message if sign-in fails
+                        errorMessage = error ?? "Login failed. Please try again."
+                    }
+                }
+            }) {
+                Text("Sign In")
+                    .font(.title2)
+                    .padding()
+                    .frame(maxWidth: .infinity)
+                    .background(Color.blue)
+                    .foregroundColor(.white)
+                    .cornerRadius(10)
+            }
+
+            if let errorMessage = errorMessage {
+                Text(errorMessage)
+                    .foregroundColor(.red)
+                    .padding(.top, 10)
+            }
+
+            Spacer()
+        }
+        .padding()
+    }
+}
+
+struct LoginView_Previews: PreviewProvider {
+    static var previews: some View {
+        LoginView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/MainView.swift b/Aldo/Views/MainView.swift
new file mode 100644
index 0000000..62713de
--- /dev/null
+++ b/Aldo/Views/MainView.swift
@@ -0,0 +1,144 @@
+import SwiftUI
+
+struct MainView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @EnvironmentObject var networkMonitor: NetworkMonitor
+    
+    // Set a fixed size for buttons
+    let buttonWidth: CGFloat = 300
+    let buttonHeight: CGFloat = 60
+
+    var body: some View {
+        NavigationView {
+            ZStack {
+                // Background Image
+                Image("Armitage")
+                    .resizable()
+                    .scaledToFill()
+                    .edgesIgnoringSafeArea(.all)
+
+                VStack(spacing: 20) {
+                    Spacer()
+
+                    // "Play Now" button - Using EnhancedPlayNowView
+                    NavigationLink(destination: EnhancedPlayNowView()) {
+                        Text("Play Now")
+                            .font(.title2)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 12)
+                            .frame(width: buttonWidth, height: buttonHeight)
+                            .background(Color.black.opacity(0.9))
+                            .cornerRadius(10)
+                            .shadow(radius: 5)
+                    }
+
+                    // "View Activity" button
+                    NavigationLink(destination: ActivityView()) {
+                        Text("View Activity")
+                            .font(.title2)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 12)
+                            .frame(width: buttonWidth, height: buttonHeight)
+                            .background(Color.black.opacity(0.9))
+                            .cornerRadius(10)
+                            .shadow(radius: 5)
+                    }
+
+                    // "View Friends" button
+                    NavigationLink(destination: FriendsListView()) {
+                        Text("View Friends")
+                            .font(.title2)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 12)
+                            .frame(width: buttonWidth, height: buttonHeight)
+                            .background(Color.black.opacity(0.9))
+                            .cornerRadius(10)
+                            .shadow(radius: 5)
+                    }
+
+                    // "View Profile" button
+                    NavigationLink(destination: ProfileView()) {
+                        Text("View Profile")
+                            .font(.title2)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 12)
+                            .frame(width: buttonWidth, height: buttonHeight)
+                            .background(Color.black.opacity(0.9))
+                            .cornerRadius(10)
+                            .shadow(radius: 5)
+                    }
+
+                    // "League Play" button
+                    NavigationLink(destination: LeaguePlayView()) {
+                        Text("League Play")
+                            .font(.title2)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 12)
+                            .frame(width: buttonWidth, height: buttonHeight)
+                            .background(Color.black.opacity(0.9))
+                            .cornerRadius(10)
+                            .shadow(radius: 5)
+                    }
+
+                    // "Log Out" button
+                    Button(action: {
+                        authManager.logout()
+                    }) {
+                        Text("Log Out")
+                            .font(.title2)
+                            .fontWeight(.bold)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 12)
+                            .frame(width: buttonWidth, height: buttonHeight)
+                            .background(Color.red.opacity(0.7))
+                            .cornerRadius(10)
+                            .shadow(radius: 5)
+                    }
+
+                    Spacer() // To ensure buttons are positioned towards the top
+
+                }
+                .padding(.horizontal, 20)
+            }
+        }
+    }
+}
+
+struct LeaguePlayView: View {
+    var body: some View {
+        VStack(spacing: 20) {
+            Text("Choose an option to proceed")
+                .font(.title)
+                .fontWeight(.bold)
+                .padding(.top, 50)
+            
+            // "Create a League" button
+            NavigationLink("Create a League", destination: CreateLeagueView())
+                .font(.title2)
+                .frame(maxWidth: .infinity)
+                .padding()
+                .background(Color.green)
+                .foregroundColor(.black)
+                .cornerRadius(10)
+                .shadow(radius: 5)
+
+            // "Search Leagues" button
+            NavigationLink("Search for a League", destination: SearchLeaguesView())
+                .font(.title2)
+                .frame(maxWidth: .infinity)
+                .padding()
+                .background(Color.black)
+                .foregroundColor(.white)
+                .cornerRadius(10)
+                .shadow(radius: 5)
+
+            Spacer()
+        }
+        .padding()
+    }
+}
diff --git a/Aldo/Views/PhoneVerificationView.swift b/Aldo/Views/PhoneVerificationView.swift
new file mode 100644
index 0000000..b5240e5
--- /dev/null
+++ b/Aldo/Views/PhoneVerificationView.swift
@@ -0,0 +1,150 @@
+//
+//  PhoneVerificationView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/24/24.
+//
+
+import SwiftUI
+import Firebase
+
+struct PhoneVerificationView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @Environment(\.presentationMode) var presentationMode
+    
+    @State private var phoneNumber: String = ""
+    @State private var verificationCode: String = ""
+    @State private var isVerificationSent = false
+    @State private var errorMessage: String? = nil
+    @State private var isLoading = false
+    
+    var body: some View {
+        VStack(spacing: 20) {
+            Text("Phone Verification")
+                .font(.largeTitle)
+                .fontWeight(.bold)
+                .padding(.bottom, 20)
+            
+            if !isVerificationSent {
+                // Phone number input
+                TextField("Phone Number", text: $phoneNumber)
+                    .keyboardType(.phonePad)
+                    .padding()
+                    .background(Color(.systemGray6))
+                    .cornerRadius(10)
+                    .padding(.horizontal)
+                
+                Button(action: sendVerificationCode) {
+                    if isLoading {
+                        ProgressView()
+                            .progressViewStyle(CircularProgressViewStyle())
+                    } else {
+                        Text("Send Verification Code")
+                            .fontWeight(.semibold)
+                            .foregroundColor(.white)
+                            .padding()
+                            .frame(maxWidth: .infinity)
+                    }
+                }
+                .background(isLoading ? Color.gray : Color.blue)
+                .cornerRadius(10)
+                .padding(.horizontal)
+                .disabled(isLoading || phoneNumber.isEmpty)
+            } else {
+                // Verification code input
+                TextField("Verification Code", text: $verificationCode)
+                    .keyboardType(.numberPad)
+                    .padding()
+                    .background(Color(.systemGray6))
+                    .cornerRadius(10)
+                    .padding(.horizontal)
+                
+                Button(action: verifyCode) {
+                    if isLoading {
+                        ProgressView()
+                            .progressViewStyle(CircularProgressViewStyle())
+                    } else {
+                        Text("Verify Code")
+                            .fontWeight(.semibold)
+                            .foregroundColor(.white)
+                            .padding()
+                            .frame(maxWidth: .infinity)
+                    }
+                }
+                .background(isLoading ? Color.gray : Color.green)
+                .cornerRadius(10)
+                .padding(.horizontal)
+                .disabled(isLoading || verificationCode.isEmpty)
+                
+                Button(action: {
+                    isVerificationSent = false
+                    errorMessage = nil
+                }) {
+                    Text("Change Phone Number")
+                        .foregroundColor(.blue)
+                        .padding(.top)
+                }
+            }
+            
+            if let errorMessage = errorMessage {
+                Text(errorMessage)
+                    .foregroundColor(.red)
+                    .padding()
+            }
+            
+            Spacer()
+        }
+        .padding()
+    }
+    
+    private func sendVerificationCode() {
+        isLoading = true
+        errorMessage = nil
+        
+        // Format phone number to E.164 standard if needed
+        let formattedNumber = formatPhoneNumber(phoneNumber)
+        
+        authManager.sendVerificationCode(to: formattedNumber) { success, error in
+            isLoading = false
+            
+            if success {
+                isVerificationSent = true
+            } else {
+                errorMessage = error ?? "Failed to send verification code. Please try again."
+            }
+        }
+    }
+    
+    private func verifyCode() {
+        isLoading = true
+        errorMessage = nil
+        
+        authManager.verifyCode(code: verificationCode) { success, error in
+            isLoading = false
+            
+            if success {
+                presentationMode.wrappedValue.dismiss()
+            } else {
+                errorMessage = error ?? "Invalid verification code. Please try again."
+            }
+        }
+    }
+    
+    private func formatPhoneNumber(_ number: String) -> String {
+        // Simple formatting - ensure it starts with "+" if not already
+        if number.hasPrefix("+") {
+            return number
+        } else if number.hasPrefix("1") {
+            return "+\(number)"
+        } else {
+            return "+1\(number)" // Default to US code
+        }
+    }
+}
+
+struct PhoneVerificationView_Previews: PreviewProvider {
+    static var previews: some View {
+        PhoneVerificationView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/ProfileView.swift b/Aldo/Views/ProfileView.swift
new file mode 100644
index 0000000..55994a0
--- /dev/null
+++ b/Aldo/Views/ProfileView.swift
@@ -0,0 +1,457 @@
+//
+//  ProfileView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 3/4/25.
+//
+
+
+import SwiftUI
+import Firebase
+
+struct ProfileView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @State private var showingEditView = false
+    
+    var body: some View {
+        ScrollView {
+            VStack(spacing: 20) {
+                // Profile Header
+                VStack {
+                    // Profile picture
+                    if let user = authManager.currentUser, let profilePicture = user.profilePicture, 
+                       let url = URL(string: profilePicture) {
+                        CachedAsyncImage(url: url) { image in
+                            image
+                                .resizable()
+                                .aspectRatio(contentMode: .fill)
+                                .frame(width: 120, height: 120)
+                                .clipShape(Circle())
+                                .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                                .shadow(radius: 5)
+                        } placeholder: {
+                            ProgressView()
+                                .frame(width: 120, height: 120)
+                        }
+                    } else {
+                        Image(systemName: "person.circle.fill")
+                            .resizable()
+                            .scaledToFit()
+                            .frame(width: 120, height: 120)
+                            .foregroundColor(.gray)
+                    }
+                    
+                    // Username and basic info
+                    if let user = authManager.currentUser {
+                        Text(user.username)
+                            .font(.title)
+                            .fontWeight(.bold)
+                            .padding(.top, 8)
+                        
+                        Text(user.email)
+                            .font(.subheadline)
+                            .foregroundColor(.gray)
+                        
+                        if !user.bio.isEmpty {
+                            Text(user.bio)
+                                .font(.body)
+                                .multilineTextAlignment(.center)
+                                .padding(.horizontal)
+                                .padding(.top, 4)
+                        }
+                    }
+                    
+                    // Edit profile button
+                    Button(action: {
+                        showingEditView = true
+                    }) {
+                        Text("Edit Profile")
+                            .font(.headline)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 8)
+                            .padding(.horizontal, 20)
+                            .background(Color.blue)
+                            .cornerRadius(20)
+                    }
+                    .padding(.top, 8)
+                }
+                .padding()
+                .background(Color.white)
+                .cornerRadius(12)
+                .shadow(radius: 3)
+                .padding(.horizontal)
+                
+                // Stats Section
+                VStack(alignment: .leading, spacing: 16) {
+                    Text("Your Stats")
+                        .font(.title2)
+                        .fontWeight(.bold)
+                        .padding(.horizontal)
+                    
+                    if let user = authManager.currentUser {
+                        // Total Rounds
+                        StatCardView(
+                            icon: "flag.fill",
+                            title: "Total Rounds",
+                            value: "\(user.scores.count)",
+                            color: .green
+                        )
+                        
+                        // Best Score
+                        StatCardView(
+                            icon: "trophy.fill",
+                            title: "Best Score",
+                            value: getBestScore(user),
+                            color: .orange
+                        )
+                        
+                        // Total Steps
+                        StatCardView(
+                            icon: "figure.walk",
+                            title: "Total Steps",
+                            value: getFormattedSteps(user),
+                            color: .blue
+                        )
+                    }
+                }
+                .padding(.top)
+                
+                // Recent Rounds
+                VStack(alignment: .leading, spacing: 12) {
+                    Text("Recent Rounds")
+                        .font(.title2)
+                        .fontWeight(.bold)
+                        .padding(.horizontal)
+                    
+                    if let user = authManager.currentUser, !user.scores.isEmpty {
+                        ForEach(user.scores.sorted(by: { $0.date > $1.date }).prefix(3), id: \.id) { score in
+                            RoundCardView(score: score)
+                        }
+                        
+                        Button(action: {
+                            // Navigate to full history view
+                        }) {
+                            Text("View All Rounds")
+                                .font(.headline)
+                                .foregroundColor(.blue)
+                                .padding()
+                                .frame(maxWidth: .infinity)
+                                .background(Color.blue.opacity(0.1))
+                                .cornerRadius(10)
+                        }
+                        .padding(.horizontal)
+                    } else {
+                        Text("No rounds recorded yet")
+                            .foregroundColor(.gray)
+                            .italic()
+                            .padding()
+                    }
+                }
+                .padding(.top)
+                
+                // Log out button
+                Button(action: {
+                    authManager.logout()
+                }) {
+                    Text("Log Out")
+                        .font(.headline)
+                        .foregroundColor(.white)
+                        .padding()
+                        .frame(maxWidth: .infinity)
+                        .background(Color.red)
+                        .cornerRadius(10)
+                        .padding(.horizontal)
+                }
+                .padding(.top, 20)
+                .padding(.bottom, 40)
+            }
+        }
+        .navigationTitle("Profile")
+        .sheet(isPresented: $showingEditView) {
+            ProfileEditView()
+        }
+    }
+    
+    // Helper function to get best score
+    private func getBestScore(_ user: Models.User) -> String {
+        if user.scores.isEmpty {
+            return "N/A"
+        }
+        
+        if let bestScore = user.scores.min(by: { $0.score < $1.score }) {
+            return "\(bestScore.score) at \(bestScore.course)"
+        }
+        
+        return "N/A"
+    }
+    
+    // Helper function to format total steps
+    private func getFormattedSteps(_ user: Models.User) -> String {
+        let totalSteps = user.scores.compactMap { $0.steps }.reduce(0, +)
+        
+        let formatter = NumberFormatter()
+        formatter.numberStyle = .decimal
+        
+        if let formattedSteps = formatter.string(from: NSNumber(value: totalSteps)) {
+            return formattedSteps
+        }
+        
+        return "\(totalSteps)"
+    }
+}
+
+struct StatCardView: View {
+    let icon: String
+    let title: String
+    let value: String
+    let color: Color
+    
+    var body: some View {
+        HStack(spacing: 16) {
+            Image(systemName: icon)
+                .font(.title)
+                .foregroundColor(color)
+                .frame(width: 40)
+            
+            VStack(alignment: .leading) {
+                Text(title)
+                    .font(.headline)
+                    .foregroundColor(.gray)
+                
+                Text(value)
+                    .font(.title3)
+                    .fontWeight(.bold)
+            }
+            
+            Spacer()
+        }
+        .padding()
+        .background(Color.white)
+        .cornerRadius(12)
+        .shadow(radius: 2)
+        .padding(.horizontal)
+    }
+}
+
+struct RoundCardView: View {
+    let score: Models.User.Score
+    
+    var body: some View {
+        HStack {
+            VStack(alignment: .leading, spacing: 4) {
+                Text(score.course)
+                    .font(.headline)
+                
+                Text(formattedDate(score.date))
+                    .font(.subheadline)
+                    .foregroundColor(.gray)
+            }
+            
+            Spacer()
+            
+            VStack(alignment: .trailing, spacing: 4) {
+                Text("\(score.score)")
+                    .font(.title2)
+                    .fontWeight(.bold)
+                
+                Text(score.holesPlayed)
+                    .font(.caption)
+                    .foregroundColor(.gray)
+            }
+        }
+        .padding()
+        .background(Color.white)
+        .cornerRadius(10)
+        .shadow(radius: 2)
+        .padding(.horizontal)
+    }
+    
+    private func formattedDate(_ date: Date) -> String {
+        let formatter = DateFormatter()
+        formatter.dateStyle = .medium
+        formatter.timeStyle = .none
+        return formatter.string(from: date)
+    }
+}
+
+struct ProfileEditView: View {
+    @Environment(\.presentationMode) var presentationMode
+    @EnvironmentObject var authManager: AuthenticationManager
+    
+    @State private var username: String = ""
+    @State private var firstName: String = ""
+    @State private var lastName: String = ""
+    @State private var bio: String = ""
+    @State private var location: String = ""
+    @State private var profileImage: UIImage? = nil
+    @State private var showImagePicker = false
+    @State private var isLoading = false
+    @State private var showAlert = false
+    @State private var alertMessage = ""
+    
+    var body: some View {
+        NavigationView {
+            Form {
+                // Profile Image Section
+                Section {
+                    VStack {
+                        if let profileImage = profileImage {
+                            Image(uiImage: profileImage)
+                                .resizable()
+                                .scaledToFill()
+                                .frame(width: 120, height: 120)
+                                .clipShape(Circle())
+                                .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                        } else if let user = authManager.currentUser, let profilePicture = user.profilePicture,
+                                  let url = URL(string: profilePicture) {
+                            CachedAsyncImage(url: url) { image in
+                                image
+                                    .resizable()
+                                    .aspectRatio(contentMode: .fill)
+                                    .frame(width: 120, height: 120)
+                                    .clipShape(Circle())
+                                    .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                            } placeholder: {
+                                ProgressView()
+                                    .frame(width: 120, height: 120)
+                            }
+                        } else {
+                            Image(systemName: "person.circle.fill")
+                                .resizable()
+                                .scaledToFit()
+                                .frame(width: 120, height: 120)
+                                .foregroundColor(.gray)
+                        }
+                        
+                        Button("Change Photo") {
+                            showImagePicker = true
+                        }
+                        .padding(.top, 8)
+                    }
+                    .frame(maxWidth: .infinity)
+                    .padding(.vertical)
+                }
+                
+                // Basic Info Section
+                Section(header: Text("Basic Information")) {
+                    TextField("Username", text: $username)
+                    TextField("First Name", text: $firstName)
+                    TextField("Last Name", text: $lastName)
+                }
+                
+                // Bio Section
+                Section(header: Text("About You")) {
+                    TextEditor(text: $bio)
+                        .frame(height: 100)
+                    
+                    TextField("Location", text: $location)
+                }
+                
+                // Save Button
+                Section {
+                    Button(action: saveChanges) {
+                        if isLoading {
+                            ProgressView()
+                                .frame(maxWidth: .infinity)
+                        } else {
+                            Text("Save Changes")
+                                .frame(maxWidth: .infinity)
+                                .foregroundColor(.white)
+                        }
+                    }
+                    .padding()
+                    .background(isLoading ? Color.gray : Color.blue)
+                    .cornerRadius(10)
+                    .disabled(isLoading)
+                }
+            }
+            .navigationTitle("Edit Profile")
+            .navigationBarItems(leading: Button("Cancel") {
+                presentationMode.wrappedValue.dismiss()
+            })
+            .onAppear(perform: loadUserData)
+            .sheet(isPresented: $showImagePicker) {
+                ImagePicker(image: $profileImage)
+            }
+            .alert(isPresented: $showAlert) {
+                Alert(title: Text("Profile Update"), message: Text(alertMessage), dismissButton: .default(Text("OK")) {
+                    if alertMessage.contains("Success") {
+                        presentationMode.wrappedValue.dismiss()
+                    }
+                })
+            }
+        }
+    }
+    
+    private func loadUserData() {
+        guard let user = authManager.currentUser else { return }
+        
+        username = user.username
+        firstName = user.firstName
+        lastName = user.lastName
+        bio = user.bio
+        location = user.location
+    }
+    
+    private func saveChanges() {
+        guard let user = authManager.currentUser else {
+            alertMessage = "User data not available"
+            showAlert = true
+            return
+        }
+        
+        isLoading = true
+        
+        // First handle profile image update if needed
+        if let newImage = profileImage {
+            UserService.shared.updateProfilePicture(image: newImage) { result in
+                switch result {
+                case .success(let imageURL):
+                    // Now update the rest of user info
+                    updateUserInfo(user: user, profilePictureURL: imageURL)
+                    
+                case .failure(let error):
+                    isLoading = false
+                    alertMessage = "Failed to update profile picture: \(error.localizedDescription)"
+                    showAlert = true
+                }
+            }
+        } else {
+            // Just update user info
+            updateUserInfo(user: user, profilePictureURL: user.profilePicture)
+        }
+    }
+    
+    private func updateUserInfo(user: Models.User, profilePictureURL: String?) {
+        // Create updated user model
+        var updatedUser = user
+        updatedUser.username = username
+        updatedUser.firstName = firstName
+        updatedUser.lastName = lastName
+        updatedUser.bio = bio
+        updatedUser.location = location
+        updatedUser.profilePicture = profilePictureURL
+        
+        // Save to Firestore
+        UserService.shared.updateUser(userData: updatedUser) { result in
+            isLoading = false
+            
+            switch result {
+            case .success:
+                alertMessage = "Profile updated successfully!"
+                showAlert = true
+                
+            case .failure(let error):
+                alertMessage = "Failed to update profile: \(error.localizedDescription)"
+                showAlert = true
+            }
+        }
+    }
+}
+
+struct ProfileView_Previews: PreviewProvider {
+    static var previews: some View {
+        ProfileView()
+            .environmentObject(AuthenticationManager())
+    }
+}
\ No newline at end of file
diff --git a/Aldo/Views/Score.swift b/Aldo/Views/Score.swift
new file mode 100644
index 0000000..09fb972
--- /dev/null
+++ b/Aldo/Views/Score.swift
@@ -0,0 +1,15 @@
+//
+//  Score.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 1/26/25.
+//
+
+
+import Foundation
+
+struct Score: Identifiable {
+    var id: String
+    var userId: String
+    var holeScores: [Int]  // Array to hold scores for each hole (or whatever structure you want)
+}
diff --git a/Aldo/Views/ScoreEntryView.swift b/Aldo/Views/ScoreEntryView.swift
new file mode 100644
index 0000000..242ef79
--- /dev/null
+++ b/Aldo/Views/ScoreEntryView.swift
@@ -0,0 +1,267 @@
+//
+//  ScoreEntryView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+
+import SwiftUI
+import FirebaseFirestore
+import FirebaseAuth
+
+struct ScoreEntryView: View {
+    @State private var scores: [Int] = Array(repeating: 0, count: 18)
+    @State private var selectedCourse = ""
+    @State private var courses = ["Armitage", "Rich Valley", "Range End", "Cumberland", "Mayapple", "Dauphin Highlands"]
+    @State private var playNineHoles = false
+    @State private var frontNine = true
+    @State private var totalScore: Int = 0
+    @State private var username: String = "" // Username will be pulled automatically
+    @State private var showAlert = false
+    @State private var alertMessage = ""
+    @State private var isPressed = false // For button animation
+    
+    @EnvironmentObject var workoutManager: iOSWorkoutManager
+    @EnvironmentObject var networkMonitor: NetworkMonitor
+
+    private var loggedInUsername: String {
+        Auth.auth().currentUser?.displayName ?? "Guest"
+    }
+
+    var body: some View {
+        NavigationView {
+            VStack {
+                // Network status indicator
+                if !networkMonitor.isConnected {
+                    HStack {
+                        Image(systemName: "wifi.slash")
+                        Text("Offline Mode - Score will be saved locally")
+                    }
+                    .font(.footnote)
+                    .foregroundColor(.white)
+                    .padding(8)
+                    .background(Color.orange)
+                    .cornerRadius(8)
+                    .padding(.horizontal)
+                }
+                
+                workoutStatsSection
+
+                Picker("Select Course", selection: $selectedCourse) {
+                    ForEach(courses, id: \.self) { course in
+                        Text(course)
+                    }
+                }
+                .pickerStyle(MenuPickerStyle())
+                .padding()
+
+                if playNineHoles {
+                    Picker("Select Front or Back Nine", selection: $frontNine) {
+                        Text("Front Nine").tag(true)
+                        Text("Back Nine").tag(false)
+                    }
+                    .pickerStyle(SegmentedPickerStyle())
+                    .padding()
+                }
+
+                VStack(alignment: .leading, spacing: 10) {
+                    Text("Quick Entry")
+                        .font(.headline)
+
+                    HStack {
+                        Text("Total Score: \(totalScore)")
+                            .font(.title2)
+                            .padding()
+
+                        Button(action: submitQuickScore) {
+                            Text("Submit")
+                                .font(.title3)
+                                .foregroundColor(.white)
+                                .padding()
+                                .background(Color.blue)
+                                .cornerRadius(8)
+                        }
+                    }
+
+                    Text("Logged in as: \(loggedInUsername)")
+                        .font(.footnote)
+                        .padding(.top, 5)
+                }
+                .padding()
+
+                let holes = determineHolesToPlay()
+
+                List {
+                    ForEach(holes, id: \.self) { hole in
+                        NavigationLink(
+                            destination: IndividualHoleView(
+                                score: $scores[hole],
+                                holeNumber: hole + 1,
+                                totalHoles: playNineHoles ? 9 : 18,
+                                workoutManager: workoutManager
+                            )
+                        ) {
+                            HStack {
+                                Text("Hole \(hole + 1)")
+                                Spacer()
+                                Text("\(scores[hole])")
+                            }
+                        }
+                    }
+                }
+                .listStyle(InsetGroupedListStyle())
+
+                if scores.filter({ $0 == 0 }).isEmpty {
+                    submitButton
+                        .transition(.move(edge: .bottom))
+                        .animation(.spring(), value: scores)
+                }
+            }
+            .alert(isPresented: $showAlert) {
+                Alert(title: Text("Submission Status"), message: Text(alertMessage), dismissButton: .default(Text("OK")))
+            }
+            .navigationTitle("Enter Scores")
+            .navigationBarTitleDisplayMode(.inline)
+            .onChange(of: scores) { _ in
+                updateTotalScore()
+            }
+        }
+        .onAppear {
+            username = loggedInUsername
+        }
+    }
+
+    private var workoutStatsSection: some View {
+        VStack(alignment: .leading, spacing: 5) {
+            Text("Workout Stats")
+                .font(.headline)
+            Text("Steps: \(workoutManager.steps)")
+            Text("Distance: \(String(format: "%.2f miles", workoutManager.distance))")
+            Text("Calories: \(String(format: "%.0f kcal", workoutManager.caloriesBurned))")
+        }
+        .padding()
+        .background(Color(.systemGray6))
+        .cornerRadius(10)
+        .padding([.leading, .trailing, .top])
+    }
+
+    private var submitButton: some View {
+        Button(action: submitScores) {
+            Text("Submit Scores/Workout")
+                .font(.title2)
+                .foregroundColor(.white)
+                .padding()
+                .frame(maxWidth: .infinity)
+                .background(LinearGradient(gradient: Gradient(colors: [.green, .blue]), startPoint: .topLeading, endPoint: .bottomTrailing))
+                .cornerRadius(15)
+                .shadow(radius: 10)
+                .scaleEffect(isPressed ? 0.95 : 1.0)
+                .animation(.easeInOut, value: isPressed)
+        }
+        .padding()
+        .onTapGesture {
+            isPressed.toggle()
+        }
+    }
+
+    private func determineHolesToPlay() -> Range<Int> {
+        if playNineHoles {
+            return frontNine ? 0..<9 : 9..<18
+        }
+        return 0..<18
+    }
+
+    private func updateTotalScore() {
+        totalScore = scores.reduce(0, +)
+    }
+
+    private func submitScores() {
+        let scoreEntry = createScoreEntry()
+        
+        if networkMonitor.isConnected {
+            saveScoreEntryToFirestore(scoreEntry: scoreEntry)
+        } else {
+            saveScoreEntryOffline(scoreEntry: scoreEntry)
+        }
+    }
+
+    private func submitQuickScore() {
+        let scoreEntry = createScoreEntry()
+        
+        if networkMonitor.isConnected {
+            saveScoreEntryToFirestore(scoreEntry: scoreEntry)
+        } else {
+            saveScoreEntryOffline(scoreEntry: scoreEntry)
+        }
+    }
+    
+    private func createScoreEntry() -> Models.User.Score {
+        return Models.User.Score(
+            id: UUID().uuidString,
+            course: selectedCourse,
+            score: totalScore,
+            date: Date(),
+            holesPlayed: playNineHoles ? (frontNine ? "Front Nine" : "Back Nine") : "18 Holes",
+            steps: workoutManager.steps,
+            distance: workoutManager.distance,
+            caloriesBurned: workoutManager.caloriesBurned
+        )
+    }
+
+    private func saveScoreEntryToFirestore(scoreEntry: Models.User.Score) {
+        guard let currentUser = Auth.auth().currentUser?.uid else {
+            alertMessage = "User not authenticated"
+            showAlert = true
+            return
+        }
+        
+        UserService.shared.addScore(score: scoreEntry) { result in
+            switch result {
+            case .success:
+                alertMessage = "Score successfully saved to your profile!"
+                showAlert = true
+                resetForm()
+            case .failure(let error):
+                alertMessage = "Error saving score: \(error.localizedDescription)"
+                showAlert = true
+            }
+        }
+    }
+    
+    private func saveScoreEntryOffline(scoreEntry: Models.User.Score) {
+        guard let userId = Auth.auth().currentUser?.uid else {
+            alertMessage = "User not authenticated"
+            showAlert = true
+            return
+        }
+        
+        FirestoreManager.shared.saveScoreOffline(score: scoreEntry, userId: userId) { result in
+            switch result {
+            case .success:
+                alertMessage = "Score saved offline! It will sync when you're back online."
+                showAlert = true
+                resetForm()
+            case .failure(let error):
+                alertMessage = "Error saving offline: \(error.localizedDescription)"
+                showAlert = true
+            }
+        }
+    }
+    
+    private func resetForm() {
+        scores = Array(repeating: 0, count: 18)
+        totalScore = 0
+        selectedCourse = courses.first ?? ""
+        playNineHoles = false
+        frontNine = true
+    }
+}
+
+struct ScoreEntryView_Previews: PreviewProvider {
+    static var previews: some View {
+        ScoreEntryView()
+            .environmentObject(iOSWorkoutManager()) // Provide a mock environment object for previews
+            .environmentObject(NetworkMonitor()) // Provide network monitor
+    }
+}
diff --git a/Aldo/Views/ScoreService.swift b/Aldo/Views/ScoreService.swift
new file mode 100644
index 0000000..4a2ffc9
--- /dev/null
+++ b/Aldo/Views/ScoreService.swift
@@ -0,0 +1,32 @@
+//
+//  ScoreService.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 1/26/25.
+//
+
+import FirebaseFirestore
+
+class ScoreService {
+    static let shared = ScoreService()
+    private let db = Firestore.firestore()
+    
+    func updateScores(leagueId: String, roundId: String, score: Score, completion: @escaping (Bool) -> Void) {
+        // Reference to Firestore document for the score
+        let scoresRef = db.collection("leagues").document(leagueId).collection("rounds").document(roundId).collection("scores").document(score.id)
+        
+        // Set the data for the score
+        scoresRef.setData([
+            "userId": score.userId,
+            "holeScores": score.holeScores
+        ]) { error in
+            if let error = error {
+                print("Error updating score: \(error.localizedDescription)")
+                completion(false)
+            } else {
+                print("Score updated successfully!")
+                completion(true)
+            }
+        }
+    }
+}
diff --git a/Aldo/Views/SearchLeaguesView.swift b/Aldo/Views/SearchLeaguesView.swift
new file mode 100644
index 0000000..882c655
--- /dev/null
+++ b/Aldo/Views/SearchLeaguesView.swift
@@ -0,0 +1,29 @@
+//
+//  SearchLeaguesView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 1/26/25.
+//
+
+import SwiftUI
+
+struct SearchLeaguesView: View {
+    @State private var leagueIdString: String = "" // The league ID as String
+    @State private var leagueId: UUID? // The league ID as UUID
+    
+    var body: some View {
+        VStack {
+            TextField("Enter League Name", text: $leagueIdString)
+                .padding()
+            
+            Button("Search League") {
+                if let uuid = UUID(uuidString: leagueIdString) {
+                    leagueId = uuid
+                    // Proceed with the logic using the UUID
+                } else {
+                    print("Invalid UUID format")
+                }
+            }
+        }
+    }
+}
diff --git a/Aldo/Views/SettingsView.swift b/Aldo/Views/SettingsView.swift
new file mode 100644
index 0000000..810dc43
--- /dev/null
+++ b/Aldo/Views/SettingsView.swift
@@ -0,0 +1,367 @@
+//
+//  SettingsView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+import SwiftUI
+import Firebase
+import FirebaseStorage
+
+struct SettingsView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    
+    // User data fields
+    @State private var username: String = ""
+    @State private var firstName: String = ""
+    @State private var lastName: String = ""
+    @State private var email: String = ""
+    @State private var phoneNumber: String = ""
+    @State private var bio: String = ""
+    @State private var location: String = ""
+    @State private var profilePicture: UIImage? = nil
+    @State private var notificationsEnabled: Bool = true
+    @State private var selectedLanguage: String = "English"
+    @State private var newPassword: String = ""
+    
+    // UI States
+    @State private var showImagePicker = false
+    @State private var showAlert = false
+    @State private var alertTitle: String = ""
+    @State private var alertMessage: String = ""
+    @State private var isLoading: Bool = false
+    @State private var hasChanges: Bool = false
+    
+    // List of prohibited words
+    let prohibitedWords = ["badword1", "badword2"] // Replace with actual list of prohibited words
+    
+    // Language options
+    let languages = ["English", "Spanish", "French", "German"]
+    
+    var body: some View {
+        NavigationView {
+            Form {
+                // Profile Picture Section
+                Section(header: Text("Profile Picture")) {
+                    VStack {
+                        if let profilePicture = profilePicture {
+                            Image(uiImage: profilePicture)
+                                .resizable()
+                                .aspectRatio(contentMode: .fill)
+                                .frame(width: 120, height: 120)
+                                .clipShape(Circle())
+                                .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                                .shadow(radius: 5)
+                                .padding()
+                        } else if let user = authManager.currentUser, let urlString = user.profilePicture, let url = URL(string: urlString) {
+                            AsyncImage(url: url) { image in
+                                image
+                                    .resizable()
+                                    .aspectRatio(contentMode: .fill)
+                                    .frame(width: 120, height: 120)
+                                    .clipShape(Circle())
+                                    .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                                    .shadow(radius: 5)
+                                    .padding()
+                            } placeholder: {
+                                ProgressView()
+                                    .frame(width: 120, height: 120)
+                                    .padding()
+                            }
+                        } else {
+                            Image(systemName: "person.circle.fill")
+                                .resizable()
+                                .scaledToFit()
+                                .frame(width: 120, height: 120)
+                                .foregroundColor(.gray)
+                                .padding()
+                        }
+
+                        Button(action: {
+                            showImagePicker = true
+                        }) {
+                            Text("Change Picture")
+                                .foregroundColor(.blue)
+                        }
+                    }
+                    .frame(maxWidth: .infinity)
+                }
+                
+                // Basic Info Section
+                Section(header: Text("Basic Information")) {
+                    TextField("Username", text: $username)
+                        .onChange(of: username) { _ in hasChanges = true }
+                    
+                    TextField("First Name", text: $firstName)
+                        .onChange(of: firstName) { _ in hasChanges = true }
+                    
+                    TextField("Last Name", text: $lastName)
+                        .onChange(of: lastName) { _ in hasChanges = true }
+                    
+                    TextField("Email", text: $email)
+                        .disabled(true) // Email is tied to authentication, so we disable it
+                    
+                    TextField("Phone Number", text: $phoneNumber)
+                        .keyboardType(.phonePad)
+                        .onChange(of: phoneNumber) { _ in hasChanges = true }
+                    
+                    TextField("Location", text: $location)
+                        .onChange(of: location) { _ in hasChanges = true }
+                }
+                
+                // Bio Section
+                Section(header: Text("About You")) {
+                    TextEditor(text: $bio)
+                        .frame(height: 100)
+                        .onChange(of: bio) { _ in hasChanges = true }
+                }
+                
+                // Password Section
+                Section(header: Text("Password")) {
+                    SecureField("New Password (leave empty to keep current)", text: $newPassword)
+                        .onChange(of: newPassword) { _ in hasChanges = true }
+                    
+                    if !newPassword.isEmpty {
+                        Text("Password must be at least 6 characters")
+                            .font(.caption)
+                            .foregroundColor(.gray)
+                    }
+                }
+                
+                // Preferences Section
+                Section(header: Text("Preferences")) {
+                    Toggle("Enable Notifications", isOn: $notificationsEnabled)
+                        .onChange(of: notificationsEnabled) { _ in hasChanges = true }
+                    
+                    Picker("Language", selection: $selectedLanguage) {
+                        ForEach(languages, id: \.self) {
+                            Text($0)
+                        }
+                    }
+                    .pickerStyle(MenuPickerStyle())
+                    .onChange(of: selectedLanguage) { _ in hasChanges = true }
+                }
+                
+                // Save Button
+                Section {
+                    Button(action: saveSettings) {
+                        if isLoading {
+                            HStack {
+                                Spacer()
+                                ProgressView()
+                                    .progressViewStyle(CircularProgressViewStyle())
+                                Spacer()
+                            }
+                        } else {
+                            Text("Save Changes")
+                                .frame(maxWidth: .infinity)
+                                .foregroundColor(.white)
+                        }
+                    }
+                    .padding()
+                    .background(hasChanges ? Color.blue : Color.gray)
+                    .cornerRadius(10)
+                    .disabled(!hasChanges || isLoading)
+                }
+            }
+            .navigationTitle("Settings")
+            .alert(isPresented: $showAlert) {
+                Alert(
+                    title: Text(alertTitle),
+                    message: Text(alertMessage),
+                    dismissButton: .default(Text("OK"))
+                )
+            }
+            .sheet(isPresented: $showImagePicker) {
+                ImagePicker(image: $profilePicture)
+                    .onDisappear {
+                        if profilePicture != nil {
+                            hasChanges = true
+                        }
+                    }
+            }
+            .onAppear(perform: loadUserData)
+        }
+    }
+    
+    // Load User Data
+    private func loadUserData() {
+        guard let user = authManager.currentUser else { return }
+        
+        username = user.username
+        firstName = user.firstName
+        lastName = user.lastName
+        email = user.email
+        phoneNumber = user.phoneNumber
+        bio = user.bio
+        location = user.location
+        notificationsEnabled = user.notificationsEnabled
+        selectedLanguage = user.selectedLanguage
+        
+        // Reset changes flag
+        hasChanges = false
+    }
+    
+    // Save Settings
+    private func saveSettings() {
+        guard validateUsername() else { return }
+        
+        isLoading = true
+        
+        // Create an updated user model
+        guard let currentUser = authManager.currentUser else {
+            handleError("User data not found")
+            return
+        }
+        
+        // Upload profile picture if changed
+        if let newImage = profilePicture {
+            uploadProfileImage(image: newImage) { result in
+                switch result {
+                case .success(let imageURL):
+                    updateUserData(currentUser, profilePictureURL: imageURL)
+                case .failure(let error):
+                    handleError("Failed to upload profile picture: \(error.localizedDescription)")
+                }
+            }
+        } else {
+            // Just update the user data without changing profile pic
+            updateUserData(currentUser, profilePictureURL: currentUser.profilePicture)
+        }
+        
+        // Update password if changed
+        if !newPassword.isEmpty {
+            updatePassword()
+        }
+    }
+    
+    // Upload profile image
+    private func uploadProfileImage(image: UIImage, completion: @escaping (Result<String, Error>) -> Void) {
+        guard let imageData = image.jpegData(compressionQuality: 0.7) else {
+            completion(.failure(NSError(domain: "SettingsView", code: 1001, userInfo: [NSLocalizedDescriptionKey: "Failed to convert image to data"])))
+            return
+        }
+        
+        let storageRef = Storage.storage().reference().child("profile_images/\(UUID().uuidString).jpg")
+        
+        storageRef.putData(imageData, metadata: nil) { _, error in
+            if let error = error {
+                completion(.failure(error))
+                return
+            }
+            
+            storageRef.downloadURL { url, error in
+                if let error = error {
+                    completion(.failure(error))
+                    return
+                }
+                
+                guard let downloadURL = url else {
+                    completion(.failure(NSError(domain: "SettingsView", code: 1002, userInfo: [NSLocalizedDescriptionKey: "Failed to get download URL"])))
+                    return
+                }
+                
+                completion(.success(downloadURL.absoluteString))
+            }
+        }
+    }
+    
+    // Update user data in Firestore
+    private func updateUserData(_ user: Models.User, profilePictureURL: String?) {
+        // Create new user with updated values
+        let updatedUser = Models.User(
+            id: user.id,
+            username: username,
+            firstName: firstName,
+            lastName: lastName,
+            email: email,
+            phoneNumber: phoneNumber,
+            bio: bio,
+            location: location,
+            friends: user.friends,
+            scores: user.scores,
+            steps: user.steps,
+            profilePicture: profilePictureURL,
+            notificationsEnabled: notificationsEnabled,
+            selectedLanguage: selectedLanguage
+        )
+        
+        guard let userId = Auth.auth().currentUser?.uid else {
+            handleError("User not authenticated")
+            return
+        }
+        
+        // Update user document in Firestore
+        let db = Firestore.firestore()
+        db.collection("users").document(userId).updateData(updatedUser.toDictionary()) { error in
+            isLoading = false
+            
+            if let error = error {
+                handleError("Failed to update profile: \(error.localizedDescription)")
+            } else {
+                // Update local user
+                authManager.currentUser = updatedUser
+                showSuccessAlert("Profile Updated", "Your profile information has been updated successfully.")
+                hasChanges = false
+            }
+        }
+    }
+    
+    // Update password
+    private func updatePassword() {
+        if newPassword.count < 6 {
+            handleError("Password must be at least 6 characters")
+            return
+        }
+        
+        Auth.auth().currentUser?.updatePassword(to: newPassword) { error in
+            if let error = error {
+                handleError("Failed to update password: \(error.localizedDescription)")
+            } else {
+                newPassword = ""
+                showSuccessAlert("Password Updated", "Your password has been updated successfully.")
+            }
+        }
+    }
+    
+    // Validate Username
+    private func validateUsername() -> Bool {
+        // Check for prohibited words
+        for word in prohibitedWords {
+            if username.lowercased().contains(word) {
+                handleError("Username contains prohibited language.")
+                return false
+            }
+        }
+        
+        // Username length check
+        if username.count < 3 {
+            handleError("Username must be at least 3 characters.")
+            return false
+        }
+        
+        return true
+    }
+    
+    // Handle Error
+    private func handleError(_ message: String) {
+        isLoading = false
+        alertTitle = "Error"
+        alertMessage = message
+        showAlert = true
+    }
+    
+    // Show Success Alert
+    private func showSuccessAlert(_ title: String, _ message: String) {
+        alertTitle = title
+        alertMessage = message
+        showAlert = true
+    }
+}
+
+struct SettingsView_Previews: PreviewProvider {
+    static var previews: some View {
+        SettingsView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/SignUpView.swift b/Aldo/Views/SignUpView.swift
new file mode 100644
index 0000000..92e7707
--- /dev/null
+++ b/Aldo/Views/SignUpView.swift
@@ -0,0 +1,338 @@
+//
+//  SignUpView.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+import SwiftUI
+import Firebase
+import FirebaseAuth
+
+struct SignUpView: View {
+    @EnvironmentObject var authManager: AuthenticationManager
+    @Environment(\.presentationMode) var presentationMode
+    
+    // User Input Fields
+    @State private var username: String = ""
+    @State private var firstName: String = ""
+    @State private var lastName: String = ""
+    @State private var email: String = ""
+    @State private var password: String = ""
+    @State private var confirmPassword: String = ""
+    @State private var phoneNumber: String = ""
+    @State private var bio: String = ""
+    @State private var location: String = ""
+    @State private var profilePicture: UIImage? = nil
+    
+    // UI States
+    @State private var showImagePicker = false
+    @State private var showError = false
+    @State private var errorMessage = ""
+    @State private var isProcessing = false
+    @State private var showSuccessAlert = false
+    
+    // Validation
+    let prohibitedWords = ["badword1", "badword2"] // Replace with actual list
+    
+    var body: some View {
+        ScrollView {
+            VStack(spacing: 20) {
+                // Header
+                Text("Create Account")
+                    .font(.largeTitle)
+                    .fontWeight(.bold)
+                    .padding(.top, 20)
+                
+                // Profile Picture Selector
+                VStack {
+                    if let profilePicture = profilePicture {
+                        Image(uiImage: profilePicture)
+                            .resizable()
+                            .scaledToFill()
+                            .frame(width: 120, height: 120)
+                            .clipShape(Circle())
+                            .overlay(Circle().stroke(Color.blue, lineWidth: 3))
+                            .shadow(radius: 5)
+                    } else {
+                        Image(systemName: "person.circle.fill")
+                            .resizable()
+                            .scaledToFit()
+                            .frame(width: 120, height: 120)
+                            .foregroundColor(.gray)
+                    }
+                    
+                    Button(action: {
+                        showImagePicker = true
+                    }) {
+                        Text("Select Profile Picture")
+                            .foregroundColor(.blue)
+                            .padding(.vertical, 8)
+                    }
+                }
+                .padding(.bottom, 10)
+                
+                // Form Fields
+                Group {
+                    CustomTextField(placeholder: "Username", text: $username, icon: "person")
+                    
+                    HStack {
+                        CustomTextField(placeholder: "First Name", text: $firstName, icon: "person.text.rectangle")
+                            .frame(maxWidth: .infinity)
+                        
+                        CustomTextField(placeholder: "Last Name", text: $lastName, icon: "person.text.rectangle")
+                            .frame(maxWidth: .infinity)
+                    }
+                    
+                    CustomTextField(placeholder: "Email", text: $email, icon: "envelope")
+                        .keyboardType(.emailAddress)
+                        .autocapitalization(.none)
+                    
+                    CustomSecureField(placeholder: "Password", text: $password, icon: "lock")
+                    
+                    CustomSecureField(placeholder: "Confirm Password", text: $confirmPassword, icon: "lock.shield")
+                    
+                    CustomTextField(placeholder: "Phone Number", text: $phoneNumber, icon: "phone")
+                        .keyboardType(.phonePad)
+                    
+                    CustomTextField(placeholder: "Location", text: $location, icon: "location")
+                    
+                    CustomTextEditor(placeholder: "Bio - Tell us about yourself", text: $bio)
+                        .frame(height: 100)
+                }
+                
+                // Error Message
+                if showError {
+                    Text(errorMessage)
+                        .font(.footnote)
+                        .foregroundColor(.red)
+                        .padding(.horizontal)
+                        .multilineTextAlignment(.center)
+                }
+                
+                // Sign Up Button
+                Button(action: signUp) {
+                    if isProcessing {
+                        ProgressView()
+                            .progressViewStyle(CircularProgressViewStyle(tint: .white))
+                            .scaleEffect(1.5)
+                            .padding(.vertical, 10)
+                    } else {
+                        Text("Create Account")
+                            .font(.headline)
+                            .foregroundColor(.white)
+                            .padding(.vertical, 10)
+                    }
+                }
+                .frame(maxWidth: .infinity)
+                .background(isProcessing ? Color.gray : Color.blue)
+                .cornerRadius(10)
+                .padding(.horizontal, 20)
+                .padding(.top, 10)
+                .disabled(isProcessing)
+                
+                // Already have an account button
+                Button(action: {
+                    presentationMode.wrappedValue.dismiss()
+                }) {
+                    Text("Already have an account? Sign In")
+                        .foregroundColor(.blue)
+                        .padding(.vertical, 10)
+                }
+            }
+            .padding()
+        }
+        .alert(isPresented: $showSuccessAlert) {
+            Alert(
+                title: Text("Account Created"),
+                message: Text("Your account has been created successfully!"),
+                dismissButton: .default(Text("OK")) {
+                    presentationMode.wrappedValue.dismiss()
+                }
+            )
+        }
+        .sheet(isPresented: $showImagePicker) {
+            ImagePicker(image: $profilePicture)
+        }
+        .onAppear {
+            // Perform any setup needed
+        }
+    }
+    
+    private func signUp() {
+        // Reset error state
+        showError = false
+        errorMessage = ""
+        
+        // Validate inputs
+        guard validateInputs() else { return }
+        
+        // Set processing state
+        isProcessing = true
+        
+        // First create the authentication account
+        Auth.auth().createUser(withEmail: email, password: password) { authResult, error in
+            if let error = error {
+                handleError(error.localizedDescription)
+                return
+            }
+            
+            guard let user = authResult?.user else {
+                handleError("Failed to create user account")
+                return
+            }
+            
+            // Now use UserService to save the full profile with image
+            UserService.shared.createUser(
+                email: email,
+                username: username,
+                firstName: firstName,
+                lastName: lastName,
+                phoneNumber: phoneNumber,
+                bio: bio,
+                location: location,
+                profileImage: profilePicture
+            ) { result in
+                isProcessing = false
+                
+                switch result {
+                case .success(let userModel):
+                    // Update the auth manager with the new user
+                    authManager.currentUser = userModel
+                    authManager.isAuthenticated = true
+                    
+                    // Show success and dismiss
+                    showSuccessAlert = true
+                    
+                case .failure(let error):
+                    // Handle error
+                    handleError(error.localizedDescription)
+                    
+                    // Since authentication was created but profile failed, we should delete the auth account
+                    user.delete { error in
+                        if let error = error {
+                            print("Failed to clean up auth account: \(error.localizedDescription)")
+                        }
+                    }
+                }
+            }
+        }
+    }
+    
+    private func validateInputs() -> Bool {
+        // Check required fields
+        if username.isEmpty || email.isEmpty || password.isEmpty || confirmPassword.isEmpty {
+            handleError("Please fill in all required fields")
+            return false
+        }
+        
+        // Validate password match
+        if password != confirmPassword {
+            handleError("Passwords do not match")
+            return false
+        }
+        
+        // Validate password length
+        if password.count < 6 {
+            handleError("Password must be at least 6 characters")
+            return false
+        }
+        
+        // Validate email format
+        if !isValidEmail(email) {
+            handleError("Please enter a valid email address")
+            return false
+        }
+        
+        // Validate username
+        for word in prohibitedWords {
+            if username.lowercased().contains(word) {
+                handleError("Username contains prohibited language")
+                return false
+            }
+        }
+        
+        return true
+    }
+    
+    private func isValidEmail(_ email: String) -> Bool {
+        let emailRegex = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
+        let emailPredicate = NSPredicate(format: "SELF MATCHES %@", emailRegex)
+        return emailPredicate.evaluate(with: email)
+    }
+    
+    private func handleError(_ message: String) {
+        isProcessing = false
+        errorMessage = message
+        showError = true
+    }
+}
+
+// MARK: - Custom Input Components
+
+struct CustomTextField: View {
+    var placeholder: String
+    @Binding var text: String
+    var icon: String
+    
+    var body: some View {
+        HStack {
+            Image(systemName: icon)
+                .foregroundColor(.gray)
+                .frame(width: 20)
+            
+            TextField(placeholder, text: $text)
+                .padding(.leading, 5)
+        }
+        .padding()
+        .background(Color(.systemGray6))
+        .cornerRadius(10)
+    }
+}
+
+struct CustomSecureField: View {
+    var placeholder: String
+    @Binding var text: String
+    var icon: String
+    
+    var body: some View {
+        HStack {
+            Image(systemName: icon)
+                .foregroundColor(.gray)
+                .frame(width: 20)
+            
+            SecureField(placeholder, text: $text)
+                .padding(.leading, 5)
+        }
+        .padding()
+        .background(Color(.systemGray6))
+        .cornerRadius(10)
+    }
+}
+
+struct CustomTextEditor: View {
+    var placeholder: String
+    @Binding var text: String
+    
+    var body: some View {
+        ZStack(alignment: .topLeading) {
+            if text.isEmpty {
+                Text(placeholder)
+                    .foregroundColor(.gray)
+                    .padding(.horizontal, 8)
+                    .padding(.vertical, 12)
+            }
+            
+            TextEditor(text: $text)
+                .padding(4)
+        }
+        .background(Color(.systemGray6))
+        .cornerRadius(10)
+    }
+}
+
+struct SignUpView_Previews: PreviewProvider {
+    static var previews: some View {
+        SignUpView()
+            .environmentObject(AuthenticationManager())
+    }
+}
diff --git a/Aldo/Views/User.swift b/Aldo/Views/User.swift
new file mode 100644
index 0000000..1a40880
--- /dev/null
+++ b/Aldo/Views/User.swift
@@ -0,0 +1,47 @@
+//
+//  User.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 2/16/25.
+//
+
+
+import Foundation
+import FirebaseFirestore
+import FirebaseFirestoreSwift
+
+struct User: Identifiable, Codable {
+    let id: String
+    var username: String
+    var firstName: String
+    var lastName: String
+    var email: String
+    var phoneNumber: String
+    var friends: [String]
+    var scores: [Score]
+    var steps: Int
+    var profilePicture: String?
+
+    struct Score: Codable, Identifiable {
+        var id: UUID = UUID()
+        let course: String
+        let score: Int
+    }
+}
+
+struct Friend: Identifiable, Codable {
+    @DocumentID var id: String?
+    var username: String
+    var profileImageURL: URL?
+    var rounds: [GolfRound]
+}
+
+struct GolfRound: Identifiable, Codable {
+    @DocumentID var id: String?
+    var course: String
+    var scores: [Int]
+    var steps: Int
+    var distance: Double
+    var caloriesBurned: Double
+    var date: Date
+}
\ No newline at end of file
diff --git a/Aldo/Views/UserService.swift b/Aldo/Views/UserService.swift
new file mode 100644
index 0000000..350af3f
--- /dev/null
+++ b/Aldo/Views/UserService.swift
@@ -0,0 +1,474 @@
+//
+//  UserService.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/12/24.
+//
+
+import Foundation
+import Firebase
+import FirebaseFirestore
+import FirebaseStorage
+import UIKit
+import Combine
+
+class UserService: ObservableObject {
+    static let shared = UserService()
+    
+    private let db = Firestore.firestore()
+    private let storage = Storage.storage()
+    
+    @Published var currentUser: Models.User?
+    @Published var isLoading = false
+    
+    // MARK: - FCM Token Management
+    
+    func saveFCMToken(_ token: String, completion: @escaping (Bool) -> Void) {
+        guard let uid = Auth.auth().currentUser?.uid else {
+            completion(false)
+            return
+        }
+        
+        let db = Firestore.firestore()
+        db.collection("users").document(uid).updateData([
+            "fcmToken": token
+        ]) { error in
+            if let error = error {
+                print("Error saving FCM token: \(error.localizedDescription)")
+                completion(false)
+            } else {
+                print("FCM token saved successfully")
+                completion(true)
+            }
+        }
+    }
+    
+    // MARK: - User Creation
+    
+    func createUser(email: String,
+                   username: String,
+                   firstName: String,
+                   lastName: String,
+                   phoneNumber: String,
+                   bio: String,
+                   location: String,
+                   profileImage: UIImage?,
+                   completion: @escaping (Result<Models.User, Error>) -> Void) {
+        
+        isLoading = true
+        
+        // First, upload profile image if it exists
+        uploadProfileImage(image: profileImage) { [weak self] result in
+            guard let self = self else { return }
+            
+            switch result {
+            case .success(let imageURL):
+                // Create user model with minimal required fields
+                let newUser = Models.User(
+                    id: "",
+                    username: username,
+                    firstName: firstName,
+                    lastName: lastName,
+                    email: email,
+                    phoneNumber: phoneNumber,
+                    bio: bio,
+                    location: location,
+                    friends: [],
+                    scores: [],
+                    steps: 0,
+                    profilePicture: imageURL
+                )
+                
+                // Save to Firestore
+                if let uid = Auth.auth().currentUser?.uid {
+                    self.db.collection("users").document(uid).setData(newUser.toDictionary()) { error in
+                        self.isLoading = false
+                        
+                        if let error = error {
+                            completion(.failure(error))
+                        } else {
+                            var savedUser = newUser
+                            // Update the ID field with the Firestore document ID
+                            savedUser = Models.User(
+                                id: uid,
+                                username: newUser.username,
+                                firstName: newUser.firstName,
+                                lastName: newUser.lastName,
+                                email: newUser.email,
+                                phoneNumber: newUser.phoneNumber,
+                                bio: newUser.bio,
+                                location: newUser.location,
+                                friends: newUser.friends,
+                                scores: newUser.scores,
+                                steps: newUser.steps,
+                                profilePicture: newUser.profilePicture,
+                                notificationsEnabled: newUser.notificationsEnabled,
+                                selectedLanguage: newUser.selectedLanguage
+                            )
+                            self.currentUser = savedUser
+                            completion(.success(savedUser))
+                        }
+                    }
+                } else {
+                    self.isLoading = false
+                    completion(.failure(NSError(domain: "UserService", code: 1001, userInfo: [NSLocalizedDescriptionKey: "User not authenticated"])))
+                }
+                
+            case .failure(let error):
+                self.isLoading = false
+                completion(.failure(error))
+            }
+        }
+    }
+    
+    // MARK: - Profile Image Handling
+    
+    func uploadProfileImage(image: UIImage?, completion: @escaping (Result<String?, Error>) -> Void) {
+        guard let image = image else {
+            // No image to upload
+            completion(.success(nil))
+            return
+        }
+        
+        guard let imageData = image.jpegData(compressionQuality: 0.75) else {
+            completion(.failure(NSError(domain: "UserService", code: 1002, userInfo: [NSLocalizedDescriptionKey: "Failed to convert image to data"])))
+            return
+        }
+        
+        // Create a unique filename
+        let imageName = UUID().uuidString + ".jpg"
+        let storageRef = storage.reference().child("profile_images/\(imageName)")
+        
+        // Upload the image
+        storageRef.putData(imageData, metadata: nil) { metadata, error in
+            if let error = error {
+                completion(.failure(error))
+                return
+            }
+            
+            // Get download URL
+            storageRef.downloadURL { url, error in
+                if let error = error {
+                    completion(.failure(error))
+                    return
+                }
+                
+                if let url = url {
+                    completion(.success(url.absoluteString))
+                } else {
+                    completion(.failure(NSError(domain: "UserService", code: 1003, userInfo: [NSLocalizedDescriptionKey: "Failed to get download URL"])))
+                }
+            }
+        }
+    }
+    
+    // MARK: - User Data Management
+    
+    func fetchCurrentUser(completion: @escaping (Result<Models.User, Error>) -> Void) {
+        guard let uid = Auth.auth().currentUser?.uid else {
+            completion(.failure(NSError(domain: "UserService", code: 1001, userInfo: [NSLocalizedDescriptionKey: "User not authenticated"])))
+            return
+        }
+        
+        isLoading = true
+        
+        db.collection("users").document(uid).getDocument { [weak self] snapshot, error in
+            guard let self = self else { return }
+            self.isLoading = false
+            
+            if let error = error {
+                completion(.failure(error))
+                return
+            }
+            
+            guard let snapshot = snapshot, snapshot.exists, let data = snapshot.data() else {
+                completion(.failure(NSError(domain: "UserService", code: 1004, userInfo: [NSLocalizedDescriptionKey: "User data not found"])))
+                return
+            }
+            
+            if let user = Models.User.fromDictionary(data, id: uid) {
+                self.currentUser = user
+                completion(.success(user))
+            } else {
+                completion(.failure(NSError(domain: "UserService", code: 1005, userInfo: [NSLocalizedDescriptionKey: "Failed to parse user data"])))
+            }
+        }
+    }
+    
+    func updateUser(userData: Models.User, completion: @escaping (Result<Models.User, Error>) -> Void) {
+        guard let uid = Auth.auth().currentUser?.uid else {
+            completion(.failure(NSError(domain: "UserService", code: 1001, userInfo: [NSLocalizedDescriptionKey: "User not authenticated"])))
+            return
+        }
+        
+        isLoading = true
+        
+        db.collection("users").document(uid).updateData(userData.toDictionary()) { [weak self] error in
+            guard let self = self else { return }
+            self.isLoading = false
+            
+            if let error = error {
+                completion(.failure(error))
+            } else {
+                self.currentUser = userData
+                completion(.success(userData))
+            }
+        }
+    }
+    
+    func updateProfilePicture(image: UIImage, completion: @escaping (Result<String, Error>) -> Void) {
+        guard let uid = Auth.auth().currentUser?.uid else {
+            completion(.failure(NSError(domain: "UserService", code: 1001, userInfo: [NSLocalizedDescriptionKey: "User not authenticated"])))
+            return
+        }
+        
+        isLoading = true
+        
+        uploadProfileImage(image: image) { [weak self] result in
+            guard let self = self else { return }
+            
+            switch result {
+            case .success(let imageURL):
+                guard let imageURL = imageURL else {
+                    self.isLoading = false
+                    completion(.failure(NSError(domain: "UserService", code: 1006, userInfo: [NSLocalizedDescriptionKey: "No image URL returned"])))
+                    return
+                }
+                
+                // Update just the profile picture URL
+                self.db.collection("users").document(uid).updateData(["profilePicture": imageURL]) { error in
+                    self.isLoading = false
+                    
+                    if let error = error {
+                        completion(.failure(error))
+                    } else {
+                        // Update the current user
+                        if var user = self.currentUser {
+                            // Create a new user with the updated profile picture
+                            let updatedUser = Models.User(
+                                id: user.id,
+                                username: user.username,
+                                firstName: user.firstName,
+                                lastName: user.lastName,
+                                email: user.email,
+                                phoneNumber: user.phoneNumber,
+                                bio: user.bio,
+                                location: user.location,
+                                friends: user.friends,
+                                scores: user.scores,
+                                steps: user.steps,
+                                profilePicture: imageURL,
+                                notificationsEnabled: user.notificationsEnabled,
+                                selectedLanguage: user.selectedLanguage
+                            )
+                            self.currentUser = updatedUser
+                        }
+                        
+                        completion(.success(imageURL))
+                    }
+                }
+                
+            case .failure(let error):
+                self.isLoading = false
+                completion(.failure(error))
+            }
+        }
+    }
+    
+    // MARK: - User Search
+    
+    func searchUsers(query: String, completion: @escaping (Result<[Models.User], Error>) -> Void) {
+        isLoading = true
+        
+        // Create queries for username, firstName, lastName and phoneNumber
+        let usernameQuery = db.collection("users")
+            .whereField("username", isGreaterThanOrEqualTo: query)
+            .whereField("username", isLessThanOrEqualTo: query + "\u{f8ff}")
+            .limit(to: 20)
+            
+        let phoneQuery = db.collection("users")
+            .whereField("phoneNumber", isGreaterThanOrEqualTo: query)
+            .whereField("phoneNumber", isLessThanOrEqualTo: query + "\u{f8ff}")
+            .limit(to: 20)
+            
+        let nameQuery = db.collection("users")
+            .whereField("firstName", isGreaterThanOrEqualTo: query)
+            .whereField("firstName", isLessThanOrEqualTo: query + "\u{f8ff}")
+            .limit(to: 20)
+            
+        let lastNameQuery = db.collection("users")
+            .whereField("lastName", isGreaterThanOrEqualTo: query)
+            .whereField("lastName", isLessThanOrEqualTo: query + "\u{f8ff}")
+            .limit(to: 20)
+        
+        // Execute all queries
+        var users: [Models.User] = []
+        var errors: [Error] = []
+        let group = DispatchGroup()
+        
+        // Username query
+        group.enter()
+        usernameQuery.getDocuments { snapshot, error in
+            defer { group.leave() }
+            
+            if let error = error {
+                errors.append(error)
+                return
+            }
+            
+            if let documents = snapshot?.documents {
+                for doc in documents {
+                    if let user = Models.User.fromDictionary(doc.data(), id: doc.documentID) {
+                        users.append(user)
+                    }
+                }
+            }
+        }
+        
+        // Phone query
+        group.enter()
+        phoneQuery.getDocuments { snapshot, error in
+            defer { group.leave() }
+            
+            if let error = error {
+                errors.append(error)
+                return
+            }
+            
+            if let documents = snapshot?.documents {
+                for doc in documents {
+                    if let user = Models.User.fromDictionary(doc.data(), id: doc.documentID) {
+                        // Avoid duplicates
+                        if !users.contains(where: { $0.id == user.id }) {
+                            users.append(user)
+                        }
+                    }
+                }
+            }
+        }
+        
+        // First name query
+        group.enter()
+        nameQuery.getDocuments { snapshot, error in
+            defer { group.leave() }
+            
+            if let error = error {
+                errors.append(error)
+                return
+            }
+            
+            if let documents = snapshot?.documents {
+                for doc in documents {
+                    if let user = Models.User.fromDictionary(doc.data(), id: doc.documentID) {
+                        // Avoid duplicates
+                        if !users.contains(where: { $0.id == user.id }) {
+                            users.append(user)
+                        }
+                    }
+                }
+            }
+        }
+        
+        // Last name query
+        group.enter()
+        lastNameQuery.getDocuments { snapshot, error in
+            defer { group.leave() }
+            
+            if let error = error {
+                errors.append(error)
+                return
+            }
+            
+            if let documents = snapshot?.documents {
+                for doc in documents {
+                    if let user = Models.User.fromDictionary(doc.data(), id: doc.documentID) {
+                        // Avoid duplicates
+                        if !users.contains(where: { $0.id == user.id }) {
+                            users.append(user)
+                        }
+                    }
+                }
+            }
+        }
+        
+        group.notify(queue: .main) { [weak self] in
+            self?.isLoading = false
+            
+            if !errors.isEmpty, users.isEmpty {
+                // Only return error if we have no users and at least one error
+                completion(.failure(errors.first!))
+            } else {
+                completion(.success(users))
+            }
+        }
+    }
+    
+    // MARK: - Add Score
+    
+    func addScore(score: Models.User.Score, completion: @escaping (Result<Models.User, Error>) -> Void) {
+        guard let uid = Auth.auth().currentUser?.uid else {
+            completion(.failure(NSError(domain: "UserService", code: 1001, userInfo: [NSLocalizedDescriptionKey: "User not authenticated"])))
+            return
+        }
+        
+        isLoading = true
+        
+        // Fetch current user data first
+        fetchCurrentUser { [weak self] result in
+            guard let self = self else { return }
+            
+            switch result {
+            case .success(var user):
+                // Create a new user with updated scores
+                var scores = user.scores
+                scores.append(score)
+                
+                let updatedUser = Models.User(
+                    id: user.id,
+                    username: user.username,
+                    firstName: user.firstName,
+                    lastName: user.lastName,
+                    email: user.email,
+                    phoneNumber: user.phoneNumber,
+                    bio: user.bio,
+                    location: user.location,
+                    friends: user.friends,
+                    scores: scores,
+                    steps: user.steps,
+                    profilePicture: user.profilePicture,
+                    notificationsEnabled: user.notificationsEnabled,
+                    selectedLanguage: user.selectedLanguage
+                )
+                
+                // Update the user document with the new scores array
+                self.db.collection("users").document(uid).updateData([
+                    "scores": updatedUser.scores.map { score in
+                        return [
+                            "id": score.id,
+                            "course": score.course,
+                            "score": score.score,
+                            "date": score.date,
+                            "holesPlayed": score.holesPlayed,
+                            "steps": score.steps ?? 0,
+                            "distance": score.distance ?? 0.0,
+                            "caloriesBurned": score.caloriesBurned ?? 0.0
+                        ]
+                    }
+                ]) { error in
+                    self.isLoading = false
+                    
+                    if let error = error {
+                        completion(.failure(error))
+                    } else {
+                        self.currentUser = updatedUser
+                        completion(.success(updatedUser))
+                    }
+                }
+                
+            case .failure(let error):
+                self.isLoading = false
+                completion(.failure(error))
+            }
+        }
+    }
+}
diff --git a/Aldo/Views/WelcomeView.swift b/Aldo/Views/WelcomeView.swift
new file mode 100644
index 0000000..ccadba6
--- /dev/null
+++ b/Aldo/Views/WelcomeView.swift
@@ -0,0 +1,150 @@
+import SwiftUI
+import AuthenticationServices
+
+// Custom wrapper for the Sign In with Apple button
+struct CustomSignInWithAppleButton: UIViewRepresentable {
+    func makeUIView(context: Context) -> ASAuthorizationAppleIDButton {
+        let button = ASAuthorizationAppleIDButton(type: .signIn, style: .black)
+        button.translatesAutoresizingMaskIntoConstraints = false // Disable autoresizing mask constraints
+        return button
+    }
+
+    func updateUIView(_ uiView: ASAuthorizationAppleIDButton, context: Context) {
+        // No updates required for this button
+    }
+}
+
+class WelcomeViewController: UIViewController, ASAuthorizationControllerDelegate, ASAuthorizationControllerPresentationContextProviding {
+    @AppStorage("hasShownWelcome") private var hasShownWelcome = false
+    @State private var isSignedIn = false
+
+    override func viewDidLoad() {
+        super.viewDidLoad()
+    }
+
+    func performAppleSignIn() {
+        let request = ASAuthorizationAppleIDProvider().createRequest()
+        request.requestedScopes = [.fullName, .email]
+
+        let controller = ASAuthorizationController(authorizationRequests: [request])
+        controller.delegate = self
+        controller.presentationContextProvider = self
+        controller.performRequests()
+    }
+
+    func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) {
+        if let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential {
+            let userIdentifier = appleIDCredential.user
+            let fullName = appleIDCredential.fullName
+            let email = appleIDCredential.email
+
+            print("Apple ID Credential - User: \(userIdentifier), Full Name: \(String(describing: fullName)), Email: \(String(describing: email))")
+
+            self.isSignedIn = true
+            hasShownWelcome = true // Mark welcome as shown
+        }
+    }
+
+    func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) {
+        print("Failed to sign in with Apple: \(error.localizedDescription)")
+    }
+
+    func presentationAnchor(for controller: ASAuthorizationController) -> ASPresentationAnchor {
+        return self.view.window ?? ASPresentationAnchor()
+    }
+}
+
+// SwiftUI View that wraps the ViewController for Sign In with Apple
+struct WelcomeView: View {
+    @AppStorage("hasShownWelcome") private var hasShownWelcome = false
+    @State private var isSignedIn = false
+
+    var body: some View {
+        NavigationView {
+            ZStack {
+                // Background Image with resized size
+                Image("newAldo")
+                    .resizable()
+                    .scaledToFit() // Change this to .scaledToFit() for proportional resizing
+                    .frame(width: 500, height: 500) // Adjust the width and height to make it smaller
+                    .clipped() // Ensure it doesn't overflow the frame
+                    .padding(.top, 50) // Adjust to add space above the image if needed
+
+                VStack {
+                    Text("Welcome to")
+                        .font(.system(size: 60, weight: .heavy, design: .rounded)) // Large, heavy system font
+                        .foregroundColor(.black)
+                        .padding(.top, 200) // Space from the top of the screen
+                        .padding(.bottom, 50) // Space below the text
+
+
+                    Spacer() // Spacer to push the next elements down
+
+                    // Buttons at the bottom
+                    VStack(spacing: 20) {
+                        NavigationLink(destination: LoginView()) {
+                            Text("Log In")
+                                .font(.title2)
+                                .padding()
+                                .frame(maxWidth: .infinity)
+                                .background(Color.blue)
+                                .foregroundColor(.white)
+                                .cornerRadius(10)
+                                .shadow(radius: 5)
+                        }
+                        .padding(.horizontal, 40)
+
+                        NavigationLink(destination: SignUpView()) {
+                            Text("Sign Up")
+                                .font(.title2)
+                                .padding()
+                                .frame(maxWidth: .infinity)
+                                .background(Color.green)
+                                .foregroundColor(.white)
+                                .cornerRadius(10)
+                                .shadow(radius: 5)
+                        }
+                        .padding(.horizontal, 40)
+
+                        // Custom Sign In with Apple Button
+                        CustomSignInWithAppleButton()
+                            .frame(height: 50)
+                            .padding(.horizontal, 40)
+                            .accessibilityLabel(Text("Sign in with Apple"))
+                            .onTapGesture {
+                                performAppleSignIn()
+                            }
+                    }
+                    .padding(.bottom, 40) // Adjust the bottom padding to position the buttons better
+                }
+                .padding()
+            }
+        }
+    }
+
+    private func performAppleSignIn() {
+        let viewController = WelcomeViewController()
+        viewController.performAppleSignIn()
+    }
+}
+
+// Root view to manage app state
+struct RootView: View {
+    @AppStorage("hasShownWelcome") private var hasShownWelcome = false
+    
+    var body: some View {
+        Group {
+            if !hasShownWelcome {
+                WelcomeView()
+            } else {
+                MainView()
+            }
+        }
+    }
+}
+
+struct WelcomeView_Previews: PreviewProvider {
+    static var previews: some View {
+        WelcomeView()
+    }
+}
diff --git a/Aldo/WatchWorkoutManager.swift b/Aldo/WatchWorkoutManager.swift
new file mode 100644
index 0000000..d27d9fa
--- /dev/null
+++ b/Aldo/WatchWorkoutManager.swift
@@ -0,0 +1,107 @@
+//  WatchWorkoutManager.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/19/24.
+//
+
+
+
+import Foundation
+import HealthKit
+import WatchConnectivity
+
+class WatchWorkoutManager: NSObject, ObservableObject, WCSessionDelegate, HKLiveWorkoutBuilderDelegate {
+    @Published var steps: Int = 0
+    @Published var distance: Double = 0.0
+    @Published var caloriesBurned: Double = 0.0
+
+    private var healthStore = HKHealthStore()
+    private var session: WCSession?
+    private var workoutSession: HKWorkoutSession?
+    private var workoutBuilder: HKLiveWorkoutBuilder?
+
+    override init() {
+        super.init()
+        if WCSession.isSupported() {
+            session = WCSession.default
+            session?.delegate = self
+            session?.activate()
+        }
+    }
+
+    func startWorkout() {
+        let configuration = HKWorkoutConfiguration()
+        configuration.activityType = .golf // Choose appropriate activity type
+        configuration.locationType = .outdoor
+
+        do {
+            workoutSession = try HKWorkoutSession(healthStore: healthStore, configuration: configuration)
+            workoutBuilder = workoutSession?.associatedWorkoutBuilder()
+
+            workoutBuilder?.dataSource = HKLiveWorkoutDataSource(healthStore: healthStore, workoutConfiguration: configuration)
+            workoutBuilder?.delegate = self
+
+            workoutSession?.startActivity(with: Date())
+            workoutBuilder?.beginCollection(withStart: Date(), completion: { (success, error) in
+                if let error = error {
+                    print("Error starting workout collection: \(error.localizedDescription)")
+                }
+            })
+        } catch {
+            print("Error starting workout: \(error.localizedDescription)")
+        }
+    }
+
+    // MARK: - WCSessionDelegate methods
+    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
+        if let error = error {
+            print("WCSession activation failed with error: \(error.localizedDescription)")
+        } else {
+            print("WCSession activated with state: \(activationState.rawValue)")
+        }
+    }
+
+    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
+        if message["command"] as? String == "startWorkout" {
+            startWorkout()
+        }
+    }
+
+    func workoutBuilder(_ workoutBuilder: HKLiveWorkoutBuilder, didCollectDataOf collectedTypes: Set<HKSampleType>) {
+        for type in collectedTypes {
+            if let quantityType = type as? HKQuantityType {
+                let statistics = workoutBuilder.statistics(for: quantityType)
+                let value = statistics?.sumQuantity()?.doubleValue(for: .count())
+
+                DispatchQueue.main.async {
+                    if quantityType == HKQuantityType.quantityType(forIdentifier: .stepCount) {
+                        self.steps = Int(value ?? 0)
+                        self.sendWorkoutDataToiPhone()
+                    } else if quantityType == HKQuantityType.quantityType(forIdentifier: .distanceWalkingRunning) {
+                        self.distance = (value ?? 0.0) / 1609.34 // Convert meters to miles
+                        self.sendWorkoutDataToiPhone()
+                    } else if quantityType == HKQuantityType.quantityType(forIdentifier: .activeEnergyBurned) {
+                        self.caloriesBurned = value ?? 0.0
+                        self.sendWorkoutDataToiPhone()
+                    }
+                }
+            }
+        }
+    }
+
+    func workoutBuilderDidCollectEvent(_ workoutBuilder: HKLiveWorkoutBuilder) {
+        // Handle workout events if necessary
+    }
+
+    func sendWorkoutDataToiPhone() {
+        let workoutData: [String: Any] = [
+            "steps": steps,
+            "distance": distance,
+            "calories": caloriesBurned
+        ]
+
+        session?.sendMessage(workoutData, replyHandler: nil) { error in
+            print("Failed to send workout data to iPhone: \(error.localizedDescription)")
+        }
+    }
+}
diff --git a/Aldo/WorkoutStats.swift b/Aldo/WorkoutStats.swift
new file mode 100644
index 0000000..5bf169e
--- /dev/null
+++ b/Aldo/WorkoutStats.swift
@@ -0,0 +1,15 @@
+//
+//  WorkoutStats.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/25/24.
+//
+
+
+import Foundation
+
+struct WorkoutStats {
+    var steps: Int
+    var distance: Double
+    var caloriesBurned: Double
+}
diff --git a/Aldo/iOSWorkoutManager.swift b/Aldo/iOSWorkoutManager.swift
new file mode 100644
index 0000000..f513913
--- /dev/null
+++ b/Aldo/iOSWorkoutManager.swift
@@ -0,0 +1,67 @@
+//  iOSWorkoutManager.swift
+//  Aldo
+//
+//  Created by Andrew Katsifis on 6/19/24.
+//
+
+
+import WatchConnectivity
+import SwiftUI
+
+class iOSWorkoutManager: NSObject, ObservableObject, WCSessionDelegate {
+    @Published var steps: Int = 0
+    @Published var distance: Double = 0.0
+    @Published var caloriesBurned: Double = 0.0
+
+    var session: WCSession?
+
+    override init() {
+        super.init()
+        if WCSession.isSupported() {
+            session = WCSession.default
+            session?.delegate = self
+            session?.activate()
+        }
+    }
+
+    func startWorkoutOnWatch() {
+        session?.sendMessage(["command": "startWorkout"], replyHandler: nil) { error in
+            print("Failed to send message to watch: \(error.localizedDescription)")
+        }
+    }
+
+    func endWorkoutOnWatch() {
+        session?.sendMessage(["command": "endWorkout"], replyHandler: nil) { error in
+            print("Failed to send message to watch: \(error.localizedDescription)")
+        }
+    }
+
+    func session(_ session: WCSession, didReceiveMessage message: [String : Any]) {
+        if let steps = message["steps"] as? Int,
+           let distance = message["distance"] as? Double,
+           let calories = message["calories"] as? Double {
+            DispatchQueue.main.async {
+                self.steps = steps
+                self.distance = distance
+                self.caloriesBurned = calories
+            }
+        }
+    }
+
+    func session(_ session: WCSession, activationDidCompleteWith activationState: WCSessionActivationState, error: Error?) {
+        if let error = error {
+            print("WCSession activation failed with error: \(error.localizedDescription)")
+        } else {
+            print("WCSession activated with state: \(activationState.rawValue)")
+        }
+    }
+
+    func sessionDidBecomeInactive(_ session: WCSession) {
+        // Handle session inactivity
+    }
+
+    func sessionDidDeactivate(_ session: WCSession) {
+        // Handle session deactivation
+        session.activate()
+    }
+}
diff --git a/GoogleService-Info.plist b/GoogleService-Info.plist
new file mode 100644
index 0000000..0eb979f
--- /dev/null
+++ b/GoogleService-Info.plist
@@ -0,0 +1,39 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>API_KEY</key>
+	<string>AIzaSyDbl12Vmf9ETFMm_gp4lrOO_p2qGbVPw4I</string>
+	<key>GCM_SENDER_ID</key>
+	<string>836691343900</string>
+	<key>PLIST_VERSION</key>
+	<string>1</string>
+	<key>BUNDLE_ID</key>
+	<string>Aldo.Aldo</string>
+	<key>PROJECT_ID</key>
+	<string>aldo-230e5</string>
+	<key>STORAGE_BUCKET</key>
+	<string>aldo-230e5.appspot.com</string>
+	<key>IS_ADS_ENABLED</key>
+	<false/>
+	<key>IS_ANALYTICS_ENABLED</key>
+	<true/>
+	<key>IS_APPINVITE_ENABLED</key>
+	<true/>
+	<key>IS_GCM_ENABLED</key>
+	<true/>
+	<key>IS_SIGNIN_ENABLED</key>
+	<true/>
+	<key>GOOGLE_APP_ID</key>
+	<string>1:836691343900:ios:4e1458e8bcab5c6f3f3dd9</string>
+    <key>CFBundleURLTypes</key>
+    <array>
+        <dict>
+            <key>CFBundleURLSchemes</key>
+            <array>
+                <string>app-1-836691343900-ios-4e1458e8bcab5c6f3f3dd9</string>
+            </array>
+        </dict>
+    </array>
+</dict>
+</plist>
diff --git a/Pods/Headers 2/Private/Firebase/Firebase.h b/Pods/Headers 2/Private/Firebase/Firebase.h
new file mode 120000
index 0000000..07ac6eb
--- /dev/null
+++ b/Pods/Headers 2/Private/Firebase/Firebase.h	
@@ -0,0 +1 @@
+../../../Firebase/CoreOnly/Sources/Firebase.h
\ No newline at end of file
diff --git a/Pods/Headers 2/Public/Firebase/Firebase.h b/Pods/Headers 2/Public/Firebase/Firebase.h
new file mode 120000
index 0000000..07ac6eb
--- /dev/null
+++ b/Pods/Headers 2/Public/Firebase/Firebase.h	
@@ -0,0 +1 @@
+../../../Firebase/CoreOnly/Sources/Firebase.h
\ No newline at end of file
diff --git a/Scripts/update_plist.sh b/Scripts/update_plist.sh
new file mode 100755
index 0000000..71f03f6
--- /dev/null
+++ b/Scripts/update_plist.sh
@@ -0,0 +1,25 @@
+#!/bin/bash
+set -e  # Exit immediately if a command exits with a non-zero status
+set -x  # Print commands and their arguments as they are executed
+
+# Path to the Info.plist file
+PLIST_PATH="${TARGET_BUILD_DIR}/${INFOPLIST_PATH}"
+
+# Debugging: Print the resolved path
+echo "Resolved Info.plist path: $PLIST_PATH"
+
+# Check if PLIST_PATH exists
+if [ ! -f "$PLIST_PATH" ]; then
+  echo "Error: Info.plist file not found at $PLIST_PATH"
+  exit 1
+fi
+
+# Add NSHealthUpdateUsageDescription if it doesn't exist
+/usr/libexec/PlistBuddy -c "Print :NSHealthUpdateUsageDescription" "$PLIST_PATH" || \
+/usr/libexec/PlistBuddy -c "Add :NSHealthUpdateUsageDescription string 'This app requires access to your health data to track and analyze your workouts and heart rate during golf sessions.'" "$PLIST_PATH"
+
+# Add NSHealthShareUsageDescription if it doesn't exist
+/usr/libexec/PlistBuddy -c "Print :NSHealthShareUsageDescription" "$PLIST_PATH" || \
+/usr/libexec/PlistBuddy -c "Add :NSHealthShareUsageDescription string 'This app requires access to your health data to display and analyze your workout history and other health metrics.'" "$PLIST_PATH"
+
+echo "Updated Info.plist at $PLIST_PATH"
